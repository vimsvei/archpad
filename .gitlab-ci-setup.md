# GitLab CI/CD Setup Guide

## Настройка переменных окружения в GitLab

Для работы CI/CD pipeline необходимо настроить следующие переменные в GitLab:

### Обязательные переменные

1. **`REGISTRY_USERNAME`** - имя пользователя для Container Registry TimeWeb
2. **`REGISTRY_PASSWORD`** - API токен для Container Registry TimeWeb

### Опциональные переменные

- **`REGISTRY_URL`** - URL Container Registry (по умолчанию: `registry.timeweb.cloud`)
- **`REGISTRY_IMAGE_PREFIX`** - префикс для имен образов (по умолчанию: `archpad`)

## Настройка переменных в GitLab

1. Перейдите в **Settings → CI/CD → Variables**
2. Добавьте переменные:
   - `REGISTRY_USERNAME` (Type: Variable, Protected: false, Masked: false)
   - `REGISTRY_PASSWORD` (Type: Variable, Protected: true, Masked: true)

## Альтернатива: Загрузка секретов из Vault

Если вы хотите загружать секреты из Vault автоматически, можно добавить в `.gitlab-ci.yml`:

```yaml
before_script:
  - |
    # Загрузка секретов из Vault
    VAULT_ADDR="https://vault.archpad.pro"
    VAULT_TOKEN="$VAULT_TOKEN"  # Токен из GitLab Variables
    
    REGISTRY_USERNAME=$(curl -sS -H "X-Vault-Token: ${VAULT_TOKEN}" \
      "${VAULT_ADDR}/v1/kv/data/archpad/demo/registry" | \
      jq -r '.data.data.REGISTRY_USERNAME')
    
    REGISTRY_PASSWORD=$(curl -sS -H "X-Vault-Token: ${VAULT_TOKEN}" \
      "${VAULT_ADDR}/v1/kv/data/archpad/demo/registry" | \
      jq -r '.data.data.REGISTRY_PASSWORD')
```

## Настройка Runner

### Вариант 1: Использование Shared Runner (рекомендуется для начала)

Если у вас есть Shared Runner в GitLab, jobs будут выполняться на нем автоматически (тег `docker` убран из конфигурации).

### Вариант 2: Настройка собственного Runner с тегом `docker`

Если вы хотите использовать собственный Runner с тегом `docker`, настройте его:

```toml
[[runners]]
  name = "docker-runner"
  url = "https://gitlab.com/"
  token = "YOUR_RUNNER_TOKEN"
  executor = "docker"
  tags = ["docker"]  # Добавьте тег
  [runners.docker]
    image = "docker:24-dind"
    privileged = true
    volumes = ["/certs/client", "/cache"]
```

После настройки runner, верните тег `docker` в jobs в `.gitlab-ci.yml`:

```yaml
build:arch-repo-service:
  extends: .build_docker_image
  variables:
    DOCKERFILE_PATH: "packages/backend/apps/arch-repo-service/Dockerfile"
    BUILD_CONTEXT: "."
  tags:
    - docker  # Верните тег, если используете собственный runner
```

## Тегирование образов

Образы тегируются двумя способами:
- По git commit SHA (первые 8 символов): `arch-repo-service:abc12345`
- Latest: `arch-repo-service:latest`

## Обновление образов в Kubernetes

После успешной сборки образов, обновите манифесты Kubernetes:

### Вариант 1: ArgoCD Image Updater (рекомендуется)

Настройте ArgoCD Image Updater для автоматического обновления образов:

```yaml
# В ArgoCD Application добавьте аннотацию:
argocd-image-updater.argoproj.io/image-list: arch-repo-service=registry.timeweb.cloud/archpad/arch-repo-service
argocd-image-updater.argoproj.io/write-back-method: git
```

### Вариант 2: Ручное обновление

Обновите `image` в манифестах Kubernetes:

```yaml
# infra/timeweb/10-gitops/apps/backend/arch-repo-service/arch-repo-service.deployment.yaml
image: registry.timeweb.cloud/archpad/arch-repo-service:abc12345
```

Затем закоммитьте изменения, ArgoCD автоматически синхронизирует.

### Вариант 3: kubectl set image

```bash
kubectl set image deployment/arch-repo-service \
  arch-repo-service=registry.timeweb.cloud/archpad/arch-repo-service:abc12345 \
  -n platform
```

## Проверка работы

После настройки:

1. Сделайте коммит в `main` или `develop` ветку
2. Pipeline автоматически запустится
3. Проверьте логи сборки в GitLab CI/CD
4. Убедитесь, что образы успешно загружены в Container Registry
