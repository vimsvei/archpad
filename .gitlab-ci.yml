stages:
  - build
  - version
  - deploy

variables:
  # Container Registry TimeWeb
  # REGISTRY_URL –∏ REGISTRY_IMAGE_PREFIX –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –≤ GitLab CI/CD Variables
  # –ï—Å–ª–∏ –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã, –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é:
  REGISTRY_URL: "${REGISTRY_URL:-archpad-cr.registry.twcstorage.ru}"
  REGISTRY_IMAGE_PREFIX: "${REGISTRY_IMAGE_PREFIX:-archpad}"
  
  # Docker build settings
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"

# –®–∞–±–ª–æ–Ω –¥–ª—è —Å–±–æ—Ä–∫–∏ Docker –æ–±—Ä–∞–∑–∞
.build_docker_image:
  stage: build
  image: docker:24-dind
  services:
    - docker:24-dind
  before_script:
    - export COMMIT_SHA=$(echo $CI_COMMIT_SHA | cut -c1-8)
    # –ò–∑–≤–ª–µ–∫–∞–µ–º –≤–µ—Ä—Å–∏—é –∏–∑ –∏–º–µ–Ω–∏ –≤–µ—Ç–∫–∏ (r/X.Y.Z –∏–ª–∏ r-x.y.z)
    - |
      if echo "$CI_COMMIT_REF_NAME" | grep -qE '^r[/-][0-9]+\.[0-9]+\.[0-9]+$'; then
        # –ò–∑–≤–ª–µ–∫–∞–µ–º –≤–µ—Ä—Å–∏—é –∏–∑ –≤–µ—Ç–∫–∏ (r/X.Y.Z -> X.Y.Z –∏–ª–∏ r-x.y.z -> x.y.z)
        VERSION=$(echo "$CI_COMMIT_REF_NAME" | sed -E 's/^r[\/-]([0-9]+\.[0-9]+\.[0-9]+)$/\1/')
        export VERSION
        echo "Version extracted from branch: $VERSION"
      else
        echo "ERROR: Branch name must match pattern r/X.Y.Z or r-x.y.z"
        echo "Current branch: $CI_COMMIT_REF_NAME"
        exit 1
      fi
    # –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ REGISTRY_URL –∏ REGISTRY_IMAGE_PREFIX –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –≤ GitLab CI/CD Variables
    # –û–Ω–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –¥–æ—Å—Ç—É–ø–Ω—ã, –Ω–æ —É–±–µ–¥–∏–º—Å—è, —á—Ç–æ –æ–Ω–∏ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã
    - export REGISTRY_URL="${REGISTRY_URL:-archpad-cr.registry.twcstorage.ru}"
    - export REGISTRY_IMAGE_PREFIX="${REGISTRY_IMAGE_PREFIX:-archpad}"
    - 'echo "Building for version $VERSION (commit $COMMIT_SHA)"'
    - 'echo "Branch: $CI_COMMIT_REF_NAME"'
    - 'echo "Registry URL: $REGISTRY_URL"'
    - 'echo "Registry Image Prefix: $REGISTRY_IMAGE_PREFIX"'
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º VAULT_TOKEN –¥–ª—è portal (–Ω—É–∂–µ–Ω –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–µ–∫—Ä–µ—Ç–æ–≤ –≤–æ –≤—Ä–µ–º—è —Å–±–æ—Ä–∫–∏)
    - |
      export SERVICE_NAME_CHECK="${CI_JOB_NAME#build:}"
      if [ "$SERVICE_NAME_CHECK" = "portal" ] && [ -z "$VAULT_TOKEN" ]; then
        echo "=========================================="
        echo "WARNING: VAULT_TOKEN is not set"
        echo "=========================================="
        echo "For portal builds, VAULT_TOKEN is required to fetch NEXT_PUBLIC_* secrets from Vault."
        echo "Please set VAULT_TOKEN in GitLab CI/CD Variables:"
        echo "  Settings ‚Üí CI/CD ‚Üí Variables ‚Üí Add variable"
        echo "  Key: VAULT_TOKEN"
        echo "  Value: your-vault-token"
        echo "  Type: Variable"
        echo "  Flags: Masked (recommended)"
        echo "=========================================="
        echo "Build will continue, but NEXT_PUBLIC_* variables may be missing."
      fi
    - |
      if [ -z "$REGISTRY_USERNAME" ] || [ -z "$REGISTRY_PASSWORD" ]; then
        echo "=========================================="
        echo "ERROR: Missing required CI/CD Variables"
        echo "=========================================="
        echo "Please set the following variables in GitLab:"
        echo "  Settings ‚Üí CI/CD ‚Üí Variables ‚Üí Expand"
        echo ""
        echo "Required variables:"
        [ -z "$REGISTRY_USERNAME" ] && echo "  ‚ùå REGISTRY_USERNAME (not set)" || echo "  ‚úÖ REGISTRY_USERNAME (set)"
        [ -z "$REGISTRY_PASSWORD" ] && echo "  ‚ùå REGISTRY_PASSWORD (not set)" || echo "  ‚úÖ REGISTRY_PASSWORD (set)"
        echo ""
        echo "How to set:"
        echo "  1. Go to: Settings ‚Üí CI/CD ‚Üí Variables"
        echo "  2. Click 'Add variable'"
        echo "  3. Set Key: REGISTRY_USERNAME, Value: your-registry-username"
        echo "  4. Set Key: REGISTRY_PASSWORD, Value: your-registry-password (masked)"
        echo "  5. Save and retry the pipeline"
        echo "=========================================="
        exit 1
      fi
    - 'echo "Logging in to registry: $REGISTRY_URL"'
    - echo "$REGISTRY_PASSWORD" | docker login -u "$REGISTRY_USERNAME" --password-stdin "$REGISTRY_URL"
    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–µ–∫—Ä–µ—Ç–æ–≤ –∏–∑ Vault –¥–ª—è portal
    # –§—É–Ω–∫—Ü–∏—è –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ –≤ before_script, —á—Ç–æ–±—ã –±—ã—Ç—å –¥–æ—Å—Ç—É–ø–Ω–æ–π –≤ script
    - |
      get_vault_secrets_for_portal() {
        local VAULT_ADDR="${VAULT_ADDR:-https://vault.archpad.pro}"
        local VAULT_SECRET_PATH="kv/data/archpad/demo/frontend/portal"
        local VAULT_TOLGEE_API_KEY_PATH="kv/data/archpad/demo/tolgee/api-key"
        
        if [ -z "$VAULT_TOKEN" ]; then
          echo "ERROR: VAULT_TOKEN is not set"
          echo "Please set VAULT_TOKEN in GitLab CI/CD Variables"
          return 1
        fi
        
        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º curl –∏ jq –µ—Å–ª–∏ –∏—Ö –Ω–µ—Ç (–¥–ª—è alpine –æ–±—Ä–∞–∑–∞)
        if ! command -v curl >/dev/null 2>&1; then
          apk add --no-cache curl >/dev/null 2>&1 || true
        fi
        if ! command -v jq >/dev/null 2>&1; then
          apk add --no-cache jq >/dev/null 2>&1 || true
        fi
        
        echo "Fetching secrets from Vault: ${VAULT_ADDR}/${VAULT_SECRET_PATH}"
        
        # –ü–æ–ª—É—á–∞–µ–º —Å–µ–∫—Ä–µ—Ç—ã –∏–∑ Vault
        local response=$(curl -s -H "X-Vault-Token: ${VAULT_TOKEN}" \
          "${VAULT_ADDR}/v1/${VAULT_SECRET_PATH}" 2>&1)
        
        if [ $? -ne 0 ] || echo "$response" | jq -e '.errors' >/dev/null 2>&1; then
          echo "ERROR: Failed to fetch secrets from Vault"
          echo "$response" | jq -r '.errors[]?' 2>/dev/null || echo "$response"
          return 1
        fi
        
        # –ü–æ–ª—É—á–∞–µ–º NEXT_PUBLIC_TOLGEE_API_KEY –∏–∑ –æ—Ç–¥–µ–ª—å–Ω–æ–≥–æ –ø—É—Ç–∏
        echo "Fetching NEXT_PUBLIC_TOLGEE_API_KEY from Vault: ${VAULT_ADDR}/${VAULT_TOLGEE_API_KEY_PATH}"
        local tolgee_api_key_response=$(curl -s -H "X-Vault-Token: ${VAULT_TOKEN}" \
          "${VAULT_ADDR}/v1/${VAULT_TOLGEE_API_KEY_PATH}" 2>&1)
        
        if [ $? -ne 0 ] || echo "$tolgee_api_key_response" | jq -e '.errors' >/dev/null 2>&1; then
          echo "ERROR: Failed to fetch NEXT_PUBLIC_TOLGEE_API_KEY from Vault"
          echo "$tolgee_api_key_response" | jq -r '.errors[]?' 2>/dev/null || echo "$tolgee_api_key_response"
          return 1
        fi
        
        # –ò–∑–≤–ª–µ–∫–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏–∑ –æ—Ç–≤–µ—Ç–∞ Vault
        export NEXT_PUBLIC_TOLGEE_API_KEY=$(echo "$tolgee_api_key_response" | jq -r '.data.data.NEXT_PUBLIC_TOLGEE_API_KEY // empty')
        export NEXT_PUBLIC_TOLGEE_API_URL=$(echo "$response" | jq -r '.data.data.NEXT_PUBLIC_TOLGEE_API_URL // empty')
        export NEXT_PUBLIC_URL=$(echo "$response" | jq -r '.data.data.NEXT_PUBLIC_URL // empty')
        export NEXT_PUBLIC_HASURA_GRAPHQL_ENDPOINT=$(echo "$response" | jq -r '.data.data.NEXT_PUBLIC_HASURA_GRAPHQL_ENDPOINT // empty')
        export NEXT_PUBLIC_ORY_SDK_URL=$(echo "$response" | jq -r '.data.data.NEXT_PUBLIC_ORY_SDK_URL // empty')
        export NEXT_PUBLIC_API_GRAPHQL_ENDPOINT=$(echo "$response" | jq -r '.data.data.NEXT_PUBLIC_API_GRAPHQL_ENDPOINT // empty')
        
        echo "‚úÖ Successfully fetched secrets from Vault"
        echo "  NEXT_PUBLIC_TOLGEE_API_KEY: ${NEXT_PUBLIC_TOLGEE_API_KEY:+***SET***}"
        echo "  NEXT_PUBLIC_TOLGEE_API_URL: ${NEXT_PUBLIC_TOLGEE_API_URL:+***SET***}"
        echo "  NEXT_PUBLIC_URL: ${NEXT_PUBLIC_URL:+***SET***}"
        echo "  NEXT_PUBLIC_HASURA_GRAPHQL_ENDPOINT: ${NEXT_PUBLIC_HASURA_GRAPHQL_ENDPOINT:+***SET***}"
        echo "  NEXT_PUBLIC_ORY_SDK_URL: ${NEXT_PUBLIC_ORY_SDK_URL:+***SET***}"
        echo "  NEXT_PUBLIC_API_GRAPHQL_ENDPOINT: ${NEXT_PUBLIC_API_GRAPHQL_ENDPOINT:+***SET***}"
      }
  script:
    - export SERVICE_NAME="${CI_JOB_NAME#build:}"
    # –£–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã (–∏–∑ GitLab Variables –∏–ª–∏ fallback)
    - export REGISTRY_URL="${REGISTRY_URL:-archpad-cr.registry.twcstorage.ru}"
    - export REGISTRY_IMAGE_PREFIX="${REGISTRY_IMAGE_PREFIX:-archpad}"
    # –§–æ—Ä–º–∏—Ä—É–µ–º —Ç–µ–≥–∏ –æ–±—Ä–∞–∑–æ–≤: x.y.z-<commit-sha> –∏ latest
    - export IMAGE_TAG_VERSION="${REGISTRY_URL}/${REGISTRY_IMAGE_PREFIX}/${SERVICE_NAME}:${VERSION}-${COMMIT_SHA}"
    - export IMAGE_TAG_LATEST="${REGISTRY_URL}/${REGISTRY_IMAGE_PREFIX}/${SERVICE_NAME}:latest"
    - 'echo "Building $SERVICE_NAME version $VERSION (commit $COMMIT_SHA)"'
    - |
      echo "Image tags:"
      echo "  - ${IMAGE_TAG_VERSION}"
      echo "  - ${IMAGE_TAG_LATEST}"
    - 'echo "Dockerfile: $DOCKERFILE_PATH"'
    - 'echo "Build context: $BUILD_CONTEXT"'
    # –î–ª—è portal –ø–æ–ª—É—á–∞–µ–º —Å–µ–∫—Ä–µ—Ç—ã –∏–∑ Vault –∏ –ø–µ—Ä–µ–¥–∞–µ–º NEXT_PUBLIC_* –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∫–∞–∫ build-args
    # –≠—Ç–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –¥–æ—Å—Ç—É–ø–Ω—ã –≤–æ –≤—Ä–µ–º—è —Å–±–æ—Ä–∫–∏ Next.js
    - |
      if [ "$SERVICE_NAME" = "portal" ]; then
        echo "Building portal - fetching secrets from Vault..."
        get_vault_secrets_for_portal
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –Ω–µ –ø—É—Å—Ç—ã–µ
        if [ -z "$NEXT_PUBLIC_TOLGEE_API_KEY" ] || [ -z "$NEXT_PUBLIC_TOLGEE_API_URL" ]; then
          echo "ERROR: Required NEXT_PUBLIC_* variables are empty after fetching from Vault"
          echo "  NEXT_PUBLIC_TOLGEE_API_KEY: ${NEXT_PUBLIC_TOLGEE_API_KEY:+SET}${NEXT_PUBLIC_TOLGEE_API_KEY:-NOT SET}"
          echo "  NEXT_PUBLIC_TOLGEE_API_URL: ${NEXT_PUBLIC_TOLGEE_API_URL:+SET}${NEXT_PUBLIC_TOLGEE_API_URL:-NOT SET}"
          exit 1
        fi
        
        echo "Building portal with NEXT_PUBLIC_* build arguments from Vault..."
        echo "  NEXT_PUBLIC_TOLGEE_API_KEY: ${NEXT_PUBLIC_TOLGEE_API_KEY:+***SET***}"
        echo "  NEXT_PUBLIC_TOLGEE_API_URL: ${NEXT_PUBLIC_TOLGEE_API_URL:+***SET***}"
        echo "  NEXT_PUBLIC_URL: ${NEXT_PUBLIC_URL:+***SET***}"
        echo "  NEXT_PUBLIC_HASURA_GRAPHQL_ENDPOINT: ${NEXT_PUBLIC_HASURA_GRAPHQL_ENDPOINT:+***SET***}"
        echo "  NEXT_PUBLIC_ORY_SDK_URL: ${NEXT_PUBLIC_ORY_SDK_URL:+***SET***}"
        echo "  NEXT_PUBLIC_API_GRAPHQL_ENDPOINT: ${NEXT_PUBLIC_API_GRAPHQL_ENDPOINT:+***SET***}"
        
        docker build \
          -t "$IMAGE_TAG_VERSION" \
          -t "$IMAGE_TAG_LATEST" \
          -f "$DOCKERFILE_PATH" \
          --build-arg BUILD_COMMIT_SHA="${CI_COMMIT_SHA}" \
          --build-arg BUILD_VERSION="${VERSION}" \
          --build-arg BUILD_BRANCH="${CI_COMMIT_REF_NAME}" \
          --build-arg NEXT_PUBLIC_TOLGEE_API_KEY="${NEXT_PUBLIC_TOLGEE_API_KEY}" \
          --build-arg NEXT_PUBLIC_TOLGEE_API_URL="${NEXT_PUBLIC_TOLGEE_API_URL}" \
          --build-arg NEXT_PUBLIC_URL="${NEXT_PUBLIC_URL}" \
          --build-arg NEXT_PUBLIC_HASURA_GRAPHQL_ENDPOINT="${NEXT_PUBLIC_HASURA_GRAPHQL_ENDPOINT}" \
          --build-arg NEXT_PUBLIC_ORY_SDK_URL="${NEXT_PUBLIC_ORY_SDK_URL}" \
          --build-arg NEXT_PUBLIC_API_GRAPHQL_ENDPOINT="${NEXT_PUBLIC_API_GRAPHQL_ENDPOINT}" \
          "$BUILD_CONTEXT"
      else
        docker build \
          -t "$IMAGE_TAG_VERSION" \
          -t "$IMAGE_TAG_LATEST" \
          -f "$DOCKERFILE_PATH" \
          --build-arg BUILD_COMMIT_SHA="${CI_COMMIT_SHA}" \
          --build-arg BUILD_VERSION="${VERSION}" \
          --build-arg BUILD_BRANCH="${CI_COMMIT_REF_NAME}" \
          "$BUILD_CONTEXT"
      fi
    - docker push "$IMAGE_TAG_VERSION"
    - docker push "$IMAGE_TAG_LATEST"
    - |
      echo "‚úÖ Images pushed:"
      echo "  - $IMAGE_TAG_VERSION"
      echo "  - $IMAGE_TAG_LATEST"
  after_script:
    - docker logout "$REGISTRY_URL" || true
  rules:
    # –°–æ–±–∏—Ä–∞–µ–º —Ç–æ–ª—å–∫–æ –¥–ª—è –≤–µ—Ç–æ–∫ –≤–∏–¥–∞ r/X.Y.Z –∏–ª–∏ r-x.y.z
    - if: $CI_COMMIT_REF_NAME =~ /^r[\/-][0-9]+\.[0-9]+\.[0-9]+$/

# –®–∞–±–ª–æ–Ω –¥–ª—è —Å–±–æ—Ä–∫–∏ Docker –æ–±—Ä–∞–∑–∞ –∏–∑ main –≤–µ—Ç–∫–∏
.build_docker_image_main:
  stage: build
  image: docker:24-dind
  services:
    - docker:24-dind
  before_script:
    - export COMMIT_SHA=$(echo $CI_COMMIT_SHA | cut -c1-8)
    - export REGISTRY_URL="${REGISTRY_URL:-archpad-cr.registry.twcstorage.ru}"
    - export REGISTRY_IMAGE_PREFIX="${REGISTRY_IMAGE_PREFIX:-archpad}"
    - 'echo "Building for main branch (commit $COMMIT_SHA)"'
    - 'echo "Branch: $CI_COMMIT_REF_NAME"'
    - 'echo "Registry URL: $REGISTRY_URL"'
    - 'echo "Registry Image Prefix: $REGISTRY_IMAGE_PREFIX"'
    # –ü—Ä–æ–≤–µ—Ä—è–µ–º VAULT_TOKEN –¥–ª—è portal (–Ω—É–∂–µ–Ω –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–µ–∫—Ä–µ—Ç–æ–≤ –≤–æ –≤—Ä–µ–º—è —Å–±–æ—Ä–∫–∏)
    - |
      export SERVICE_NAME_CHECK="${CI_JOB_NAME#build:main:}"
      if [ "$SERVICE_NAME_CHECK" = "portal" ] && [ -z "$VAULT_TOKEN" ]; then
        echo "=========================================="
        echo "WARNING: VAULT_TOKEN is not set"
        echo "=========================================="
        echo "For portal builds, VAULT_TOKEN is required to fetch NEXT_PUBLIC_* secrets from Vault."
        echo "Please set VAULT_TOKEN in GitLab CI/CD Variables:"
        echo "  Settings ‚Üí CI/CD ‚Üí Variables ‚Üí Add variable"
        echo "  Key: VAULT_TOKEN"
        echo "  Value: your-vault-token"
        echo "  Type: Variable"
        echo "  Flags: Masked (recommended)"
        echo "=========================================="
        echo "Build will continue, but NEXT_PUBLIC_* variables may be missing."
      fi
    - |
      if [ -z "$REGISTRY_USERNAME" ] || [ -z "$REGISTRY_PASSWORD" ]; then
        echo "=========================================="
        echo "ERROR: Missing required CI/CD Variables"
        echo "=========================================="
        echo "Please set the following variables in GitLab:"
        echo "  Settings ‚Üí CI/CD ‚Üí Variables ‚Üí Expand"
        echo ""
        echo "Required variables:"
        [ -z "$REGISTRY_USERNAME" ] && echo "  ‚ùå REGISTRY_USERNAME (not set)" || echo "  ‚úÖ REGISTRY_USERNAME (set)"
        [ -z "$REGISTRY_PASSWORD" ] && echo "  ‚ùå REGISTRY_PASSWORD (not set)" || echo "  ‚úÖ REGISTRY_PASSWORD (set)"
        echo ""
        echo "How to set:"
        echo "  1. Go to: Settings ‚Üí CI/CD ‚Üí Variables"
        echo "  2. Click 'Add variable'"
        echo "  3. Set Key: REGISTRY_USERNAME, Value: your-registry-username"
        echo "  4. Set Key: REGISTRY_PASSWORD, Value: your-registry-password (masked)"
        echo "  5. Save and retry the pipeline"
        echo "=========================================="
        exit 1
      fi
    - 'echo "Logging in to registry: $REGISTRY_URL"'
    - echo "$REGISTRY_PASSWORD" | docker login -u "$REGISTRY_USERNAME" --password-stdin "$REGISTRY_URL"
    # –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ñ—É–Ω–∫—Ü–∏—é –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–µ–∫—Ä–µ—Ç–æ–≤ –∏–∑ Vault –¥–ª—è portal
    # –§—É–Ω–∫—Ü–∏—è –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∞ –≤ before_script, —á—Ç–æ–±—ã –±—ã—Ç—å –¥–æ—Å—Ç—É–ø–Ω–æ–π –≤ script
    - |
      get_vault_secrets_for_portal() {
        local VAULT_ADDR="${VAULT_ADDR:-https://vault.archpad.pro}"
        local VAULT_SECRET_PATH="kv/data/archpad/demo/frontend/portal"
        local VAULT_TOLGEE_API_KEY_PATH="kv/data/archpad/demo/tolgee/api-key"
        
        if [ -z "$VAULT_TOKEN" ]; then
          echo "ERROR: VAULT_TOKEN is not set"
          echo "Please set VAULT_TOKEN in GitLab CI/CD Variables"
          return 1
        fi
        
        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º curl –∏ jq –µ—Å–ª–∏ –∏—Ö –Ω–µ—Ç (–¥–ª—è alpine –æ–±—Ä–∞–∑–∞)
        if ! command -v curl >/dev/null 2>&1; then
          apk add --no-cache curl >/dev/null 2>&1 || true
        fi
        if ! command -v jq >/dev/null 2>&1; then
          apk add --no-cache jq >/dev/null 2>&1 || true
        fi
        
        echo "Fetching secrets from Vault: ${VAULT_ADDR}/${VAULT_SECRET_PATH}"
        
        # –ü–æ–ª—É—á–∞–µ–º —Å–µ–∫—Ä–µ—Ç—ã –∏–∑ Vault
        local response=$(curl -s -H "X-Vault-Token: ${VAULT_TOKEN}" \
          "${VAULT_ADDR}/v1/${VAULT_SECRET_PATH}" 2>&1)
        
        if [ $? -ne 0 ] || echo "$response" | jq -e '.errors' >/dev/null 2>&1; then
          echo "ERROR: Failed to fetch secrets from Vault"
          echo "$response" | jq -r '.errors[]?' 2>/dev/null || echo "$response"
          return 1
        fi
        
        # –ü–æ–ª—É—á–∞–µ–º NEXT_PUBLIC_TOLGEE_API_KEY –∏–∑ –æ—Ç–¥–µ–ª—å–Ω–æ–≥–æ –ø—É—Ç–∏
        echo "Fetching NEXT_PUBLIC_TOLGEE_API_KEY from Vault: ${VAULT_ADDR}/${VAULT_TOLGEE_API_KEY_PATH}"
        local tolgee_api_key_response=$(curl -s -H "X-Vault-Token: ${VAULT_TOKEN}" \
          "${VAULT_ADDR}/v1/${VAULT_TOLGEE_API_KEY_PATH}" 2>&1)
        
        if [ $? -ne 0 ] || echo "$tolgee_api_key_response" | jq -e '.errors' >/dev/null 2>&1; then
          echo "ERROR: Failed to fetch NEXT_PUBLIC_TOLGEE_API_KEY from Vault"
          echo "$tolgee_api_key_response" | jq -r '.errors[]?' 2>/dev/null || echo "$tolgee_api_key_response"
          return 1
        fi
        
        # –ò–∑–≤–ª–µ–∫–∞–µ–º –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∏–∑ –æ—Ç–≤–µ—Ç–∞ Vault
        export NEXT_PUBLIC_TOLGEE_API_KEY=$(echo "$tolgee_api_key_response" | jq -r '.data.data.NEXT_PUBLIC_TOLGEE_API_KEY // empty')
        export NEXT_PUBLIC_TOLGEE_API_URL=$(echo "$response" | jq -r '.data.data.NEXT_PUBLIC_TOLGEE_API_URL // empty')
        export NEXT_PUBLIC_URL=$(echo "$response" | jq -r '.data.data.NEXT_PUBLIC_URL // empty')
        export NEXT_PUBLIC_HASURA_GRAPHQL_ENDPOINT=$(echo "$response" | jq -r '.data.data.NEXT_PUBLIC_HASURA_GRAPHQL_ENDPOINT // empty')
        export NEXT_PUBLIC_ORY_SDK_URL=$(echo "$response" | jq -r '.data.data.NEXT_PUBLIC_ORY_SDK_URL // empty')
        export NEXT_PUBLIC_API_GRAPHQL_ENDPOINT=$(echo "$response" | jq -r '.data.data.NEXT_PUBLIC_API_GRAPHQL_ENDPOINT // empty')
        
        echo "‚úÖ Successfully fetched secrets from Vault"
        echo "  NEXT_PUBLIC_TOLGEE_API_KEY: ${NEXT_PUBLIC_TOLGEE_API_KEY:+***SET***}"
        echo "  NEXT_PUBLIC_TOLGEE_API_URL: ${NEXT_PUBLIC_TOLGEE_API_URL:+***SET***}"
        echo "  NEXT_PUBLIC_URL: ${NEXT_PUBLIC_URL:+***SET***}"
        echo "  NEXT_PUBLIC_HASURA_GRAPHQL_ENDPOINT: ${NEXT_PUBLIC_HASURA_GRAPHQL_ENDPOINT:+***SET***}"
        echo "  NEXT_PUBLIC_ORY_SDK_URL: ${NEXT_PUBLIC_ORY_SDK_URL:+***SET***}"
        echo "  NEXT_PUBLIC_API_GRAPHQL_ENDPOINT: ${NEXT_PUBLIC_API_GRAPHQL_ENDPOINT:+***SET***}"
      }
  script:
    - export SERVICE_NAME="${CI_JOB_NAME#build:main:}"
    - export REGISTRY_URL="${REGISTRY_URL:-archpad-cr.registry.twcstorage.ru}"
    - export REGISTRY_IMAGE_PREFIX="${REGISTRY_IMAGE_PREFIX:-archpad}"
    # –§–æ—Ä–º–∏—Ä—É–µ–º —Ç–µ–≥–∏ –æ–±—Ä–∞–∑–æ–≤: main-<commit-sha> –∏ latest
    - export IMAGE_TAG_MAIN="${REGISTRY_URL}/${REGISTRY_IMAGE_PREFIX}/${SERVICE_NAME}:main-${COMMIT_SHA}"
    - export IMAGE_TAG_LATEST="${REGISTRY_URL}/${REGISTRY_IMAGE_PREFIX}/${SERVICE_NAME}:latest"
    - 'echo "Building $SERVICE_NAME for main branch (commit $COMMIT_SHA)"'
    - |
      echo "Image tags:"
      echo "  - ${IMAGE_TAG_MAIN}"
      echo "  - ${IMAGE_TAG_LATEST}"
    - 'echo "Dockerfile: $DOCKERFILE_PATH"'
    - 'echo "Build context: $BUILD_CONTEXT"'
    # –î–ª—è portal –ø–æ–ª—É—á–∞–µ–º —Å–µ–∫—Ä–µ—Ç—ã –∏–∑ Vault –∏ –ø–µ—Ä–µ–¥–∞–µ–º NEXT_PUBLIC_* –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –∫–∞–∫ build-args
    # –≠—Ç–∏ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –¥–æ—Å—Ç—É–ø–Ω—ã –≤–æ –≤—Ä–µ–º—è —Å–±–æ—Ä–∫–∏ Next.js
    - |
      if [ "$SERVICE_NAME" = "portal" ]; then
        echo "Building portal - fetching secrets from Vault..."
        get_vault_secrets_for_portal
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –Ω–µ –ø—É—Å—Ç—ã–µ
        if [ -z "$NEXT_PUBLIC_TOLGEE_API_KEY" ] || [ -z "$NEXT_PUBLIC_TOLGEE_API_URL" ]; then
          echo "ERROR: Required NEXT_PUBLIC_* variables are empty after fetching from Vault"
          echo "  NEXT_PUBLIC_TOLGEE_API_KEY: ${NEXT_PUBLIC_TOLGEE_API_KEY:+SET}${NEXT_PUBLIC_TOLGEE_API_KEY:-NOT SET}"
          echo "  NEXT_PUBLIC_TOLGEE_API_URL: ${NEXT_PUBLIC_TOLGEE_API_URL:+SET}${NEXT_PUBLIC_TOLGEE_API_URL:-NOT SET}"
          exit 1
        fi
        
        echo "Building portal with NEXT_PUBLIC_* build arguments from Vault..."
        echo "  NEXT_PUBLIC_TOLGEE_API_KEY: ${NEXT_PUBLIC_TOLGEE_API_KEY:+***SET***}"
        echo "  NEXT_PUBLIC_TOLGEE_API_URL: ${NEXT_PUBLIC_TOLGEE_API_URL:+***SET***}"
        echo "  NEXT_PUBLIC_URL: ${NEXT_PUBLIC_URL:+***SET***}"
        echo "  NEXT_PUBLIC_HASURA_GRAPHQL_ENDPOINT: ${NEXT_PUBLIC_HASURA_GRAPHQL_ENDPOINT:+***SET***}"
        echo "  NEXT_PUBLIC_ORY_SDK_URL: ${NEXT_PUBLIC_ORY_SDK_URL:+***SET***}"
        echo "  NEXT_PUBLIC_API_GRAPHQL_ENDPOINT: ${NEXT_PUBLIC_API_GRAPHQL_ENDPOINT:+***SET***}"
        
        docker build \
          -t "$IMAGE_TAG_MAIN" \
          -t "$IMAGE_TAG_LATEST" \
          -f "$DOCKERFILE_PATH" \
          --build-arg BUILD_COMMIT_SHA="${CI_COMMIT_SHA}" \
          --build-arg BUILD_VERSION="main" \
          --build-arg BUILD_BRANCH="${CI_COMMIT_REF_NAME}" \
          --build-arg NEXT_PUBLIC_TOLGEE_API_KEY="${NEXT_PUBLIC_TOLGEE_API_KEY}" \
          --build-arg NEXT_PUBLIC_TOLGEE_API_URL="${NEXT_PUBLIC_TOLGEE_API_URL}" \
          --build-arg NEXT_PUBLIC_URL="${NEXT_PUBLIC_URL}" \
          --build-arg NEXT_PUBLIC_HASURA_GRAPHQL_ENDPOINT="${NEXT_PUBLIC_HASURA_GRAPHQL_ENDPOINT}" \
          --build-arg NEXT_PUBLIC_ORY_SDK_URL="${NEXT_PUBLIC_ORY_SDK_URL}" \
          --build-arg NEXT_PUBLIC_API_GRAPHQL_ENDPOINT="${NEXT_PUBLIC_API_GRAPHQL_ENDPOINT}" \
          "$BUILD_CONTEXT"
      else
        docker build \
          -t "$IMAGE_TAG_MAIN" \
          -t "$IMAGE_TAG_LATEST" \
          -f "$DOCKERFILE_PATH" \
          --build-arg BUILD_COMMIT_SHA="${CI_COMMIT_SHA}" \
          --build-arg BUILD_VERSION="main" \
          --build-arg BUILD_BRANCH="${CI_COMMIT_REF_NAME}" \
          "$BUILD_CONTEXT"
      fi
    - docker push "$IMAGE_TAG_MAIN"
    - docker push "$IMAGE_TAG_LATEST"
    - |
      echo "‚úÖ Images pushed:"
      echo "  - $IMAGE_TAG_MAIN"
      echo "  - $IMAGE_TAG_LATEST"
  after_script:
    - docker logout "$REGISTRY_URL" || true
  rules:
    # –°–æ–±–∏—Ä–∞–µ–º –¥–ª—è main –≤–µ—Ç–∫–∏ –∏ MR –≤ main, —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∏–∑–º–µ–Ω–µ–Ω—ã —Ñ–∞–π–ª—ã –≤ packages/
    - if: $CI_COMMIT_REF_NAME == "main" && $CI_PIPELINE_SOURCE == "push"
      changes:
        - packages/**/*
    - if: $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "main" && $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - packages/**/*

# ============================================
# Backend Services
# ============================================

build:arch-repo-service:
  extends: .build_docker_image
  variables:
    DOCKERFILE_PATH: "packages/backend/apps/arch-repo-service/Dockerfile"
    BUILD_CONTEXT: "."

build:tenant-service:
  extends: .build_docker_image
  variables:
    DOCKERFILE_PATH: "packages/backend/apps/tenant-service/Dockerfile"
    BUILD_CONTEXT: "."

build:hasura-sync-service:
  extends: .build_docker_image
  variables:
    DOCKERFILE_PATH: "packages/backend/apps/hasura-sync-service/Dockerfile"
    BUILD_CONTEXT: "."

# ============================================
# Frontend
# ============================================

build:portal:
  extends: .build_docker_image
  variables:
    DOCKERFILE_PATH: "packages/portal/Dockerfile"
    BUILD_CONTEXT: "."

# ============================================
# Backend Services (main –≤–µ—Ç–∫–∞)
# ============================================

build:main:arch-repo-service:
  extends: .build_docker_image_main
  variables:
    DOCKERFILE_PATH: "packages/backend/apps/arch-repo-service/Dockerfile"
    BUILD_CONTEXT: "."
  rules:
    # –°–æ–±–∏—Ä–∞–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∏–∑–º–µ–Ω–µ–Ω—ã —Ñ–∞–π–ª—ã –≤ arch-repo-service
    - if: $CI_COMMIT_REF_NAME == "main" && $CI_PIPELINE_SOURCE == "push"
      changes:
        - packages/backend/apps/arch-repo-service/**/*
        - packages/contract/**/*
    - if: $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "main" && $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - packages/backend/apps/arch-repo-service/**/*
        - packages/contract/**/*

build:main:tenant-service:
  extends: .build_docker_image_main
  variables:
    DOCKERFILE_PATH: "packages/backend/apps/tenant-service/Dockerfile"
    BUILD_CONTEXT: "."
  rules:
    # –°–æ–±–∏—Ä–∞–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∏–∑–º–µ–Ω–µ–Ω—ã —Ñ–∞–π–ª—ã –≤ tenant-service
    - if: $CI_COMMIT_REF_NAME == "main" && $CI_PIPELINE_SOURCE == "push"
      changes:
        - packages/backend/apps/tenant-service/**/*
        - packages/contract/**/*
    - if: $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "main" && $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - packages/backend/apps/tenant-service/**/*
        - packages/contract/**/*

build:main:hasura-sync-service:
  extends: .build_docker_image_main
  variables:
    DOCKERFILE_PATH: "packages/backend/apps/hasura-sync-service/Dockerfile"
    BUILD_CONTEXT: "."
  rules:
    # –°–æ–±–∏—Ä–∞–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∏–∑–º–µ–Ω–µ–Ω—ã —Ñ–∞–π–ª—ã –≤ hasura-sync-service
    - if: $CI_COMMIT_REF_NAME == "main" && $CI_PIPELINE_SOURCE == "push"
      changes:
        - packages/backend/apps/hasura-sync-service/**/*
        - packages/contract/**/*
    - if: $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "main" && $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - packages/backend/apps/hasura-sync-service/**/*
        - packages/contract/**/*

# ============================================
# Frontend (main –≤–µ—Ç–∫–∞)
# ============================================

build:main:portal:
  extends: .build_docker_image_main
  variables:
    DOCKERFILE_PATH: "packages/portal/Dockerfile"
    BUILD_CONTEXT: "."
  rules:
    # –°–æ–±–∏—Ä–∞–µ–º —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∏–∑–º–µ–Ω–µ–Ω—ã —Ñ–∞–π–ª—ã –≤ portal
    - if: $CI_COMMIT_REF_NAME == "main" && $CI_PIPELINE_SOURCE == "push"
      changes:
        - packages/portal/**/*
        - packages/contract/**/*
    - if: $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "main" && $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - packages/portal/**/*
        - packages/contract/**/*

# ============================================
# Version Update (–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤–µ—Ä—Å–∏–π –≤ package.json)
# ============================================

update:versions:
  stage: version
  image: alpine:latest
  before_script:
    - apk add --no-cache git jq curl
    - export COMMIT_SHA=$(echo $CI_COMMIT_SHA | cut -c1-8)
    # –ò–∑–≤–ª–µ–∫–∞–µ–º –≤–µ—Ä—Å–∏—é –∏–∑ –∏–º–µ–Ω–∏ –≤–µ—Ç–∫–∏ (r/X.Y.Z –∏–ª–∏ r-x.y.z)
    - |
      if echo "$CI_COMMIT_REF_NAME" | grep -qE '^r[/-][0-9]+\.[0-9]+\.[0-9]+$'; then
        VERSION=$(echo "$CI_COMMIT_REF_NAME" | sed -E 's/^r[\/-]([0-9]+\.[0-9]+\.[0-9]+)$/\1/')
        export VERSION
        echo "Version extracted from branch: $VERSION"
      else
        echo "ERROR: Branch name must match pattern r/X.Y.Z or r-x.y.z"
        exit 1
      fi
    # –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º git –¥–ª—è –∫–æ–º–º–∏—Ç–∞
    - git config --global user.name "GitLab CI"
    - git config --global user.email "ci@archpad.pro"
    # –ò—Å–ø–æ–ª—å–∑—É–µ–º Personal Access Token –∏–ª–∏ Project Access Token –¥–ª—è push
    # CI_JOB_TOKEN –Ω–µ –∏–º–µ–µ—Ç –ø—Ä–∞–≤ –Ω–∞ push, Deploy Token –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç write_repository
    - |
      echo "Checking GIT_PUSH_TOKEN..."
      if [ -z "$GIT_PUSH_TOKEN" ]; then
        echo "=========================================="
        echo "ERROR: GIT_PUSH_TOKEN is not set"
        echo "=========================================="
        echo "Please create a Personal Access Token or Project Access Token:"
        echo ""
        echo "Option 1: Personal Access Token (recommended, works immediately)"
        echo "  1. Go to: User Settings ‚Üí Access Tokens"
        echo "     (Click on your avatar ‚Üí Preferences ‚Üí Access Tokens)"
        echo "  2. Token name: git-push-token"
        echo "  3. Expiration date: set as needed"
        echo "  4. Scopes: select 'write_repository'"
        echo "  5. Click 'Create personal access token'"
        echo "  6. Copy the token (shown only once!)"
        echo "  7. Go to project: Settings ‚Üí CI/CD ‚Üí Variables"
        echo "  8. Add variable:"
        echo "     - Key: GIT_PUSH_TOKEN"
        echo "     - Value: <paste token>"
        echo "     - Type: Variable"
        echo "     - Flags: Masked (recommended)"
        echo ""
        echo "Option 2: Project Access Token (requires group settings)"
        echo "  NOTE: If disabled in group, enable it first:"
        echo "  - Group Settings ‚Üí General ‚Üí Permissions"
        echo "  - Enable 'Project access token creation'"
        echo ""
        echo "  Then create token:"
        echo "  1. Go to: Settings ‚Üí Access Tokens"
        echo "  2. Token name: git-push-token"
        echo "  3. Role: Maintainer or Owner"
        echo "  4. Scopes: select 'write_repository'"
        echo "  5. Create and copy token"
        echo "  6. Add as CI/CD variable: GIT_PUSH_TOKEN"
        echo "=========================================="
        exit 1
      fi
      echo "GIT_PUSH_TOKEN is set (length: ${#GIT_PUSH_TOKEN} characters)"
      git remote set-url origin "https://gitlab-ci-token:${GIT_PUSH_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
      echo "Git remote URL configured with GIT_PUSH_TOKEN"
    - git fetch origin "$CI_COMMIT_REF_NAME" || git fetch origin "$CI_DEFAULT_BRANCH"
    - |
      # –í GitLab CI –º—ã —É–∂–µ –≤ –Ω—É–∂–Ω–æ–º –∫–æ–º–º–∏—Ç–µ, –Ω–æ –Ω—É–∂–Ω–æ –ø–µ—Ä–µ–∫–ª—é—á–∏—Ç—å—Å—è –Ω–∞ –≤–µ—Ç–∫—É –¥–ª—è –∫–æ–º–º–∏—Ç–∞
      if git show-ref --verify --quiet "refs/remotes/origin/$CI_COMMIT_REF_NAME"; then
        # –í–µ—Ç–∫–∞ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –ø–µ—Ä–µ–∫–ª—é—á–∞–µ–º—Å—è –Ω–∞ –Ω–µ—ë
        git checkout -B "$CI_COMMIT_REF_NAME" "origin/$CI_COMMIT_REF_NAME"
      else
        # –í–µ—Ç–∫–∞ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, —Å–æ–∑–¥–∞—ë–º –µ—ë –∏–∑ —Ç–µ–∫—É—â–µ–≥–æ –∫–æ–º–º–∏—Ç–∞
        echo "Branch $CI_COMMIT_REF_NAME does not exist, creating from current commit"
        git checkout -b "$CI_COMMIT_REF_NAME"
      fi
  script:
    - |
      echo "üì¶ Updating package.json versions to $VERSION"
      echo ""
      
      # –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è version –≤ package.json
      update_version() {
        local file=$1
        if [ -f "$file" ]; then
          local current_version=$(jq -r '.version // empty' "$file")
          if [ -n "$current_version" ]; then
            echo "  Updating $file: $current_version ‚Üí $VERSION"
            jq --arg version "$VERSION" '.version = $version' "$file" > "${file}.tmp" && mv "${file}.tmp" "$file"
          else
            echo "  Adding version to $file: $VERSION"
            jq --arg version "$VERSION" '. + {version: $version}' "$file" > "${file}.tmp" && mv "${file}.tmp" "$file"
          fi
        else
          echo "  ‚ö†Ô∏è  File not found: $file"
        fi
      }
      
      # –û–±–Ω–æ–≤–ª—è–µ–º –≤–µ—Ä—Å–∏–∏ –≤ package.json —Ñ–∞–π–ª–∞—Ö
      update_version "packages/portal/package.json"
      update_version "packages/contract/package.json"
      update_version "packages/backend/package.json"
      
      echo ""
      echo "üìã Checking for changes..."
      echo "Current git status:"
      git status --short || true
      
      echo ""
      echo "Checking file contents after update:"
      echo "  packages/portal/package.json version: $(jq -r '.version // "not set"' packages/portal/package.json)"
      echo "  packages/contract/package.json version: $(jq -r '.version // "not set"' packages/contract/package.json)"
      echo "  packages/backend/package.json version: $(jq -r '.version // "not set"' packages/backend/package.json)"
      echo "  Expected version: $VERSION"
      
      # –î–æ–±–∞–≤–ª—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã
      echo ""
      echo "Staging package.json files..."
      git add packages/*/package.json || true
      
      echo ""
      echo "Checking staged changes:"
      git diff --cached --stat || echo "No staged changes"
      
      echo ""
      echo "Checking unstaged changes:"
      git diff --stat || echo "No unstaged changes"
      
      # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ —Ç–µ–≥–∞
      TAG_EXISTS_LOCAL=false
      TAG_EXISTS_REMOTE=false
      
      if git rev-parse "v$VERSION" >/dev/null 2>&1; then
        TAG_EXISTS_LOCAL=true
      fi
      
      if git ls-remote --exit-code --tags origin "refs/tags/v$VERSION" >/dev/null 2>&1; then
        TAG_EXISTS_REMOTE=true
      fi
      
      # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è –¥–ª—è –∫–æ–º–º–∏—Ç–∞
      if git diff --cached --quiet && git diff --quiet; then
        echo ""
        echo "‚ö†Ô∏è  No changes detected. Versions are already up to date."
        echo "This might mean versions were already updated in a previous run."
        
        # –ù–æ –ø—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–Ω–æ –ª–∏ —Å–æ–∑–¥–∞—Ç—å —Ç–µ–≥
        if [ "$TAG_EXISTS_LOCAL" = false ] && [ "$TAG_EXISTS_REMOTE" = false ]; then
          echo ""
          echo "üè∑Ô∏è  Creating git tag v$VERSION (versions are up to date, but tag is missing)..."
          git tag -a "v$VERSION" -m "Release version $VERSION"
          echo "üöÄ Pushing tag v$VERSION..."
          git push origin "v$VERSION"
          echo "  ‚úÖ Tag v$VERSION created and pushed"
        elif [ "$TAG_EXISTS_LOCAL" = false ] && [ "$TAG_EXISTS_REMOTE" = true ]; then
          echo ""
          echo "üè∑Ô∏è  Fetching tag v$VERSION from remote..."
          git fetch origin "refs/tags/v$VERSION:refs/tags/v$VERSION"
        fi
      else
        echo ""
        echo "üìù Committing version updates..."
        git commit -m "chore: bump version to $VERSION [ci skip]"
        
        echo ""
        echo "üè∑Ô∏è  Checking for git tag v$VERSION..."
        
        # –°–æ–∑–¥–∞–µ–º —Ç–µ–≥, –µ—Å–ª–∏ –µ–≥–æ –Ω–µ—Ç –Ω–∏ –ª–æ–∫–∞–ª—å–Ω–æ, –Ω–∏ –Ω–∞ remote
        if [ "$TAG_EXISTS_LOCAL" = false ] && [ "$TAG_EXISTS_REMOTE" = false ]; then
          echo "  Creating git tag v$VERSION..."
          git tag -a "v$VERSION" -m "Release version $VERSION"
          echo "  ‚úÖ Tag v$VERSION created"
        elif [ "$TAG_EXISTS_LOCAL" = false ] && [ "$TAG_EXISTS_REMOTE" = true ]; then
          # –¢–µ–≥ –µ—Å—Ç—å –Ω–∞ remote, –Ω–æ –Ω–µ –ª–æ–∫–∞–ª—å–Ω–æ - –ø–æ–ª—É—á–∞–µ–º –µ–≥–æ
          echo "  Tag v$VERSION exists on remote, fetching..."
          git fetch origin "refs/tags/v$VERSION:refs/tags/v$VERSION"
        else
          echo "  Tag v$VERSION already exists, skipping tag creation"
        fi
        
        echo ""
        echo "üöÄ Pushing changes to $CI_COMMIT_REF_NAME..."
        git push origin "$CI_COMMIT_REF_NAME"
        
        # Push —Ç–µ–≥–∞, –µ—Å–ª–∏ –æ–Ω –±—ã–ª —Å–æ–∑–¥–∞–Ω –∏–ª–∏ –æ–±–Ω–æ–≤–ª–µ–Ω –ª–æ–∫–∞–ª—å–Ω–æ
        if [ "$TAG_EXISTS_REMOTE" = false ]; then
          echo "üöÄ Pushing tag v$VERSION..."
          git push origin "v$VERSION"
          echo "  ‚úÖ Tag v$VERSION pushed to remote"
        fi
        
        echo ""
        echo "‚úÖ Version $VERSION successfully updated in package.json files, committed, and tagged"
      fi
  rules:
    # –ó–∞–ø—É—Å–∫–∞–µ–º —Ç–æ–ª—å–∫–æ –¥–ª—è –≤–µ—Ç–æ–∫ –≤–∏–¥–∞ r/X.Y.Z –∏–ª–∏ r-x.y.z
    - if: $CI_COMMIT_REF_NAME =~ /^r[\/-][0-9]+\.[0-9]+\.[0-9]+$/
  needs:
    - job: build:arch-repo-service
      artifacts: false
    - job: build:tenant-service
      artifacts: false
    - job: build:hasura-sync-service
      artifacts: false
    - job: build:portal
      artifacts: false

# ============================================
# Deploy (–∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω—ã–π stage)
# ============================================

# –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –æ–±—Ä–∞–∑–æ–≤ –≤ Kubernetes –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è —á–µ—Ä–µ–∑ ArgoCD Image Updater.
# ArgoCD Image Updater –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ—Ç –Ω–æ–≤—ã–µ –æ–±—Ä–∞–∑—ã –≤ Container Registry –∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–±–Ω–æ–≤–ª—è–µ—Ç
# –º–∞–Ω–∏—Ñ–µ—Å—Ç—ã –≤ Git —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–∏. ArgoCD –∑–∞—Ç–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ—Ç –∏–∑–º–µ–Ω–µ–Ω–∏—è.
# 
# –°–º. –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é: docs/ARGOCD_IMAGE_UPDATER.md

deploy:update-images:
  stage: deploy
  image: alpine:latest
  before_script:
    - export COMMIT_SHA=$(echo $CI_COMMIT_SHA | cut -c1-8)
    # –ò–∑–≤–ª–µ–∫–∞–µ–º –≤–µ—Ä—Å–∏—é –∏–∑ –∏–º–µ–Ω–∏ –≤–µ—Ç–∫–∏ (r/X.Y.Z –∏–ª–∏ r-x.y.z)
    - |
      if echo "$CI_COMMIT_REF_NAME" | grep -qE '^r[/-][0-9]+\.[0-9]+\.[0-9]+$'; then
        VERSION=$(echo "$CI_COMMIT_REF_NAME" | sed -E 's/^r[\/-]([0-9]+\.[0-9]+\.[0-9]+)$/\1/')
        export VERSION
      else
        echo "ERROR: Branch name must match pattern r/X.Y.Z or r-x.y.z"
        exit 1
      fi
    - export REGISTRY_URL="${REGISTRY_URL:-archpad-cr.registry.twcstorage.ru}"
    - export REGISTRY_IMAGE_PREFIX="${REGISTRY_IMAGE_PREFIX:-archpad}"
  script:
    - 'echo "‚úÖ Images built and pushed successfully"'
    - 'echo ""'
    - 'echo "Built images (version $VERSION, commit $COMMIT_SHA):"'
    - 'echo "  - arch-repo-service:${VERSION}-${COMMIT_SHA} (latest)"'
    - 'echo "  - tenant-service:${VERSION}-${COMMIT_SHA} (latest)"'
    - 'echo "  - hasura-sync-service:${VERSION}-${COMMIT_SHA} (latest)"'
    - 'echo "  - portal:${VERSION}-${COMMIT_SHA} (latest)"'
    - echo ""
    - 'echo "üì¶ ArgoCD Image Updater will automatically detect new images and update Kubernetes manifests"'
    - 'echo "   See: docs/ARGOCD_IMAGE_UPDATER.md for details"'
  rules:
    # –ó–∞–ø—É—Å–∫–∞–µ–º —Ç–æ–ª—å–∫–æ –¥–ª—è –≤–µ—Ç–æ–∫ –≤–∏–¥–∞ r/X.Y.Z –∏–ª–∏ r-x.y.z
    - if: $CI_COMMIT_REF_NAME =~ /^r[\/-][0-9]+\.[0-9]+\.[0-9]+$/
  needs:
    - job: update:versions
      artifacts: false
