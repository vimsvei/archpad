stages:
  - build
  - cleanup
  - update-deploy-tags
  - version
  - deploy

variables:
  # Container Registry TimeWeb
  # REGISTRY_URL и REGISTRY_IMAGE_PREFIX должны быть установлены в GitLab CI/CD Variables
  # Если не установлены, используются значения по умолчанию:
  REGISTRY_URL: "${REGISTRY_URL:-archpad-cr.registry.twcstorage.ru}"
  REGISTRY_IMAGE_PREFIX: "${REGISTRY_IMAGE_PREFIX:-archpad}"
  
  # Docker build settings
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  # Network hiccups during registry auth are common; allow longer timeouts.
  DOCKER_CLIENT_TIMEOUT: "300"
  DOCKER_HTTP_TIMEOUT: "300"

# Шаблон для сборки Docker образа
.build_docker_image:
  stage: build
  image: docker:24-dind
  services:
    - docker:24-dind
  before_script:
    - export COMMIT_SHA=$(echo $CI_COMMIT_SHA | cut -c1-8)
    # Извлекаем версию из имени ветки (r/X.Y.Z или r-x.y.z)
    - |
      if echo "$CI_COMMIT_REF_NAME" | grep -qE '^r[/-][0-9]+\.[0-9]+\.[0-9]+$'; then
        # Извлекаем версию из ветки (r/X.Y.Z -> X.Y.Z или r-x.y.z -> x.y.z)
        VERSION=$(echo "$CI_COMMIT_REF_NAME" | sed -E 's/^r[\/-]([0-9]+\.[0-9]+\.[0-9]+)$/\1/')
        export VERSION
        echo "Version extracted from branch: $VERSION"
      else
        echo "ERROR: Branch name must match pattern r/X.Y.Z or r-x.y.z"
        echo "Current branch: $CI_COMMIT_REF_NAME"
        exit 1
      fi
    # Переменные REGISTRY_URL и REGISTRY_IMAGE_PREFIX должны быть установлены в GitLab CI/CD Variables
    # Они автоматически доступны, но убедимся, что они установлены
    - export REGISTRY_URL="${REGISTRY_URL:-archpad-cr.registry.twcstorage.ru}"
    - export REGISTRY_IMAGE_PREFIX="${REGISTRY_IMAGE_PREFIX:-archpad}"
    - 'echo "Building for version $VERSION (commit $COMMIT_SHA)"'
    - 'echo "Branch: $CI_COMMIT_REF_NAME"'
    - 'echo "Registry URL: $REGISTRY_URL"'
    - 'echo "Registry Image Prefix: $REGISTRY_IMAGE_PREFIX"'
    # Проверяем VAULT_TOKEN для portal и landing (нужен для получения секретов во время сборки)
    - |
      export SERVICE_NAME_CHECK="${CI_JOB_NAME#build:}"
      if { [ "$SERVICE_NAME_CHECK" = "portal" ] || [ "$SERVICE_NAME_CHECK" = "landing" ]; } && [ -z "$VAULT_TOKEN" ]; then
        echo "=========================================="
        echo "WARNING: VAULT_TOKEN is not set"
        echo "=========================================="
        echo "For portal/landing builds, VAULT_TOKEN is required to fetch NEXT_PUBLIC_* secrets from Vault."
        echo "Please set VAULT_TOKEN in GitLab CI/CD Variables:"
        echo "  Settings → CI/CD → Variables → Add variable"
        echo "  Key: VAULT_TOKEN"
        echo "  Value: your-vault-token"
        echo "  Type: Variable"
        echo "  Flags: Masked (recommended)"
        echo "=========================================="
        echo "Build will continue, but NEXT_PUBLIC_* variables may be missing."
      fi
    - |
      if [ -z "$REGISTRY_USERNAME" ] || [ -z "$REGISTRY_PASSWORD" ]; then
        echo "=========================================="
        echo "ERROR: Missing required CI/CD Variables"
        echo "=========================================="
        echo "Please set the following variables in GitLab:"
        echo "  Settings → CI/CD → Variables → Expand"
        echo ""
        echo "Required variables:"
        [ -z "$REGISTRY_USERNAME" ] && echo "  ❌ REGISTRY_USERNAME (not set)" || echo "  ✅ REGISTRY_USERNAME (set)"
        [ -z "$REGISTRY_PASSWORD" ] && echo "  ❌ REGISTRY_PASSWORD (not set)" || echo "  ✅ REGISTRY_PASSWORD (set)"
        echo ""
        echo "How to set:"
        echo "  1. Go to: Settings → CI/CD → Variables"
        echo "  2. Click 'Add variable'"
        echo "  3. Set Key: REGISTRY_USERNAME, Value: your-registry-username"
        echo "  4. Set Key: REGISTRY_PASSWORD, Value: your-registry-password (masked)"
        echo "  5. Save and retry the pipeline"
        echo "=========================================="
        exit 1
      fi
    - 'echo "Logging in to registry: $REGISTRY_URL"'
    - |
      docker_login_with_retry() {
        local tries=6
        local delay=5
        local i=1
        while [ "$i" -le "$tries" ]; do
          echo "$REGISTRY_PASSWORD" | docker login -u "$REGISTRY_USERNAME" --password-stdin "$REGISTRY_URL" && return 0
          echo "WARNING: docker login failed (attempt ${i}/${tries}); retrying in ${delay}s..." >&2
          sleep "$delay"
          delay=$((delay * 2))
          i=$((i + 1))
        done
        echo "ERROR: docker login failed after ${tries} attempts" >&2
        return 1
      }
      docker_login_with_retry
    # Определяем функцию для получения секретов из Vault для portal
    # Функция должна быть определена в before_script, чтобы быть доступной в script
    - |
      get_vault_secrets_for_portal() {
        local VAULT_ADDR="${VAULT_ADDR:-https://vault.archpad.pro}"
        local VAULT_SECRET_PATH="kv/data/archpad/demo/frontend/portal"
        
        if [ -z "$VAULT_TOKEN" ]; then
          echo "ERROR: VAULT_TOKEN is not set"
          echo "Please set VAULT_TOKEN in GitLab CI/CD Variables"
          return 1
        fi
        
        # Устанавливаем curl и jq если их нет (для alpine образа)
        if ! command -v curl >/dev/null 2>&1; then
          apk add --no-cache curl >/dev/null 2>&1 || true
        fi
        if ! command -v jq >/dev/null 2>&1; then
          apk add --no-cache jq >/dev/null 2>&1 || true
        fi
        
        echo "Fetching secrets from Vault: ${VAULT_ADDR}/${VAULT_SECRET_PATH}"
        
        # Получаем секреты из Vault
        local response=$(curl -s -H "X-Vault-Token: ${VAULT_TOKEN}" \
          "${VAULT_ADDR}/v1/${VAULT_SECRET_PATH}" 2>&1)
        
        if [ $? -ne 0 ] || echo "$response" | jq -e '.errors' >/dev/null 2>&1; then
          echo "ERROR: Failed to fetch secrets from Vault"
          local error_msg=$(echo "$response" | jq -r '.errors[]?' 2>/dev/null || echo "$response")
          echo "$error_msg"
          
          # Проверяем, запечатан ли Vault
          if echo "$error_msg" | grep -qi "sealed"; then
            echo ""
            echo "=========================================="
            echo "Vault is SEALED"
            echo "=========================================="
            echo "Vault must be unsealed before building Portal."
            echo ""
            echo "To unseal Vault:"
            echo "  1. Connect to your Vault server"
            echo "  2. Run: vault operator unseal <unseal-key>"
            echo "     (You may need multiple unseal keys)"
            echo ""
            echo "Or if using auto-unseal, check Vault logs for issues."
            echo "=========================================="
          fi
          return 1
        fi
        
        # NEXT_PUBLIC_TOLGEE_API_KEY из portal, URL из tolgee/front
        echo "Fetching Tolgee URLs from Vault: ${VAULT_ADDR}/kv/data/archpad/demo/tolgee/front"
        local tolgee_front_response=$(curl -s -H "X-Vault-Token: ${VAULT_TOKEN}" \
          "${VAULT_ADDR}/v1/kv/data/archpad/demo/tolgee/front" 2>&1)
        
        if [ $? -ne 0 ] || echo "$tolgee_front_response" | jq -e '.errors' >/dev/null 2>&1; then
          echo "ERROR: Failed to fetch Tolgee URLs from Vault"
          return 1
        fi
        
        export NEXT_PUBLIC_TOLGEE_API_KEY=$(echo "$response" | jq -r '.data.data.NEXT_PUBLIC_TOLGEE_API_KEY // empty')
        export NEXT_PUBLIC_TOLGEE_API_URL=$(echo "$tolgee_front_response" | jq -r '.data.data.NEXT_PUBLIC_TOLGEE_API_URL // empty')
        export NEXT_PUBLIC_URL=$(echo "$response" | jq -r '.data.data.NEXT_PUBLIC_URL // empty')
        export NEXT_PUBLIC_HASURA_GRAPHQL_URL=$(echo "$response" | jq -r '.data.data.NEXT_PUBLIC_HASURA_GRAPHQL_URL // empty')
        export NEXT_PUBLIC_API_GRAPHQL_URI=$(echo "$response" | jq -r '.data.data.NEXT_PUBLIC_API_GRAPHQL_URI // empty')
        export NEXT_PUBLIC_API_REST_URI=$(echo "$response" | jq -r '.data.data.NEXT_PUBLIC_API_REST_URI // empty')
        
        echo "✅ Successfully fetched secrets from Vault"
        echo "  NEXT_PUBLIC_TOLGEE_API_KEY: ${NEXT_PUBLIC_TOLGEE_API_KEY:+***SET***}"
        echo "  NEXT_PUBLIC_TOLGEE_API_URL: ${NEXT_PUBLIC_TOLGEE_API_URL:+***SET***}"
        echo "  NEXT_PUBLIC_URL: ${NEXT_PUBLIC_URL:+***SET***}"
        echo "  NEXT_PUBLIC_HASURA_GRAPHQL_URL: ${NEXT_PUBLIC_HASURA_GRAPHQL_URL:+***SET***}"
        echo "  NEXT_PUBLIC_API_GRAPHQL_URI: ${NEXT_PUBLIC_API_GRAPHQL_URI:+***SET***}"
        echo "  NEXT_PUBLIC_API_REST_URI: ${NEXT_PUBLIC_API_REST_URI:+***SET***}"
      }
    - |
      get_vault_secrets_for_landing() {
        local VAULT_ADDR="${VAULT_ADDR:-https://vault.archpad.pro}"
        local VAULT_LANDING_PATH="kv/data/archpad/demo/frontend/landing"
        local VAULT_TOLGEE_FRONT_PATH="kv/data/archpad/demo/tolgee/front"
        if [ -z "$VAULT_TOKEN" ]; then echo "ERROR: VAULT_TOKEN is not set"; return 1; fi
        if ! command -v curl >/dev/null 2>&1; then apk add --no-cache curl >/dev/null 2>&1 || true; fi
        if ! command -v jq >/dev/null 2>&1; then apk add --no-cache jq >/dev/null 2>&1 || true; fi
        local landing_response=$(curl -s -H "X-Vault-Token: ${VAULT_TOKEN}" "${VAULT_ADDR}/v1/${VAULT_LANDING_PATH}" 2>&1)
        if [ $? -ne 0 ] || echo "$landing_response" | jq -e '.errors' >/dev/null 2>&1; then echo "ERROR: Failed to fetch landing secrets from Vault"; return 1; fi
        local tolgee_front_response=$(curl -s -H "X-Vault-Token: ${VAULT_TOKEN}" "${VAULT_ADDR}/v1/${VAULT_TOLGEE_FRONT_PATH}" 2>&1)
        if [ $? -ne 0 ] || echo "$tolgee_front_response" | jq -e '.errors' >/dev/null 2>&1; then echo "ERROR: Failed to fetch Tolgee URLs from Vault"; return 1; fi
        export NEXT_PUBLIC_TOLGEE_API_KEY=$(echo "$landing_response" | jq -r '.data.data.NEXT_PUBLIC_TOLGEE_API_KEY // empty')
        export NEXT_PUBLIC_TOLGEE_API_URL=$(echo "$tolgee_front_response" | jq -r '.data.data.NEXT_PUBLIC_TOLGEE_API_URL // empty')
        export NEXT_PUBLIC_SITE_URL=$(echo "$landing_response" | jq -r '.data.data.NEXT_PUBLIC_SITE_URL // "https://archpad.pro"')
        echo "✅ Successfully fetched secrets for landing"
      }
  script:
    - export SERVICE_NAME="${CI_JOB_NAME#build:}"
    # Убеждаемся, что переменные установлены (из GitLab Variables или fallback)
    - export REGISTRY_URL="${REGISTRY_URL:-archpad-cr.registry.twcstorage.ru}"
    - export REGISTRY_IMAGE_PREFIX="${REGISTRY_IMAGE_PREFIX:-archpad}"
    # Формируем теги образов: x.y.z-<commit-sha> и latest
    - export IMAGE_TAG_VERSION="${REGISTRY_URL}/${REGISTRY_IMAGE_PREFIX}/${SERVICE_NAME}:${VERSION}-${COMMIT_SHA}"
    - export IMAGE_TAG_LATEST="${REGISTRY_URL}/${REGISTRY_IMAGE_PREFIX}/${SERVICE_NAME}:latest"
    - 'echo "Building $SERVICE_NAME version $VERSION (commit $COMMIT_SHA)"'
    - |
      echo "Image tags:"
      echo "  - ${IMAGE_TAG_VERSION}"
      echo "  - ${IMAGE_TAG_LATEST}"
    - 'echo "Dockerfile: $DOCKERFILE_PATH"'
    - 'echo "Build context: $BUILD_CONTEXT"'
    # Для portal получаем секреты из Vault и передаем NEXT_PUBLIC_* переменные как build-args
    # Эти переменные должны быть доступны во время сборки Next.js
    - |
      if [ "$SERVICE_NAME" = "portal" ]; then
        echo "Building portal - fetching secrets from Vault..."
        get_vault_secrets_for_portal
        
        # Проверяем, что переменные не пустые
        if [ -z "$NEXT_PUBLIC_TOLGEE_API_KEY" ] || [ -z "$NEXT_PUBLIC_TOLGEE_API_URL" ]; then
          echo "ERROR: Required NEXT_PUBLIC_* variables are empty after fetching from Vault"
          echo "  NEXT_PUBLIC_TOLGEE_API_KEY: ${NEXT_PUBLIC_TOLGEE_API_KEY:+SET}${NEXT_PUBLIC_TOLGEE_API_KEY:-NOT SET}"
          echo "  NEXT_PUBLIC_TOLGEE_API_URL: ${NEXT_PUBLIC_TOLGEE_API_URL:+SET}${NEXT_PUBLIC_TOLGEE_API_URL:-NOT SET}"
          exit 1
        fi
        
        echo "Building portal with NEXT_PUBLIC_* build arguments from Vault..."
        echo "  NEXT_PUBLIC_TOLGEE_API_KEY: ${NEXT_PUBLIC_TOLGEE_API_KEY:+***SET***}"
        echo "  NEXT_PUBLIC_TOLGEE_API_URL: ${NEXT_PUBLIC_TOLGEE_API_URL:+***SET***}"
        echo "  NEXT_PUBLIC_URL: ${NEXT_PUBLIC_URL:+***SET***}"
        echo "  NEXT_PUBLIC_HASURA_GRAPHQL_URL: ${NEXT_PUBLIC_HASURA_GRAPHQL_URL:+***SET***}"
        echo "  NEXT_PUBLIC_API_GRAPHQL_URI: ${NEXT_PUBLIC_API_GRAPHQL_URI:+***SET***}"
        echo "  NEXT_PUBLIC_API_REST_URI: ${NEXT_PUBLIC_API_REST_URI:+***SET***}"
        # (portal auth is proxied via auth-service; no Keycloak vars required)
        
        docker build \
          -t "$IMAGE_TAG_VERSION" \
          -t "$IMAGE_TAG_LATEST" \
          -f "$DOCKERFILE_PATH" \
          --build-arg BUILD_COMMIT_SHA="${CI_COMMIT_SHA}" \
          --build-arg BUILD_VERSION="${VERSION}" \
          --build-arg BUILD_BRANCH="${CI_COMMIT_REF_NAME}" \
          --build-arg NEXT_PUBLIC_TOLGEE_API_KEY="${NEXT_PUBLIC_TOLGEE_API_KEY}" \
          --build-arg NEXT_PUBLIC_TOLGEE_API_URL="${NEXT_PUBLIC_TOLGEE_API_URL}" \
          --build-arg NEXT_PUBLIC_URL="${NEXT_PUBLIC_URL}" \
          --build-arg NEXT_PUBLIC_HASURA_GRAPHQL_URL="${NEXT_PUBLIC_HASURA_GRAPHQL_URL}" \
          --build-arg NEXT_PUBLIC_API_GRAPHQL_URI="${NEXT_PUBLIC_API_GRAPHQL_URI}" \
          --build-arg NEXT_PUBLIC_API_REST_URI="${NEXT_PUBLIC_API_REST_URI}" \
          "$BUILD_CONTEXT"
      elif [ "$SERVICE_NAME" = "landing" ]; then
        echo "Building landing - fetching secrets from Vault..."
        get_vault_secrets_for_landing
        if [ -z "$NEXT_PUBLIC_TOLGEE_API_KEY" ] || [ -z "$NEXT_PUBLIC_TOLGEE_API_URL" ]; then
          echo "ERROR: Required NEXT_PUBLIC_* variables are empty after fetching from Vault"
          exit 1
        fi
        docker build \
          -t "$IMAGE_TAG_VERSION" \
          -t "$IMAGE_TAG_LATEST" \
          -f "$DOCKERFILE_PATH" \
          --build-arg BUILD_COMMIT_SHA="${CI_COMMIT_SHA}" \
          --build-arg BUILD_VERSION="${VERSION}" \
          --build-arg BUILD_BRANCH="${CI_COMMIT_REF_NAME}" \
          --build-arg NEXT_PUBLIC_TOLGEE_API_KEY="${NEXT_PUBLIC_TOLGEE_API_KEY}" \
          --build-arg NEXT_PUBLIC_TOLGEE_API_URL="${NEXT_PUBLIC_TOLGEE_API_URL}" \
          --build-arg NEXT_PUBLIC_SITE_URL="${NEXT_PUBLIC_SITE_URL}" \
          "$BUILD_CONTEXT"
      else
        docker build \
          -t "$IMAGE_TAG_VERSION" \
          -t "$IMAGE_TAG_LATEST" \
          -f "$DOCKERFILE_PATH" \
          --build-arg BUILD_COMMIT_SHA="${CI_COMMIT_SHA}" \
          --build-arg BUILD_VERSION="${VERSION}" \
          --build-arg BUILD_BRANCH="${CI_COMMIT_REF_NAME}" \
          "$BUILD_CONTEXT"
      fi
    - docker push "$IMAGE_TAG_VERSION"
    - docker push "$IMAGE_TAG_LATEST"
    - |
      echo "✅ Images pushed:"
      echo "  - $IMAGE_TAG_VERSION"
      echo "  - $IMAGE_TAG_LATEST"
  after_script:
    - docker logout "$REGISTRY_URL" || true
  rules:
    # Собираем только для веток вида r/X.Y.Z или r-x.y.z
    - if: $CI_COMMIT_REF_NAME =~ /^r[\/-][0-9]+\.[0-9]+\.[0-9]+$/

# Шаблон для сборки Docker образа из main ветки
.build_docker_image_main:
  stage: build
  image: docker:24-dind
  services:
    - docker:24-dind
  before_script:
    - export COMMIT_SHA=$(echo $CI_COMMIT_SHA | cut -c1-8)
    - export REGISTRY_URL="${REGISTRY_URL:-archpad-cr.registry.twcstorage.ru}"
    - export REGISTRY_IMAGE_PREFIX="${REGISTRY_IMAGE_PREFIX:-archpad}"
    - 'echo "Building for main branch (commit $COMMIT_SHA)"'
    - 'echo "Branch: $CI_COMMIT_REF_NAME"'
    - 'echo "Registry URL: $REGISTRY_URL"'
    - 'echo "Registry Image Prefix: $REGISTRY_IMAGE_PREFIX"'
    # Проверяем VAULT_TOKEN для portal и landing (нужен для получения секретов во время сборки)
    - |
      export SERVICE_NAME_CHECK="${CI_JOB_NAME#build:main:}"
      if { [ "$SERVICE_NAME_CHECK" = "portal" ] || [ "$SERVICE_NAME_CHECK" = "landing" ]; } && [ -z "$VAULT_TOKEN" ]; then
        echo "=========================================="
        echo "WARNING: VAULT_TOKEN is not set"
        echo "=========================================="
        echo "For portal/landing builds, VAULT_TOKEN is required to fetch NEXT_PUBLIC_* secrets from Vault."
        echo "Please set VAULT_TOKEN in GitLab CI/CD Variables:"
        echo "  Settings → CI/CD → Variables → Add variable"
        echo "  Key: VAULT_TOKEN"
        echo "  Value: your-vault-token"
        echo "  Type: Variable"
        echo "  Flags: Masked (recommended)"
        echo "=========================================="
        echo "Build will continue, but NEXT_PUBLIC_* variables may be missing."
      fi
    - |
      if [ -z "$REGISTRY_USERNAME" ] || [ -z "$REGISTRY_PASSWORD" ]; then
        echo "=========================================="
        echo "ERROR: Missing required CI/CD Variables"
        echo "=========================================="
        echo "Please set the following variables in GitLab:"
        echo "  Settings → CI/CD → Variables → Expand"
        echo ""
        echo "Required variables:"
        [ -z "$REGISTRY_USERNAME" ] && echo "  ❌ REGISTRY_USERNAME (not set)" || echo "  ✅ REGISTRY_USERNAME (set)"
        [ -z "$REGISTRY_PASSWORD" ] && echo "  ❌ REGISTRY_PASSWORD (not set)" || echo "  ✅ REGISTRY_PASSWORD (set)"
        echo ""
        echo "How to set:"
        echo "  1. Go to: Settings → CI/CD → Variables"
        echo "  2. Click 'Add variable'"
        echo "  3. Set Key: REGISTRY_USERNAME, Value: your-registry-username"
        echo "  4. Set Key: REGISTRY_PASSWORD, Value: your-registry-password (masked)"
        echo "  5. Save and retry the pipeline"
        echo "=========================================="
        exit 1
      fi
    - 'echo "Logging in to registry: $REGISTRY_URL"'
    - |
      docker_login_with_retry() {
        local tries=6
        local delay=5
        local i=1
        while [ "$i" -le "$tries" ]; do
          echo "$REGISTRY_PASSWORD" | docker login -u "$REGISTRY_USERNAME" --password-stdin "$REGISTRY_URL" && return 0
          echo "WARNING: docker login failed (attempt ${i}/${tries}); retrying in ${delay}s..." >&2
          sleep "$delay"
          delay=$((delay * 2))
          i=$((i + 1))
        done
        echo "ERROR: docker login failed after ${tries} attempts" >&2
        return 1
      }
      docker_login_with_retry
    # Определяем функцию для получения секретов из Vault для portal
    # Функция должна быть определена в before_script, чтобы быть доступной в script
    - |
      get_vault_secrets_for_portal() {
        local VAULT_ADDR="${VAULT_ADDR:-https://vault.archpad.pro}"
        local VAULT_SECRET_PATH="kv/data/archpad/demo/frontend/portal"
        # Portal no longer reads Keycloak напрямую; весь auth через auth-service.
        
        if [ -z "$VAULT_TOKEN" ]; then
          echo "ERROR: VAULT_TOKEN is not set"
          echo "Please set VAULT_TOKEN in GitLab CI/CD Variables"
          return 1
        fi
        
        # Устанавливаем curl и jq если их нет (для alpine образа)
        if ! command -v curl >/dev/null 2>&1; then
          apk add --no-cache curl >/dev/null 2>&1 || true
        fi
        if ! command -v jq >/dev/null 2>&1; then
          apk add --no-cache jq >/dev/null 2>&1 || true
        fi
        
        echo "Fetching secrets from Vault: ${VAULT_ADDR}/${VAULT_SECRET_PATH}"
        
        # Получаем секреты из Vault
        local response=$(curl -s -H "X-Vault-Token: ${VAULT_TOKEN}" \
          "${VAULT_ADDR}/v1/${VAULT_SECRET_PATH}" 2>&1)
        
        if [ $? -ne 0 ] || echo "$response" | jq -e '.errors' >/dev/null 2>&1; then
          echo "ERROR: Failed to fetch secrets from Vault"
          local error_msg=$(echo "$response" | jq -r '.errors[]?' 2>/dev/null || echo "$response")
          echo "$error_msg"
          
          # Проверяем, запечатан ли Vault
          if echo "$error_msg" | grep -qi "sealed"; then
            echo ""
            echo "=========================================="
            echo "Vault is SEALED"
            echo "=========================================="
            echo "Vault must be unsealed before building Portal."
            echo ""
            echo "To unseal Vault:"
            echo "  1. Connect to your Vault server"
            echo "  2. Run: vault operator unseal <unseal-key>"
            echo "     (You may need multiple unseal keys)"
            echo ""
            echo "Or if using auto-unseal, check Vault logs for issues."
            echo "=========================================="
          fi
          return 1
        fi
        
        # NEXT_PUBLIC_TOLGEE_API_KEY из portal, URL из tolgee/front
        echo "Fetching Tolgee URLs from Vault: ${VAULT_ADDR}/kv/data/archpad/demo/tolgee/front"
        local tolgee_front_response=$(curl -s -H "X-Vault-Token: ${VAULT_TOKEN}" \
          "${VAULT_ADDR}/v1/kv/data/archpad/demo/tolgee/front" 2>&1)
        
        if [ $? -ne 0 ] || echo "$tolgee_front_response" | jq -e '.errors' >/dev/null 2>&1; then
          echo "ERROR: Failed to fetch Tolgee URLs from Vault"
          return 1
        fi
        
        export NEXT_PUBLIC_TOLGEE_API_KEY=$(echo "$response" | jq -r '.data.data.NEXT_PUBLIC_TOLGEE_API_KEY // empty')
        export NEXT_PUBLIC_TOLGEE_API_URL=$(echo "$tolgee_front_response" | jq -r '.data.data.NEXT_PUBLIC_TOLGEE_API_URL // empty')
        export NEXT_PUBLIC_URL=$(echo "$response" | jq -r '.data.data.NEXT_PUBLIC_URL // empty')
        export NEXT_PUBLIC_HASURA_GRAPHQL_URL=$(echo "$response" | jq -r '.data.data.NEXT_PUBLIC_HASURA_GRAPHQL_URL // empty')
        export NEXT_PUBLIC_API_GRAPHQL_URI=$(echo "$response" | jq -r '.data.data.NEXT_PUBLIC_API_GRAPHQL_URI // empty')
        export NEXT_PUBLIC_API_REST_URI=$(echo "$response" | jq -r '.data.data.NEXT_PUBLIC_API_REST_URI // empty')

        # (no Keycloak build args)
        
        echo "✅ Successfully fetched secrets from Vault"
        echo "  NEXT_PUBLIC_TOLGEE_API_KEY: ${NEXT_PUBLIC_TOLGEE_API_KEY:+***SET***}"
        echo "  NEXT_PUBLIC_TOLGEE_API_URL: ${NEXT_PUBLIC_TOLGEE_API_URL:+***SET***}"
        echo "  NEXT_PUBLIC_URL: ${NEXT_PUBLIC_URL:+***SET***}"
        echo "  NEXT_PUBLIC_HASURA_GRAPHQL_URL: ${NEXT_PUBLIC_HASURA_GRAPHQL_URL:+***SET***}"
        echo "  NEXT_PUBLIC_API_GRAPHQL_URI: ${NEXT_PUBLIC_API_GRAPHQL_URI:+***SET***}"
        echo "  NEXT_PUBLIC_API_REST_URI: ${NEXT_PUBLIC_API_REST_URI:+***SET***}"
        # (portal auth is proxied via auth-service; no Keycloak vars required)
      }
    - |
      get_vault_secrets_for_landing() {
        local VAULT_ADDR="${VAULT_ADDR:-https://vault.archpad.pro}"
        local VAULT_LANDING_PATH="kv/data/archpad/demo/frontend/landing"
        local VAULT_TOLGEE_FRONT_PATH="kv/data/archpad/demo/tolgee/front"
        if [ -z "$VAULT_TOKEN" ]; then echo "ERROR: VAULT_TOKEN is not set"; return 1; fi
        if ! command -v curl >/dev/null 2>&1; then apk add --no-cache curl >/dev/null 2>&1 || true; fi
        if ! command -v jq >/dev/null 2>&1; then apk add --no-cache jq >/dev/null 2>&1 || true; fi
        local landing_response=$(curl -s -H "X-Vault-Token: ${VAULT_TOKEN}" "${VAULT_ADDR}/v1/${VAULT_LANDING_PATH}" 2>&1)
        if [ $? -ne 0 ] || echo "$landing_response" | jq -e '.errors' >/dev/null 2>&1; then echo "ERROR: Failed to fetch landing secrets from Vault"; return 1; fi
        local tolgee_front_response=$(curl -s -H "X-Vault-Token: ${VAULT_TOKEN}" "${VAULT_ADDR}/v1/${VAULT_TOLGEE_FRONT_PATH}" 2>&1)
        if [ $? -ne 0 ] || echo "$tolgee_front_response" | jq -e '.errors' >/dev/null 2>&1; then echo "ERROR: Failed to fetch Tolgee URLs from Vault"; return 1; fi
        export NEXT_PUBLIC_TOLGEE_API_KEY=$(echo "$landing_response" | jq -r '.data.data.NEXT_PUBLIC_TOLGEE_API_KEY // empty')
        export NEXT_PUBLIC_TOLGEE_API_URL=$(echo "$tolgee_front_response" | jq -r '.data.data.NEXT_PUBLIC_TOLGEE_API_URL // empty')
        export NEXT_PUBLIC_SITE_URL=$(echo "$landing_response" | jq -r '.data.data.NEXT_PUBLIC_SITE_URL // "https://archpad.pro"')
        echo "✅ Successfully fetched secrets for landing"
      }
  script:
    - export SERVICE_NAME="${CI_JOB_NAME#build:main:}"
    - export REGISTRY_URL="${REGISTRY_URL:-archpad-cr.registry.twcstorage.ru}"
    - export REGISTRY_IMAGE_PREFIX="${REGISTRY_IMAGE_PREFIX:-archpad}"
    # Формируем теги образов: main-<commit-sha> и latest
    - export IMAGE_TAG_MAIN="${REGISTRY_URL}/${REGISTRY_IMAGE_PREFIX}/${SERVICE_NAME}:main-${COMMIT_SHA}"
    - export IMAGE_TAG_LATEST="${REGISTRY_URL}/${REGISTRY_IMAGE_PREFIX}/${SERVICE_NAME}:latest"
    - 'echo "Building $SERVICE_NAME for main branch (commit $COMMIT_SHA)"'
    - |
      echo "Image tags:"
      echo "  - ${IMAGE_TAG_MAIN}"
      echo "  - ${IMAGE_TAG_LATEST}"
    - 'echo "Dockerfile: $DOCKERFILE_PATH"'
    - 'echo "Build context: $BUILD_CONTEXT"'
    # Для portal получаем секреты из Vault и передаем NEXT_PUBLIC_* переменные как build-args
    # Эти переменные должны быть доступны во время сборки Next.js
    - |
      if [ "$SERVICE_NAME" = "portal" ]; then
        echo "Building portal - fetching secrets from Vault..."
        get_vault_secrets_for_portal
        
        # Проверяем, что переменные не пустые
        if [ -z "$NEXT_PUBLIC_TOLGEE_API_KEY" ] || [ -z "$NEXT_PUBLIC_TOLGEE_API_URL" ]; then
          echo "ERROR: Required NEXT_PUBLIC_* variables are empty after fetching from Vault"
          echo "  NEXT_PUBLIC_TOLGEE_API_KEY: ${NEXT_PUBLIC_TOLGEE_API_KEY:+SET}${NEXT_PUBLIC_TOLGEE_API_KEY:-NOT SET}"
          echo "  NEXT_PUBLIC_TOLGEE_API_URL: ${NEXT_PUBLIC_TOLGEE_API_URL:+SET}${NEXT_PUBLIC_TOLGEE_API_URL:-NOT SET}"
          exit 1
        fi
        
        echo "Building portal with NEXT_PUBLIC_* build arguments from Vault..."
        echo "  NEXT_PUBLIC_TOLGEE_API_KEY: ${NEXT_PUBLIC_TOLGEE_API_KEY:+***SET***}"
        echo "  NEXT_PUBLIC_TOLGEE_API_URL: ${NEXT_PUBLIC_TOLGEE_API_URL:+***SET***}"
        echo "  NEXT_PUBLIC_URL: ${NEXT_PUBLIC_URL:+***SET***}"
        echo "  NEXT_PUBLIC_HASURA_GRAPHQL_URL: ${NEXT_PUBLIC_HASURA_GRAPHQL_URL:+***SET***}"
        echo "  NEXT_PUBLIC_API_GRAPHQL_URI: ${NEXT_PUBLIC_API_GRAPHQL_URI:+***SET***}"
        echo "  NEXT_PUBLIC_API_REST_URI: ${NEXT_PUBLIC_API_REST_URI:+***SET***}"
        # (portal auth is proxied via auth-service; no Keycloak vars required)
        
        docker build \
          -t "$IMAGE_TAG_MAIN" \
          -t "$IMAGE_TAG_LATEST" \
          -f "$DOCKERFILE_PATH" \
          --build-arg BUILD_COMMIT_SHA="${CI_COMMIT_SHA}" \
          --build-arg BUILD_VERSION="main" \
          --build-arg BUILD_BRANCH="${CI_COMMIT_REF_NAME}" \
          --build-arg NEXT_PUBLIC_TOLGEE_API_KEY="${NEXT_PUBLIC_TOLGEE_API_KEY}" \
          --build-arg NEXT_PUBLIC_TOLGEE_API_URL="${NEXT_PUBLIC_TOLGEE_API_URL}" \
          --build-arg NEXT_PUBLIC_URL="${NEXT_PUBLIC_URL}" \
          --build-arg NEXT_PUBLIC_HASURA_GRAPHQL_URL="${NEXT_PUBLIC_HASURA_GRAPHQL_URL}" \
          --build-arg NEXT_PUBLIC_API_GRAPHQL_URI="${NEXT_PUBLIC_API_GRAPHQL_URI}" \
          --build-arg NEXT_PUBLIC_API_REST_URI="${NEXT_PUBLIC_API_REST_URI}" \
          "$BUILD_CONTEXT"
      elif [ "$SERVICE_NAME" = "landing" ]; then
        echo "Building landing - fetching secrets from Vault..."
        get_vault_secrets_for_landing
        if [ -z "$NEXT_PUBLIC_TOLGEE_API_KEY" ] || [ -z "$NEXT_PUBLIC_TOLGEE_API_URL" ]; then
          echo "ERROR: Required NEXT_PUBLIC_* variables are empty after fetching from Vault"
          exit 1
        fi
        docker build \
          -t "$IMAGE_TAG_MAIN" \
          -t "$IMAGE_TAG_LATEST" \
          -f "$DOCKERFILE_PATH" \
          --build-arg BUILD_COMMIT_SHA="${CI_COMMIT_SHA}" \
          --build-arg BUILD_VERSION="main" \
          --build-arg BUILD_BRANCH="${CI_COMMIT_REF_NAME}" \
          --build-arg NEXT_PUBLIC_TOLGEE_API_KEY="${NEXT_PUBLIC_TOLGEE_API_KEY}" \
          --build-arg NEXT_PUBLIC_TOLGEE_API_URL="${NEXT_PUBLIC_TOLGEE_API_URL}" \
          --build-arg NEXT_PUBLIC_SITE_URL="${NEXT_PUBLIC_SITE_URL}" \
          "$BUILD_CONTEXT"
      else
        docker build \
          -t "$IMAGE_TAG_MAIN" \
          -t "$IMAGE_TAG_LATEST" \
          -f "$DOCKERFILE_PATH" \
          --build-arg BUILD_COMMIT_SHA="${CI_COMMIT_SHA}" \
          --build-arg BUILD_VERSION="main" \
          --build-arg BUILD_BRANCH="${CI_COMMIT_REF_NAME}" \
          "$BUILD_CONTEXT"
      fi
    - docker push "$IMAGE_TAG_MAIN"
    - docker push "$IMAGE_TAG_LATEST"
    - |
      echo "✅ Images pushed:"
      echo "  - $IMAGE_TAG_MAIN"
      echo "  - $IMAGE_TAG_LATEST"
  after_script:
    - docker logout "$REGISTRY_URL" || true
  rules:
    # Собираем для main ветки и MR в main, только если изменены файлы в packages/
    - if: $CI_COMMIT_REF_NAME == "main" && $CI_PIPELINE_SOURCE == "push"
      changes:
        - packages/**/*
    - if: $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "main" && $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - packages/**/*

# ============================================
# Registry cleanup (keep only recent tags)
# ============================================

.cleanup_registry_image:
  stage: cleanup
  image: alpine:3.19
  # Cleanup must never block delivery if registry API forbids deletes.
  allow_failure: true
  before_script:
    - apk add --no-cache curl jq coreutils >/dev/null
    - export REGISTRY_URL="${REGISTRY_URL:-archpad-cr.registry.twcstorage.ru}"
    - export REGISTRY_IMAGE_PREFIX="${REGISTRY_IMAGE_PREFIX:-archpad}"
    - |
      if [ -z "${REGISTRY_USERNAME:-}" ] || [ -z "${REGISTRY_PASSWORD:-}" ]; then
        echo "WARNING: REGISTRY_USERNAME/REGISTRY_PASSWORD not set; skipping cleanup"
        exit 0
      fi
  script:
    - |
      set -eu

      # Job name format:
      # - cleanup:main:<service>
      # - cleanup:<service>
      SERVICE_NAME="${CI_JOB_NAME#cleanup:}"
      SERVICE_NAME="${SERVICE_NAME#main:}"

      REPO="${REGISTRY_IMAGE_PREFIX}/${SERVICE_NAME}"
      BASE="https://${REGISTRY_URL}"

      echo "Registry cleanup for repo=${REPO}"
      echo "Keeping: latest + new tag + 2 most recent historical tags"

      # Determine NEW_TAG from pipeline context (main vs release).
      COMMIT_SHA="${CI_COMMIT_SHORT_SHA:-$(echo "${CI_COMMIT_SHA:-}" | cut -c1-8)}"
      if echo "$CI_JOB_NAME" | grep -q '^cleanup:main:'; then
        NEW_TAG="main-${COMMIT_SHA}"
      else
        if echo "${CI_COMMIT_REF_NAME:-}" | grep -qE '^r[/-][0-9]+\.[0-9]+\.[0-9]+$'; then
          VERSION="$(echo "$CI_COMMIT_REF_NAME" | sed -E 's/^r[\/-]([0-9]+\.[0-9]+\.[0-9]+)$/\1/')"
          NEW_TAG="${VERSION}-${COMMIT_SHA}"
        else
          echo "WARNING: Not a main push or release branch; skipping cleanup"
          exit 0
        fi
      fi
      echo "NEW_TAG=${NEW_TAG}"

      # 1) Discover auth realm/service from registry challenge
      challenge="$(curl -fsSI "${BASE}/v2/" | tr -d '\r' | awk -F': ' 'tolower($1)=="www-authenticate"{print $2}' || true)"
      if [ -z "$challenge" ]; then
        echo "WARNING: no WWW-Authenticate challenge from registry; skipping cleanup"
        exit 0
      fi

      realm="$(printf "%s" "$challenge" | sed -nE 's/.*realm="([^"]+)".*/\1/p')"
      service="$(printf "%s" "$challenge" | sed -nE 's/.*service="([^"]+)".*/\1/p')"
      if [ -z "$realm" ]; then
        echo "WARNING: cannot parse auth realm; skipping cleanup"
        exit 0
      fi

      # Build token URL: add service (if missing) + scope with delete.
      token_url="$realm"
      sep='?'
      echo "$token_url" | grep -q '?' && sep='&' || true
      echo "$token_url" | grep -q 'service=' || {
        [ -n "${service:-}" ] && token_url="${token_url}${sep}service=$(printf "%s" "$service" | jq -sRr @uri)" && sep='&'
      }
      scope="repository:${REPO}:pull,push,delete"
      token_url="${token_url}${sep}scope=$(printf "%s" "$scope" | jq -sRr @uri)"

      token_json="$(curl -fsS -u "${REGISTRY_USERNAME}:${REGISTRY_PASSWORD}" "$token_url" || true)"
      token="$(printf "%s" "$token_json" | jq -r '.token // .access_token // empty' 2>/dev/null || true)"
      if [ -z "$token" ]; then
        echo "WARNING: cannot get registry token (maybe delete scope not allowed); skipping cleanup"
        exit 0
      fi

      authz="Authorization: Bearer ${token}"

      # 2) List tags
      tags_json="$(curl -fsS -H "$authz" "${BASE}/v2/${REPO}/tags/list?n=1000" || true)"
      tags="$(printf "%s" "$tags_json" | jq -r '.tags[]? // empty' | tr -d '\r' || true)"
      if [ -z "$tags" ]; then
        echo "No tags found (or cannot list tags). Nothing to cleanup."
        exit 0
      fi

      # Helpers
      accept_header="Accept: application/vnd.oci.image.manifest.v1+json, application/vnd.docker.distribution.manifest.v2+json, application/vnd.docker.distribution.manifest.list.v2+json, application/vnd.oci.image.index.v1+json"

      get_manifest_json() {
        # $1 = ref (tag or digest)
        curl -fsS -H "$authz" -H "$accept_header" "${BASE}/v2/${REPO}/manifests/$1"
      }

      get_manifest_digest_for_tag() {
        # $1 = tag
        curl -fsSI -H "$authz" -H "$accept_header" "${BASE}/v2/${REPO}/manifests/$1" \
          | tr -d '\r' \
          | awk -F': ' 'tolower($1)=="docker-content-digest"{print $2}' \
          | tail -n 1
      }

      get_created_for_ref() {
        # $1 = tag
        m="$(get_manifest_json "$1" || true)"
        if [ -z "$m" ]; then
          echo "0000-00-00T00:00:00Z"
          return 0
        fi
        cfg="$(printf "%s" "$m" | jq -r '.config.digest // empty')"
        if [ -z "$cfg" ]; then
          # Possibly a manifest list/index; try first child manifest.
          child="$(printf "%s" "$m" | jq -r '.manifests[0].digest // empty')"
          if [ -n "$child" ]; then
            m2="$(get_manifest_json "$child" || true)"
            cfg="$(printf "%s" "$m2" | jq -r '.config.digest // empty')"
          fi
        fi
        if [ -z "$cfg" ]; then
          echo "0000-00-00T00:00:00Z"
          return 0
        fi
        cfg_json="$(curl -fsS -H "$authz" "${BASE}/v2/${REPO}/blobs/$cfg" || true)"
        created="$(printf "%s" "$cfg_json" | jq -r '.created // empty' 2>/dev/null || true)"
        echo "${created:-0000-00-00T00:00:00Z}"
      }

      # 3) Build tag -> created + tag -> digest mappings
      # Keep always: latest + NEW_TAG + 2 newest other tags
      tmp="$(mktemp)"
      tmp_dig="$(mktemp)"

      printf "%s\n" "$tags" | while read -r tag; do
        [ -n "$tag" ] || continue
        created="$(get_created_for_ref "$tag")"
        printf "%s\t%s\n" "$created" "$tag" >> "$tmp"
      done

      # Sort by created desc (ISO-8601 lexicographic)
      sorted_tags="$(sort -r "$tmp" | awk -F'\t' '{print $2}')"

      keep_latest="latest"
      keep_new="$NEW_TAG"
      extra_keep="$(printf "%s\n" "$sorted_tags" \
        | awk -v k1="$keep_latest" -v k2="$keep_new" '
            $0!=k1 && $0!=k2 && length($0)>0 {print $0}
          ' \
        | head -n 2)"

      echo "Keep tags:"
      echo " - $keep_latest"
      echo " - $keep_new"
      printf "%s\n" "$extra_keep" | sed 's/^/ - /'

      # Compute digest for every tag once
      printf "%s\n" "$tags" | while read -r tag; do
        [ -n "$tag" ] || continue
        dig="$(get_manifest_digest_for_tag "$tag" || true)"
        [ -n "$dig" ] || continue
        printf "%s\t%s\n" "$tag" "$dig" >> "$tmp_dig"
      done

      # Build keep set
      keep_file="$(mktemp)"
      {
        echo "$keep_latest"
        echo "$keep_new"
        printf "%s\n" "$extra_keep"
      } | awk 'length($0)>0' | sort -u > "$keep_file"

      # 4) Delete tags not in keep set, but only if their digest is not used by any keep tag
      # Build digest -> has_keep_tag
      keep_dig_file="$(mktemp)"
      while read -r kt; do
        kd="$(awk -v t="$kt" -F'\t' '$1==t {print $2}' "$tmp_dig" | tail -n 1)"
        [ -n "$kd" ] && echo "$kd" >> "$keep_dig_file" || true
      done < "$keep_file"
      sort -u "$keep_dig_file" -o "$keep_dig_file"

      deleted=0
      skipped=0

      # Delete by digest (safe with shared tags)
      uniq_dig="$(mktemp)"
      sort -u "$tmp_dig" > "$uniq_dig"
      while read -r line; do
        tag="$(printf "%s" "$line" | awk -F'\t' '{print $1}')"
        dig="$(printf "%s" "$line" | awk -F'\t' '{print $2}')"
        [ -n "${tag:-}" ] || continue
        [ -n "${dig:-}" ] || continue

        # Skip keep tags
        if grep -qx "$tag" "$keep_file"; then
          continue
        fi

        # If digest is referenced by keep tags (e.g. latest), don't delete it
        if grep -qx "$dig" "$keep_dig_file"; then
          echo "SKIP tag=$tag digest=$dig (digest is still referenced by kept tag)"
          skipped=$((skipped + 1))
          continue
        fi

        echo "DELETE manifest digest=$dig (tag=$tag)"
        if curl -fsS -X DELETE -H "$authz" "${BASE}/v2/${REPO}/manifests/${dig}" >/dev/null; then
          deleted=$((deleted + 1))
        else
          echo "WARNING: delete failed for digest=$dig (tag=$tag)"
        fi
      done < "$uniq_dig"

      echo "Cleanup done: deleted_manifests=$deleted skipped_due_to_keep_digest=$skipped"
      rm -f "$tmp" "$tmp_dig" "$uniq_dig" "$keep_file" "$keep_dig_file"

# ============================================
# Backend Services
# ============================================

build:arch-repo-service:
  extends: .build_docker_image
  variables:
    DOCKERFILE_PATH: "packages/backend/apps/arch-repo-service/Dockerfile"
    BUILD_CONTEXT: "."

cleanup:arch-repo-service:
  extends: .cleanup_registry_image
  needs: ["build:arch-repo-service"]
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^r[\/-][0-9]+\.[0-9]+\.[0-9]+$/

build:tenant-service:
  extends: .build_docker_image
  variables:
    DOCKERFILE_PATH: "packages/backend/apps/tenant-service/Dockerfile"
    BUILD_CONTEXT: "."

cleanup:tenant-service:
  extends: .cleanup_registry_image
  needs: ["build:tenant-service"]
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^r[\/-][0-9]+\.[0-9]+\.[0-9]+$/

build:hasura-sync-service:
  extends: .build_docker_image
  variables:
    DOCKERFILE_PATH: "packages/backend/apps/hasura-sync-service/Dockerfile"
    BUILD_CONTEXT: "."

cleanup:hasura-sync-service:
  extends: .cleanup_registry_image
  needs: ["build:hasura-sync-service"]
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^r[\/-][0-9]+\.[0-9]+\.[0-9]+$/

build:auth-service:
  extends: .build_docker_image
  variables:
    DOCKERFILE_PATH: "packages/backend/apps/auth-service/Dockerfile"
    BUILD_CONTEXT: "."

cleanup:auth-service:
  extends: .cleanup_registry_image
  needs: ["build:auth-service"]
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^r[\/-][0-9]+\.[0-9]+\.[0-9]+$/

# ============================================
# Frontend
# ============================================

build:portal:
  extends: .build_docker_image
  variables:
    DOCKERFILE_PATH: "packages/frontend/portal/Dockerfile"
    BUILD_CONTEXT: "."

cleanup:portal:
  extends: .cleanup_registry_image
  needs: ["build:portal"]
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^r[\/-][0-9]+\.[0-9]+\.[0-9]+$/

build:landing:
  extends: .build_docker_image
  variables:
    DOCKERFILE_PATH: "packages/frontend/landing/Dockerfile"
    BUILD_CONTEXT: "."

cleanup:landing:
  extends: .cleanup_registry_image
  needs: ["build:landing"]
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^r[\/-][0-9]+\.[0-9]+\.[0-9]+$/

# ============================================
# Update deployment image tags (GitOps: one commit per pipeline)
# ============================================
# После успешной сборки обновляет теги образов в затронутых манифестах и делает ОДИН коммит.
# ArgoCD подтягивает изменения и деплоит новые образы.

.update_deploy_images_main:
  stage: update-deploy-tags
  image: alpine:3.19
  before_script:
    - apk add --no-cache git
    - export COMMIT_SHA=$(echo "$CI_COMMIT_SHA" | cut -c1-8)
    - git config --global user.name "GitLab CI"
    - git config --global user.email "ci@archpad.pro"
    - |
      if [ -z "$GIT_PUSH_TOKEN" ]; then
        echo "ERROR: GIT_PUSH_TOKEN is not set (required for deploy image update)"
        exit 1
      fi
      git remote set-url origin "https://gitlab-ci-token:${GIT_PUSH_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
    - git fetch origin main
    - git checkout -B main origin/main
  script:
    - export REGISTRY_URL="${REGISTRY_URL:-archpad-cr.registry.twcstorage.ru}"
    - export REGISTRY_IMAGE_PREFIX="${REGISTRY_IMAGE_PREFIX:-archpad}"
    - |
      set -eu

      REGISTRY="${REGISTRY_URL}"
      PREFIX="${REGISTRY_IMAGE_PREFIX}"
      NEW_TAG="main-${COMMIT_SHA}"

      echo "Selecting deploy manifests to update based on changed files"
      if [ -n "${CI_COMMIT_BEFORE_SHA:-}" ] && [ "${CI_COMMIT_BEFORE_SHA}" != "0000000000000000000000000000000000000000" ]; then
        CHANGED_FILES="$(git diff --name-only "${CI_COMMIT_BEFORE_SHA}" "${CI_COMMIT_SHA}" || true)"
      else
        CHANGED_FILES="$(git show --pretty='' --name-only "${CI_COMMIT_SHA}" || true)"
      fi

      if [ -z "${CHANGED_FILES}" ]; then
        echo "No changed files found, skipping deploy manifest update."
        exit 0
      fi

      printf "%s\n" "${CHANGED_FILES}" | sed 's/^/ - /'

      update_image_tag() {
        service="$1"
        deploy_file="$2"
        image_base="${REGISTRY}/${PREFIX}/${service}"
        echo "Updating ${deploy_file}: ${image_base}:* -> ${image_base}:${NEW_TAG}"
        sed -i "s|\\(${image_base}:\\)[a-zA-Z0-9._-]*|\\1${NEW_TAG}|g" "${deploy_file}"
        git add "${deploy_file}"
      }

      if printf "%s\n" "${CHANGED_FILES}" | grep -Eq '^packages/backend/apps/arch-repo-service/|^packages/backend/libs/|^packages/contract/'; then
        update_image_tag "arch-repo-service" "infra/timeweb/10-gitops/apps/backend/arch-repo-service/arch-repo-service.deployment.yaml"
      fi

      if printf "%s\n" "${CHANGED_FILES}" | grep -Eq '^packages/backend/apps/tenant-service/|^packages/backend/libs/|^packages/contract/'; then
        update_image_tag "tenant-service" "infra/timeweb/10-gitops/apps/backend/tenant-service/tenant-service.deployment.yaml"
      fi

      if printf "%s\n" "${CHANGED_FILES}" | grep -Eq '^packages/backend/apps/auth-service/|^packages/backend/libs/|^packages/contract/'; then
        update_image_tag "auth-service" "infra/timeweb/10-gitops/apps/backend/auth-service/auth-service.deployment.yaml"
      fi

      if printf "%s\n" "${CHANGED_FILES}" | grep -Eq '^packages/backend/apps/hasura-sync-service/|^packages/backend/libs/|^packages/contract/'; then
        update_image_tag "hasura-sync-service" "infra/timeweb/10-gitops/apps/backend/hasura-sync-service/hasura-sync-service.job.yaml"
      fi

      if printf "%s\n" "${CHANGED_FILES}" | grep -Eq '^packages/frontend/portal/|^packages/frontend/lib/logger/|^packages/contract/'; then
        update_image_tag "portal" "infra/timeweb/10-gitops/apps/frontend/portal/portal.deployment.yaml"
      fi

      if printf "%s\n" "${CHANGED_FILES}" | grep -Eq '^packages/frontend/landing/|^packages/frontend/lib/logger/'; then
        update_image_tag "landing" "infra/timeweb/10-gitops/apps/frontend/landing/landing.deployment.yaml"
      fi

      if git diff --cached --quiet; then
        echo "No deploy manifest changes to commit."
        exit 0
      fi

      git commit -m "chore(deploy): update manifests to ${NEW_TAG} [ci skip]"
      git push origin main

# ============================================
# Backend Services (main ветка)
# ============================================

build:main:arch-repo-service:
  extends: .build_docker_image_main
  variables:
    DOCKERFILE_PATH: "packages/backend/apps/arch-repo-service/Dockerfile"
    BUILD_CONTEXT: "."
  rules:
    # Собираем только если изменены файлы в arch-repo-service
    - if: $CI_COMMIT_REF_NAME == "main" && $CI_PIPELINE_SOURCE == "push"
      changes:
        - packages/backend/apps/arch-repo-service/**/*
        - packages/backend/libs/**/*
        - packages/contract/**/*
    - if: $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "main" && $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - packages/backend/apps/arch-repo-service/**/*
        - packages/backend/libs/**/*
        - packages/contract/**/*

cleanup:main:arch-repo-service:
  extends: .cleanup_registry_image
  needs: ["build:main:arch-repo-service"]
  rules:
    - if: $CI_COMMIT_REF_NAME == "main" && $CI_PIPELINE_SOURCE == "push"
      changes:
        - packages/backend/apps/arch-repo-service/**/*
        - packages/backend/libs/**/*
        - packages/contract/**/*

build:main:tenant-service:
  extends: .build_docker_image_main
  variables:
    DOCKERFILE_PATH: "packages/backend/apps/tenant-service/Dockerfile"
    BUILD_CONTEXT: "."
  rules:
    # Собираем только если изменены файлы в tenant-service
    - if: $CI_COMMIT_REF_NAME == "main" && $CI_PIPELINE_SOURCE == "push"
      changes:
        - packages/backend/apps/tenant-service/**/*
        - packages/backend/libs/**/*
        - packages/contract/**/*
    - if: $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "main" && $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - packages/backend/apps/tenant-service/**/*
        - packages/backend/libs/**/*
        - packages/contract/**/*

cleanup:main:tenant-service:
  extends: .cleanup_registry_image
  needs: ["build:main:tenant-service"]
  rules:
    - if: $CI_COMMIT_REF_NAME == "main" && $CI_PIPELINE_SOURCE == "push"
      changes:
        - packages/backend/apps/tenant-service/**/*
        - packages/backend/libs/**/*
        - packages/contract/**/*

build:main:auth-service:
  extends: .build_docker_image_main
  variables:
    DOCKERFILE_PATH: "packages/backend/apps/auth-service/Dockerfile"
    BUILD_CONTEXT: "."
  rules:
    - if: $CI_COMMIT_REF_NAME == "main" && $CI_PIPELINE_SOURCE == "push"
      changes:
        - packages/backend/apps/auth-service/**/*
        - packages/backend/libs/**/*
        - packages/contract/**/*
    - if: $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "main" && $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - packages/backend/apps/auth-service/**/*
        - packages/backend/libs/**/*
        - packages/contract/**/*

cleanup:main:auth-service:
  extends: .cleanup_registry_image
  needs: ["build:main:auth-service"]
  rules:
    - if: $CI_COMMIT_REF_NAME == "main" && $CI_PIPELINE_SOURCE == "push"
      changes:
        - packages/backend/apps/auth-service/**/*
        - packages/backend/libs/**/*
        - packages/contract/**/*

build:main:hasura-sync-service:
  extends: .build_docker_image_main
  variables:
    DOCKERFILE_PATH: "packages/backend/apps/hasura-sync-service/Dockerfile"
    BUILD_CONTEXT: "."
  rules:
    # Собираем только если изменены файлы в hasura-sync-service
    - if: $CI_COMMIT_REF_NAME == "main" && $CI_PIPELINE_SOURCE == "push"
      changes:
        - packages/backend/apps/hasura-sync-service/**/*
        - packages/backend/libs/**/*
        - packages/contract/**/*
    - if: $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "main" && $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - packages/backend/apps/hasura-sync-service/**/*
        - packages/backend/libs/**/*
        - packages/contract/**/*

cleanup:main:hasura-sync-service:
  extends: .cleanup_registry_image
  needs: ["build:main:hasura-sync-service"]
  rules:
    - if: $CI_COMMIT_REF_NAME == "main" && $CI_PIPELINE_SOURCE == "push"
      changes:
        - packages/backend/apps/hasura-sync-service/**/*
        - packages/backend/libs/**/*
        - packages/contract/**/*

# ============================================
# Frontend (main ветка)
# ============================================

build:main:portal:
  extends: .build_docker_image_main
  variables:
    DOCKERFILE_PATH: "packages/frontend/portal/Dockerfile"
    BUILD_CONTEXT: "."
  rules:
    # Собираем только если изменены файлы в portal
    - if: $CI_COMMIT_REF_NAME == "main" && $CI_PIPELINE_SOURCE == "push"
      changes:
        - packages/frontend/portal/**/*
        - packages/frontend/lib/logger/**/*
        - packages/contract/**/*
    - if: $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "main" && $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - packages/frontend/portal/**/*
        - packages/frontend/lib/logger/**/*
        - packages/contract/**/*

cleanup:main:portal:
  extends: .cleanup_registry_image
  needs: ["build:main:portal"]
  rules:
    - if: $CI_COMMIT_REF_NAME == "main" && $CI_PIPELINE_SOURCE == "push"
      changes:
        - packages/frontend/portal/**/*
        - packages/frontend/lib/logger/**/*
        - packages/contract/**/*

build:main:landing:
  extends: .build_docker_image_main
  variables:
    DOCKERFILE_PATH: "packages/frontend/landing/Dockerfile"
    BUILD_CONTEXT: "."
  rules:
    - if: $CI_COMMIT_REF_NAME == "main" && $CI_PIPELINE_SOURCE == "push"
      changes:
        - packages/frontend/landing/**/*
        - packages/frontend/lib/logger/**/*
    - if: $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "main" && $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - packages/frontend/landing/**/*
        - packages/frontend/lib/logger/**/*

cleanup:main:landing:
  extends: .cleanup_registry_image
  needs: ["build:main:landing"]
  rules:
    - if: $CI_COMMIT_REF_NAME == "main" && $CI_PIPELINE_SOURCE == "push"
      changes:
        - packages/frontend/landing/**/*
        - packages/frontend/lib/logger/**/*

update:main:deploy-images:
  extends: .update_deploy_images_main
  needs:
    - job: build:main:arch-repo-service
      optional: true
      artifacts: false
    - job: build:main:tenant-service
      optional: true
      artifacts: false
    - job: build:main:auth-service
      optional: true
      artifacts: false
    - job: build:main:hasura-sync-service
      optional: true
      artifacts: false
    - job: build:main:portal
      optional: true
      artifacts: false
    - job: build:main:landing
      optional: true
      artifacts: false
  rules:
    - if: $CI_COMMIT_REF_NAME == "main" && $CI_PIPELINE_SOURCE == "push"
      changes:
        - packages/backend/apps/arch-repo-service/**/*
        - packages/backend/apps/tenant-service/**/*
        - packages/backend/apps/auth-service/**/*
        - packages/backend/apps/hasura-sync-service/**/*
        - packages/backend/libs/**/*
        - packages/frontend/portal/**/*
        - packages/frontend/landing/**/*
        - packages/frontend/lib/logger/**/*
        - packages/contract/**/*

# ============================================
# Version Update (обновление версий в package.json)
# ============================================

update:versions:
  stage: version
  image: alpine:latest
  before_script:
    - apk add --no-cache git jq curl
    - export COMMIT_SHA=$(echo $CI_COMMIT_SHA | cut -c1-8)
    # Извлекаем версию из имени ветки (r/X.Y.Z или r-x.y.z)
    - |
      if echo "$CI_COMMIT_REF_NAME" | grep -qE '^r[/-][0-9]+\.[0-9]+\.[0-9]+$'; then
        VERSION=$(echo "$CI_COMMIT_REF_NAME" | sed -E 's/^r[\/-]([0-9]+\.[0-9]+\.[0-9]+)$/\1/')
        export VERSION
        echo "Version extracted from branch: $VERSION"
      else
        echo "ERROR: Branch name must match pattern r/X.Y.Z or r-x.y.z"
        exit 1
      fi
    # Настраиваем git для коммита
    - git config --global user.name "GitLab CI"
    - git config --global user.email "ci@archpad.pro"
    # Используем Personal Access Token или Project Access Token для push
    # CI_JOB_TOKEN не имеет прав на push, Deploy Token не поддерживает write_repository
    - |
      echo "Checking GIT_PUSH_TOKEN..."
      if [ -z "$GIT_PUSH_TOKEN" ]; then
        echo "=========================================="
        echo "ERROR: GIT_PUSH_TOKEN is not set"
        echo "=========================================="
        echo "Please create a Personal Access Token or Project Access Token:"
        echo ""
        echo "Option 1: Personal Access Token (recommended, works immediately)"
        echo "  1. Go to: User Settings → Access Tokens"
        echo "     (Click on your avatar → Preferences → Access Tokens)"
        echo "  2. Token name: git-push-token"
        echo "  3. Expiration date: set as needed"
        echo "  4. Scopes: select 'write_repository'"
        echo "  5. Click 'Create personal access token'"
        echo "  6. Copy the token (shown only once!)"
        echo "  7. Go to project: Settings → CI/CD → Variables"
        echo "  8. Add variable:"
        echo "     - Key: GIT_PUSH_TOKEN"
        echo "     - Value: <paste token>"
        echo "     - Type: Variable"
        echo "     - Flags: Masked (recommended)"
        echo ""
        echo "Option 2: Project Access Token (requires group settings)"
        echo "  NOTE: If disabled in group, enable it first:"
        echo "  - Group Settings → General → Permissions"
        echo "  - Enable 'Project access token creation'"
        echo ""
        echo "  Then create token:"
        echo "  1. Go to: Settings → Access Tokens"
        echo "  2. Token name: git-push-token"
        echo "  3. Role: Maintainer or Owner"
        echo "  4. Scopes: select 'write_repository'"
        echo "  5. Create and copy token"
        echo "  6. Add as CI/CD variable: GIT_PUSH_TOKEN"
        echo "=========================================="
        exit 1
      fi
      echo "GIT_PUSH_TOKEN is set (length: ${#GIT_PUSH_TOKEN} characters)"
      git remote set-url origin "https://gitlab-ci-token:${GIT_PUSH_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
      echo "Git remote URL configured with GIT_PUSH_TOKEN"
    - git fetch origin "$CI_COMMIT_REF_NAME" || git fetch origin "$CI_DEFAULT_BRANCH"
    - |
      # В GitLab CI мы уже в нужном коммите, но нужно переключиться на ветку для коммита
      if git show-ref --verify --quiet "refs/remotes/origin/$CI_COMMIT_REF_NAME"; then
        # Ветка существует, переключаемся на неё
        git checkout -B "$CI_COMMIT_REF_NAME" "origin/$CI_COMMIT_REF_NAME"
      else
        # Ветка не существует, создаём её из текущего коммита
        echo "Branch $CI_COMMIT_REF_NAME does not exist, creating from current commit"
        git checkout -b "$CI_COMMIT_REF_NAME"
      fi
  script:
    - |
      echo "📦 Updating package.json versions to $VERSION"
      echo ""
      
      # Функция для обновления version в package.json
      update_version() {
        local file=$1
        if [ -f "$file" ]; then
          local current_version=$(jq -r '.version // empty' "$file")
          if [ -n "$current_version" ]; then
            echo "  Updating $file: $current_version → $VERSION"
            jq --arg version "$VERSION" '.version = $version' "$file" > "${file}.tmp" && mv "${file}.tmp" "$file"
          else
            echo "  Adding version to $file: $VERSION"
            jq --arg version "$VERSION" '. + {version: $version}' "$file" > "${file}.tmp" && mv "${file}.tmp" "$file"
          fi
        else
          echo "  ⚠️  File not found: $file"
        fi
      }
      
      # Обновляем версии в package.json файлах
      update_version "packages/frontend/portal/package.json"
      update_version "packages/frontend/landing/package.json"
      update_version "packages/contract/package.json"
      update_version "packages/backend/package.json"
      
      echo ""
      echo "📋 Checking for changes..."
      echo "Current git status:"
      git status --short || true
      
      echo ""
      echo "Checking file contents after update:"
      echo "  packages/frontend/portal/package.json version: $(jq -r '.version // "not set"' packages/frontend/portal/package.json)"
      echo "  packages/frontend/landing/package.json version: $(jq -r '.version // "not set"' packages/frontend/landing/package.json)"
      echo "  packages/contract/package.json version: $(jq -r '.version // "not set"' packages/contract/package.json)"
      echo "  packages/backend/package.json version: $(jq -r '.version // "not set"' packages/backend/package.json)"
      echo "  Expected version: $VERSION"
      
      # Добавляем измененные файлы
      echo ""
      echo "Staging package.json files..."
      git add packages/*/package.json packages/frontend/*/package.json packages/frontend/lib/*/package.json || true
      
      echo ""
      echo "Checking staged changes:"
      git diff --cached --stat || echo "No staged changes"
      
      echo ""
      echo "Checking unstaged changes:"
      git diff --stat || echo "No unstaged changes"
      
      # Проверяем наличие тега
      TAG_EXISTS_LOCAL=false
      TAG_EXISTS_REMOTE=false
      
      if git rev-parse "v$VERSION" >/dev/null 2>&1; then
        TAG_EXISTS_LOCAL=true
      fi
      
      if git ls-remote --exit-code --tags origin "refs/tags/v$VERSION" >/dev/null 2>&1; then
        TAG_EXISTS_REMOTE=true
      fi
      
      # Проверяем, есть ли изменения для коммита
      if git diff --cached --quiet && git diff --quiet; then
        echo ""
        echo "⚠️  No changes detected. Versions are already up to date."
        echo "This might mean versions were already updated in a previous run."
        
        # Но проверяем, нужно ли создать тег
        if [ "$TAG_EXISTS_LOCAL" = false ] && [ "$TAG_EXISTS_REMOTE" = false ]; then
          echo ""
          echo "🏷️  Creating git tag v$VERSION (versions are up to date, but tag is missing)..."
          git tag -a "v$VERSION" -m "Release version $VERSION"
          echo "🚀 Pushing tag v$VERSION..."
          git push origin "v$VERSION"
          echo "  ✅ Tag v$VERSION created and pushed"
        elif [ "$TAG_EXISTS_LOCAL" = false ] && [ "$TAG_EXISTS_REMOTE" = true ]; then
          echo ""
          echo "🏷️  Fetching tag v$VERSION from remote..."
          git fetch origin "refs/tags/v$VERSION:refs/tags/v$VERSION"
        fi
      else
        echo ""
        echo "📝 Committing version updates..."
        git commit -m "chore: bump version to $VERSION [ci skip]"
        
        echo ""
        echo "🏷️  Checking for git tag v$VERSION..."
        
        # Создаем тег, если его нет ни локально, ни на remote
        if [ "$TAG_EXISTS_LOCAL" = false ] && [ "$TAG_EXISTS_REMOTE" = false ]; then
          echo "  Creating git tag v$VERSION..."
          git tag -a "v$VERSION" -m "Release version $VERSION"
          echo "  ✅ Tag v$VERSION created"
        elif [ "$TAG_EXISTS_LOCAL" = false ] && [ "$TAG_EXISTS_REMOTE" = true ]; then
          # Тег есть на remote, но не локально - получаем его
          echo "  Tag v$VERSION exists on remote, fetching..."
          git fetch origin "refs/tags/v$VERSION:refs/tags/v$VERSION"
        else
          echo "  Tag v$VERSION already exists, skipping tag creation"
        fi
        
        echo ""
        echo "🚀 Pushing changes to $CI_COMMIT_REF_NAME..."
        git push origin "$CI_COMMIT_REF_NAME"
        
        # Push тега, если он был создан или обновлен локально
        if [ "$TAG_EXISTS_REMOTE" = false ]; then
          echo "🚀 Pushing tag v$VERSION..."
          git push origin "v$VERSION"
          echo "  ✅ Tag v$VERSION pushed to remote"
        fi
        
        echo ""
        echo "✅ Version $VERSION successfully updated in package.json files, committed, and tagged"
      fi
  rules:
    # Запускаем только для веток вида r/X.Y.Z или r-x.y.z
    - if: $CI_COMMIT_REF_NAME =~ /^r[\/-][0-9]+\.[0-9]+\.[0-9]+$/
  needs:
    - job: build:arch-repo-service
      artifacts: false
    - job: build:tenant-service
      artifacts: false
    - job: build:hasura-sync-service
      artifacts: false
    - job: build:portal
      artifacts: false
    - job: build:landing
      artifacts: false

# ============================================
# Deploy (информационный stage)
# ============================================

# Примечание: Автоматическое обновление образов в Kubernetes выполняется через ArgoCD Image Updater.
# ArgoCD Image Updater отслеживает новые образы в Container Registry и автоматически обновляет
# манифесты в Git репозитории. ArgoCD затем автоматически синхронизирует изменения.
# 
# См. документацию: docs/ARGOCD_IMAGE_UPDATER.md

deploy:update-images:
  stage: deploy
  image: alpine:latest
  before_script:
    - export COMMIT_SHA=$(echo $CI_COMMIT_SHA | cut -c1-8)
    # Извлекаем версию из имени ветки (r/X.Y.Z или r-x.y.z)
    - |
      if echo "$CI_COMMIT_REF_NAME" | grep -qE '^r[/-][0-9]+\.[0-9]+\.[0-9]+$'; then
        VERSION=$(echo "$CI_COMMIT_REF_NAME" | sed -E 's/^r[\/-]([0-9]+\.[0-9]+\.[0-9]+)$/\1/')
        export VERSION
      else
        echo "ERROR: Branch name must match pattern r/X.Y.Z or r-x.y.z"
        exit 1
      fi
    - export REGISTRY_URL="${REGISTRY_URL:-archpad-cr.registry.twcstorage.ru}"
    - export REGISTRY_IMAGE_PREFIX="${REGISTRY_IMAGE_PREFIX:-archpad}"
  script:
    - 'echo "✅ Images built and pushed successfully"'
    - 'echo ""'
    - 'echo "Built images (version $VERSION, commit $COMMIT_SHA):"'
    - 'echo "  - arch-repo-service:${VERSION}-${COMMIT_SHA} (latest)"'
    - 'echo "  - tenant-service:${VERSION}-${COMMIT_SHA} (latest)"'
    - 'echo "  - hasura-sync-service:${VERSION}-${COMMIT_SHA} (latest)"'
    - 'echo "  - portal:${VERSION}-${COMMIT_SHA} (latest)"'
    - 'echo "  - landing:${VERSION}-${COMMIT_SHA} (latest)"'
    - echo ""
    - 'echo "📦 ArgoCD Image Updater will automatically detect new images and update Kubernetes manifests"'
    - 'echo "   See: docs/ARGOCD_IMAGE_UPDATER.md for details"'
  rules:
    # Запускаем только для веток вида r/X.Y.Z или r-x.y.z
    - if: $CI_COMMIT_REF_NAME =~ /^r[\/-][0-9]+\.[0-9]+\.[0-9]+$/
  needs:
    - job: update:versions
      artifacts: false
