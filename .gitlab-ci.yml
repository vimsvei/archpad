stages:
  - build
  - version
  - deploy

variables:
  # Container Registry TimeWeb
  # REGISTRY_URL –∏ REGISTRY_IMAGE_PREFIX –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –≤ GitLab CI/CD Variables
  # –ï—Å–ª–∏ –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã, –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é:
  REGISTRY_URL: "${REGISTRY_URL:-archpad-cr.registry.twcstorage.ru}"
  REGISTRY_IMAGE_PREFIX: "${REGISTRY_IMAGE_PREFIX:-archpad}"
  
  # Docker build settings
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"

# –®–∞–±–ª–æ–Ω –¥–ª—è —Å–±–æ—Ä–∫–∏ Docker –æ–±—Ä–∞–∑–∞
.build_docker_image:
  stage: build
  image: docker:24-dind
  services:
    - docker:24-dind
  before_script:
    - export COMMIT_SHA=$(echo $CI_COMMIT_SHA | cut -c1-8)
    # –ò–∑–≤–ª–µ–∫–∞–µ–º –≤–µ—Ä—Å–∏—é –∏–∑ –∏–º–µ–Ω–∏ –≤–µ—Ç–∫–∏ (r/X.Y.Z –∏–ª–∏ r-x.y.z)
    - |
      if echo "$CI_COMMIT_REF_NAME" | grep -qE '^r[/-][0-9]+\.[0-9]+\.[0-9]+$'; then
        # –ò–∑–≤–ª–µ–∫–∞–µ–º –≤–µ—Ä—Å–∏—é –∏–∑ –≤–µ—Ç–∫–∏ (r/X.Y.Z -> X.Y.Z –∏–ª–∏ r-x.y.z -> x.y.z)
        VERSION=$(echo "$CI_COMMIT_REF_NAME" | sed -E 's/^r[\/-]([0-9]+\.[0-9]+\.[0-9]+)$/\1/')
        export VERSION
        echo "Version extracted from branch: $VERSION"
      else
        echo "ERROR: Branch name must match pattern r/X.Y.Z or r-x.y.z"
        echo "Current branch: $CI_COMMIT_REF_NAME"
        exit 1
      fi
    # –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ REGISTRY_URL –∏ REGISTRY_IMAGE_PREFIX –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã –≤ GitLab CI/CD Variables
    # –û–Ω–∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –¥–æ—Å—Ç—É–ø–Ω—ã, –Ω–æ —É–±–µ–¥–∏–º—Å—è, —á—Ç–æ –æ–Ω–∏ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã
    - export REGISTRY_URL="${REGISTRY_URL:-archpad-cr.registry.twcstorage.ru}"
    - export REGISTRY_IMAGE_PREFIX="${REGISTRY_IMAGE_PREFIX:-archpad}"
    - 'echo "Building for version $VERSION (commit $COMMIT_SHA)"'
    - 'echo "Branch: $CI_COMMIT_REF_NAME"'
    - 'echo "Registry URL: $REGISTRY_URL"'
    - 'echo "Registry Image Prefix: $REGISTRY_IMAGE_PREFIX"'
    - |
      if [ -z "$REGISTRY_USERNAME" ] || [ -z "$REGISTRY_PASSWORD" ]; then
        echo "=========================================="
        echo "ERROR: Missing required CI/CD Variables"
        echo "=========================================="
        echo "Please set the following variables in GitLab:"
        echo "  Settings ‚Üí CI/CD ‚Üí Variables ‚Üí Expand"
        echo ""
        echo "Required variables:"
        [ -z "$REGISTRY_USERNAME" ] && echo "  ‚ùå REGISTRY_USERNAME (not set)" || echo "  ‚úÖ REGISTRY_USERNAME (set)"
        [ -z "$REGISTRY_PASSWORD" ] && echo "  ‚ùå REGISTRY_PASSWORD (not set)" || echo "  ‚úÖ REGISTRY_PASSWORD (set)"
        echo ""
        echo "How to set:"
        echo "  1. Go to: Settings ‚Üí CI/CD ‚Üí Variables"
        echo "  2. Click 'Add variable'"
        echo "  3. Set Key: REGISTRY_USERNAME, Value: your-registry-username"
        echo "  4. Set Key: REGISTRY_PASSWORD, Value: your-registry-password (masked)"
        echo "  5. Save and retry the pipeline"
        echo "=========================================="
        exit 1
      fi
    - 'echo "Logging in to registry: $REGISTRY_URL"'
    - echo "$REGISTRY_PASSWORD" | docker login -u "$REGISTRY_USERNAME" --password-stdin "$REGISTRY_URL"
  script:
    - export SERVICE_NAME="${CI_JOB_NAME#build:}"
    # –£–±–µ–∂–¥–∞–µ–º—Å—è, —á—Ç–æ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω—ã (–∏–∑ GitLab Variables –∏–ª–∏ fallback)
    - export REGISTRY_URL="${REGISTRY_URL:-archpad-cr.registry.twcstorage.ru}"
    - export REGISTRY_IMAGE_PREFIX="${REGISTRY_IMAGE_PREFIX:-archpad}"
    # –§–æ—Ä–º–∏—Ä—É–µ–º —Ç–µ–≥–∏ –æ–±—Ä–∞–∑–æ–≤: x.y.z-<commit-sha> –∏ latest
    - export IMAGE_TAG_VERSION="${REGISTRY_URL}/${REGISTRY_IMAGE_PREFIX}/${SERVICE_NAME}:${VERSION}-${COMMIT_SHA}"
    - export IMAGE_TAG_LATEST="${REGISTRY_URL}/${REGISTRY_IMAGE_PREFIX}/${SERVICE_NAME}:latest"
    - 'echo "Building $SERVICE_NAME version $VERSION (commit $COMMIT_SHA)"'
    - |
      echo "Image tags:"
      echo "  - ${IMAGE_TAG_VERSION}"
      echo "  - ${IMAGE_TAG_LATEST}"
    - 'echo "Dockerfile: $DOCKERFILE_PATH"'
    - 'echo "Build context: $BUILD_CONTEXT"'
    - docker build -t "$IMAGE_TAG_VERSION" -t "$IMAGE_TAG_LATEST" -f "$DOCKERFILE_PATH" "$BUILD_CONTEXT"
    - docker push "$IMAGE_TAG_VERSION"
    - docker push "$IMAGE_TAG_LATEST"
    - |
      echo "‚úÖ Images pushed:"
      echo "  - $IMAGE_TAG_VERSION"
      echo "  - $IMAGE_TAG_LATEST"
  after_script:
    - docker logout "$REGISTRY_URL" || true
  rules:
    # –°–æ–±–∏—Ä–∞–µ–º —Ç–æ–ª—å–∫–æ –¥–ª—è –≤–µ—Ç–æ–∫ –≤–∏–¥–∞ r/X.Y.Z –∏–ª–∏ r-x.y.z
    - if: $CI_COMMIT_REF_NAME =~ /^r[\/-][0-9]+\.[0-9]+\.[0-9]+$/

# –®–∞–±–ª–æ–Ω –¥–ª—è —Å–±–æ—Ä–∫–∏ Docker –æ–±—Ä–∞–∑–∞ –∏–∑ main –≤–µ—Ç–∫–∏
.build_docker_image_main:
  stage: build
  image: docker:24-dind
  services:
    - docker:24-dind
  before_script:
    - export COMMIT_SHA=$(echo $CI_COMMIT_SHA | cut -c1-8)
    - export REGISTRY_URL="${REGISTRY_URL:-archpad-cr.registry.twcstorage.ru}"
    - export REGISTRY_IMAGE_PREFIX="${REGISTRY_IMAGE_PREFIX:-archpad}"
    - 'echo "Building for main branch (commit $COMMIT_SHA)"'
    - 'echo "Branch: $CI_COMMIT_REF_NAME"'
    - 'echo "Registry URL: $REGISTRY_URL"'
    - 'echo "Registry Image Prefix: $REGISTRY_IMAGE_PREFIX"'
    - |
      if [ -z "$REGISTRY_USERNAME" ] || [ -z "$REGISTRY_PASSWORD" ]; then
        echo "=========================================="
        echo "ERROR: Missing required CI/CD Variables"
        echo "=========================================="
        echo "Please set the following variables in GitLab:"
        echo "  Settings ‚Üí CI/CD ‚Üí Variables ‚Üí Expand"
        echo ""
        echo "Required variables:"
        [ -z "$REGISTRY_USERNAME" ] && echo "  ‚ùå REGISTRY_USERNAME (not set)" || echo "  ‚úÖ REGISTRY_USERNAME (set)"
        [ -z "$REGISTRY_PASSWORD" ] && echo "  ‚ùå REGISTRY_PASSWORD (not set)" || echo "  ‚úÖ REGISTRY_PASSWORD (set)"
        echo ""
        echo "How to set:"
        echo "  1. Go to: Settings ‚Üí CI/CD ‚Üí Variables"
        echo "  2. Click 'Add variable'"
        echo "  3. Set Key: REGISTRY_USERNAME, Value: your-registry-username"
        echo "  4. Set Key: REGISTRY_PASSWORD, Value: your-registry-password (masked)"
        echo "  5. Save and retry the pipeline"
        echo "=========================================="
        exit 1
      fi
    - 'echo "Logging in to registry: $REGISTRY_URL"'
    - echo "$REGISTRY_PASSWORD" | docker login -u "$REGISTRY_USERNAME" --password-stdin "$REGISTRY_URL"
  script:
    - export SERVICE_NAME="${CI_JOB_NAME#build:main:}"
    - export REGISTRY_URL="${REGISTRY_URL:-archpad-cr.registry.twcstorage.ru}"
    - export REGISTRY_IMAGE_PREFIX="${REGISTRY_IMAGE_PREFIX:-archpad}"
    # –§–æ—Ä–º–∏—Ä—É–µ–º —Ç–µ–≥–∏ –æ–±—Ä–∞–∑–æ–≤: main-<commit-sha> –∏ latest
    - export IMAGE_TAG_MAIN="${REGISTRY_URL}/${REGISTRY_IMAGE_PREFIX}/${SERVICE_NAME}:main-${COMMIT_SHA}"
    - export IMAGE_TAG_LATEST="${REGISTRY_URL}/${REGISTRY_IMAGE_PREFIX}/${SERVICE_NAME}:latest"
    - 'echo "Building $SERVICE_NAME for main branch (commit $COMMIT_SHA)"'
    - |
      echo "Image tags:"
      echo "  - ${IMAGE_TAG_MAIN}"
      echo "  - ${IMAGE_TAG_LATEST}"
    - 'echo "Dockerfile: $DOCKERFILE_PATH"'
    - 'echo "Build context: $BUILD_CONTEXT"'
    - docker build -t "$IMAGE_TAG_MAIN" -t "$IMAGE_TAG_LATEST" -f "$DOCKERFILE_PATH" "$BUILD_CONTEXT"
    - docker push "$IMAGE_TAG_MAIN"
    - docker push "$IMAGE_TAG_LATEST"
    - |
      echo "‚úÖ Images pushed:"
      echo "  - $IMAGE_TAG_MAIN"
      echo "  - $IMAGE_TAG_LATEST"
  after_script:
    - docker logout "$REGISTRY_URL" || true
  rules:
    # –°–æ–±–∏—Ä–∞–µ–º –¥–ª—è main –≤–µ—Ç–∫–∏ –∏ MR –≤ main, —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ –∏–∑–º–µ–Ω–µ–Ω—ã —Ñ–∞–π–ª—ã –≤ packages/
    - if: $CI_COMMIT_REF_NAME == "main" && $CI_PIPELINE_SOURCE == "push"
      changes:
        - packages/**/*
    - if: $CI_MERGE_REQUEST_TARGET_BRANCH_NAME == "main" && $CI_PIPELINE_SOURCE == "merge_request_event"
      changes:
        - packages/**/*

# ============================================
# Backend Services
# ============================================

build:arch-repo-service:
  extends: .build_docker_image
  variables:
    DOCKERFILE_PATH: "packages/backend/apps/arch-repo-service/Dockerfile"
    BUILD_CONTEXT: "."

build:tenant-service:
  extends: .build_docker_image
  variables:
    DOCKERFILE_PATH: "packages/backend/apps/tenant-service/Dockerfile"
    BUILD_CONTEXT: "."

build:hasura-sync-service:
  extends: .build_docker_image
  variables:
    DOCKERFILE_PATH: "packages/backend/apps/hasura-sync-service/Dockerfile"
    BUILD_CONTEXT: "."

# ============================================
# Frontend
# ============================================

build:portal:
  extends: .build_docker_image
  variables:
    DOCKERFILE_PATH: "packages/portal/Dockerfile"
    BUILD_CONTEXT: "."

# ============================================
# Backend Services (main –≤–µ—Ç–∫–∞)
# ============================================

build:main:arch-repo-service:
  extends: .build_docker_image_main
  variables:
    DOCKERFILE_PATH: "packages/backend/apps/arch-repo-service/Dockerfile"
    BUILD_CONTEXT: "."

build:main:tenant-service:
  extends: .build_docker_image_main
  variables:
    DOCKERFILE_PATH: "packages/backend/apps/tenant-service/Dockerfile"
    BUILD_CONTEXT: "."

build:main:hasura-sync-service:
  extends: .build_docker_image_main
  variables:
    DOCKERFILE_PATH: "packages/backend/apps/hasura-sync-service/Dockerfile"
    BUILD_CONTEXT: "."

# ============================================
# Frontend (main –≤–µ—Ç–∫–∞)
# ============================================

build:main:portal:
  extends: .build_docker_image_main
  variables:
    DOCKERFILE_PATH: "packages/portal/Dockerfile"
    BUILD_CONTEXT: "."

# ============================================
# Version Update (–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤–µ—Ä—Å–∏–π –≤ package.json)
# ============================================

update:versions:
  stage: version
  image: alpine:latest
  before_script:
    - apk add --no-cache git jq curl
    - export COMMIT_SHA=$(echo $CI_COMMIT_SHA | cut -c1-8)
    # –ò–∑–≤–ª–µ–∫–∞–µ–º –≤–µ—Ä—Å–∏—é –∏–∑ –∏–º–µ–Ω–∏ –≤–µ—Ç–∫–∏ (r/X.Y.Z –∏–ª–∏ r-x.y.z)
    - |
      if echo "$CI_COMMIT_REF_NAME" | grep -qE '^r[/-][0-9]+\.[0-9]+\.[0-9]+$'; then
        VERSION=$(echo "$CI_COMMIT_REF_NAME" | sed -E 's/^r[\/-]([0-9]+\.[0-9]+\.[0-9]+)$/\1/')
        export VERSION
        echo "Version extracted from branch: $VERSION"
      else
        echo "ERROR: Branch name must match pattern r/X.Y.Z or r-x.y.z"
        exit 1
      fi
    # –ù–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º git –¥–ª—è –∫–æ–º–º–∏—Ç–∞
    - git config --global user.name "GitLab CI"
    - git config --global user.email "ci@archpad.pro"
    # –ò—Å–ø–æ–ª—å–∑—É–µ–º Personal Access Token –∏–ª–∏ Project Access Token –¥–ª—è push
    # CI_JOB_TOKEN –Ω–µ –∏–º–µ–µ—Ç –ø—Ä–∞–≤ –Ω–∞ push, Deploy Token –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç write_repository
    - |
      echo "Checking GIT_PUSH_TOKEN..."
      if [ -z "$GIT_PUSH_TOKEN" ]; then
        echo "=========================================="
        echo "ERROR: GIT_PUSH_TOKEN is not set"
        echo "=========================================="
        echo "Please create a Personal Access Token or Project Access Token:"
        echo ""
        echo "Option 1: Personal Access Token (recommended, works immediately)"
        echo "  1. Go to: User Settings ‚Üí Access Tokens"
        echo "     (Click on your avatar ‚Üí Preferences ‚Üí Access Tokens)"
        echo "  2. Token name: git-push-token"
        echo "  3. Expiration date: set as needed"
        echo "  4. Scopes: select 'write_repository'"
        echo "  5. Click 'Create personal access token'"
        echo "  6. Copy the token (shown only once!)"
        echo "  7. Go to project: Settings ‚Üí CI/CD ‚Üí Variables"
        echo "  8. Add variable:"
        echo "     - Key: GIT_PUSH_TOKEN"
        echo "     - Value: <paste token>"
        echo "     - Type: Variable"
        echo "     - Flags: Masked (recommended)"
        echo ""
        echo "Option 2: Project Access Token (requires group settings)"
        echo "  NOTE: If disabled in group, enable it first:"
        echo "  - Group Settings ‚Üí General ‚Üí Permissions"
        echo "  - Enable 'Project access token creation'"
        echo ""
        echo "  Then create token:"
        echo "  1. Go to: Settings ‚Üí Access Tokens"
        echo "  2. Token name: git-push-token"
        echo "  3. Role: Maintainer or Owner"
        echo "  4. Scopes: select 'write_repository'"
        echo "  5. Create and copy token"
        echo "  6. Add as CI/CD variable: GIT_PUSH_TOKEN"
        echo "=========================================="
        exit 1
      fi
      echo "GIT_PUSH_TOKEN is set (length: ${#GIT_PUSH_TOKEN} characters)"
      git remote set-url origin "https://gitlab-ci-token:${GIT_PUSH_TOKEN}@${CI_SERVER_HOST}/${CI_PROJECT_PATH}.git"
      echo "Git remote URL configured with GIT_PUSH_TOKEN"
    - git fetch origin "$CI_COMMIT_REF_NAME" || git fetch origin "$CI_DEFAULT_BRANCH"
    - |
      # –í GitLab CI –º—ã —É–∂–µ –≤ –Ω—É–∂–Ω–æ–º –∫–æ–º–º–∏—Ç–µ, –Ω–æ –Ω—É–∂–Ω–æ –ø–µ—Ä–µ–∫–ª—é—á–∏—Ç—å—Å—è –Ω–∞ –≤–µ—Ç–∫—É –¥–ª—è –∫–æ–º–º–∏—Ç–∞
      if git show-ref --verify --quiet "refs/remotes/origin/$CI_COMMIT_REF_NAME"; then
        # –í–µ—Ç–∫–∞ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –ø–µ—Ä–µ–∫–ª—é—á–∞–µ–º—Å—è –Ω–∞ –Ω–µ—ë
        git checkout -B "$CI_COMMIT_REF_NAME" "origin/$CI_COMMIT_REF_NAME"
      else
        # –í–µ—Ç–∫–∞ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, —Å–æ–∑–¥–∞—ë–º –µ—ë –∏–∑ —Ç–µ–∫—É—â–µ–≥–æ –∫–æ–º–º–∏—Ç–∞
        echo "Branch $CI_COMMIT_REF_NAME does not exist, creating from current commit"
        git checkout -b "$CI_COMMIT_REF_NAME"
      fi
  script:
    - |
      echo "üì¶ Updating package.json versions to $VERSION"
      echo ""
      
      # –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è version –≤ package.json
      update_version() {
        local file=$1
        if [ -f "$file" ]; then
          local current_version=$(jq -r '.version // empty' "$file")
          if [ -n "$current_version" ]; then
            echo "  Updating $file: $current_version ‚Üí $VERSION"
            jq --arg version "$VERSION" '.version = $version' "$file" > "${file}.tmp" && mv "${file}.tmp" "$file"
          else
            echo "  Adding version to $file: $VERSION"
            jq --arg version "$VERSION" '. + {version: $version}' "$file" > "${file}.tmp" && mv "${file}.tmp" "$file"
          fi
        else
          echo "  ‚ö†Ô∏è  File not found: $file"
        fi
      }
      
      # –û–±–Ω–æ–≤–ª—è–µ–º –≤–µ—Ä—Å–∏–∏ –≤ package.json —Ñ–∞–π–ª–∞—Ö
      update_version "packages/portal/package.json"
      update_version "packages/contract/package.json"
      update_version "packages/backend/package.json"
      
      echo ""
      echo "üìã Checking for changes..."
      echo "Current git status:"
      git status --short || true
      
      echo ""
      echo "Checking file contents after update:"
      echo "  packages/portal/package.json version: $(jq -r '.version // "not set"' packages/portal/package.json)"
      echo "  packages/contract/package.json version: $(jq -r '.version // "not set"' packages/contract/package.json)"
      echo "  packages/backend/package.json version: $(jq -r '.version // "not set"' packages/backend/package.json)"
      echo "  Expected version: $VERSION"
      
      # –î–æ–±–∞–≤–ª—è–µ–º –∏–∑–º–µ–Ω–µ–Ω–Ω—ã–µ —Ñ–∞–π–ª—ã
      echo ""
      echo "Staging package.json files..."
      git add packages/*/package.json || true
      
      echo ""
      echo "Checking staged changes:"
      git diff --cached --stat || echo "No staged changes"
      
      echo ""
      echo "Checking unstaged changes:"
      git diff --stat || echo "No unstaged changes"
      
      # –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞–ª–∏—á–∏–µ —Ç–µ–≥–∞
      TAG_EXISTS_LOCAL=false
      TAG_EXISTS_REMOTE=false
      
      if git rev-parse "v$VERSION" >/dev/null 2>&1; then
        TAG_EXISTS_LOCAL=true
      fi
      
      if git ls-remote --exit-code --tags origin "refs/tags/v$VERSION" >/dev/null 2>&1; then
        TAG_EXISTS_REMOTE=true
      fi
      
      # –ü—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è –¥–ª—è –∫–æ–º–º–∏—Ç–∞
      if git diff --cached --quiet && git diff --quiet; then
        echo ""
        echo "‚ö†Ô∏è  No changes detected. Versions are already up to date."
        echo "This might mean versions were already updated in a previous run."
        
        # –ù–æ –ø—Ä–æ–≤–µ—Ä—è–µ–º, –Ω—É–∂–Ω–æ –ª–∏ —Å–æ–∑–¥–∞—Ç—å —Ç–µ–≥
        if [ "$TAG_EXISTS_LOCAL" = false ] && [ "$TAG_EXISTS_REMOTE" = false ]; then
          echo ""
          echo "üè∑Ô∏è  Creating git tag v$VERSION (versions are up to date, but tag is missing)..."
          git tag -a "v$VERSION" -m "Release version $VERSION"
          echo "üöÄ Pushing tag v$VERSION..."
          git push origin "v$VERSION"
          echo "  ‚úÖ Tag v$VERSION created and pushed"
        elif [ "$TAG_EXISTS_LOCAL" = false ] && [ "$TAG_EXISTS_REMOTE" = true ]; then
          echo ""
          echo "üè∑Ô∏è  Fetching tag v$VERSION from remote..."
          git fetch origin "refs/tags/v$VERSION:refs/tags/v$VERSION"
        fi
      else
        echo ""
        echo "üìù Committing version updates..."
        git commit -m "chore: bump version to $VERSION [ci skip]"
        
        echo ""
        echo "üè∑Ô∏è  Checking for git tag v$VERSION..."
        
        # –°–æ–∑–¥–∞–µ–º —Ç–µ–≥, –µ—Å–ª–∏ –µ–≥–æ –Ω–µ—Ç –Ω–∏ –ª–æ–∫–∞–ª—å–Ω–æ, –Ω–∏ –Ω–∞ remote
        if [ "$TAG_EXISTS_LOCAL" = false ] && [ "$TAG_EXISTS_REMOTE" = false ]; then
          echo "  Creating git tag v$VERSION..."
          git tag -a "v$VERSION" -m "Release version $VERSION"
          echo "  ‚úÖ Tag v$VERSION created"
        elif [ "$TAG_EXISTS_LOCAL" = false ] && [ "$TAG_EXISTS_REMOTE" = true ]; then
          # –¢–µ–≥ –µ—Å—Ç—å –Ω–∞ remote, –Ω–æ –Ω–µ –ª–æ–∫–∞–ª—å–Ω–æ - –ø–æ–ª—É—á–∞–µ–º –µ–≥–æ
          echo "  Tag v$VERSION exists on remote, fetching..."
          git fetch origin "refs/tags/v$VERSION:refs/tags/v$VERSION"
        else
          echo "  Tag v$VERSION already exists, skipping tag creation"
        fi
        
        echo ""
        echo "üöÄ Pushing changes to $CI_COMMIT_REF_NAME..."
        git push origin "$CI_COMMIT_REF_NAME"
        
        # Push —Ç–µ–≥–∞, –µ—Å–ª–∏ –æ–Ω –±—ã–ª —Å–æ–∑–¥–∞–Ω –∏–ª–∏ –æ–±–Ω–æ–≤–ª–µ–Ω –ª–æ–∫–∞–ª—å–Ω–æ
        if [ "$TAG_EXISTS_REMOTE" = false ]; then
          echo "üöÄ Pushing tag v$VERSION..."
          git push origin "v$VERSION"
          echo "  ‚úÖ Tag v$VERSION pushed to remote"
        fi
        
        echo ""
        echo "‚úÖ Version $VERSION successfully updated in package.json files, committed, and tagged"
      fi
  rules:
    # –ó–∞–ø—É—Å–∫–∞–µ–º —Ç–æ–ª—å–∫–æ –¥–ª—è –≤–µ—Ç–æ–∫ –≤–∏–¥–∞ r/X.Y.Z –∏–ª–∏ r-x.y.z
    - if: $CI_COMMIT_REF_NAME =~ /^r[\/-][0-9]+\.[0-9]+\.[0-9]+$/
  needs:
    - job: build:arch-repo-service
      artifacts: false
    - job: build:tenant-service
      artifacts: false
    - job: build:hasura-sync-service
      artifacts: false
    - job: build:portal
      artifacts: false

# ============================================
# Deploy (–∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω—ã–π stage)
# ============================================

# –ü—Ä–∏–º–µ—á–∞–Ω–∏–µ: –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –æ–±—Ä–∞–∑–æ–≤ –≤ Kubernetes –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è —á–µ—Ä–µ–∑ ArgoCD Image Updater.
# ArgoCD Image Updater –æ—Ç—Å–ª–µ–∂–∏–≤–∞–µ—Ç –Ω–æ–≤—ã–µ –æ–±—Ä–∞–∑—ã –≤ Container Registry –∏ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–±–Ω–æ–≤–ª—è–µ—Ç
# –º–∞–Ω–∏—Ñ–µ—Å—Ç—ã –≤ Git —Ä–µ–ø–æ–∑–∏—Ç–æ—Ä–∏–∏. ArgoCD –∑–∞—Ç–µ–º –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ—Ç –∏–∑–º–µ–Ω–µ–Ω–∏—è.
# 
# –°–º. –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—é: docs/ARGOCD_IMAGE_UPDATER_SETUP.md

deploy:update-images:
  stage: deploy
  image: alpine:latest
  before_script:
    - export COMMIT_SHA=$(echo $CI_COMMIT_SHA | cut -c1-8)
    # –ò–∑–≤–ª–µ–∫–∞–µ–º –≤–µ—Ä—Å–∏—é –∏–∑ –∏–º–µ–Ω–∏ –≤–µ—Ç–∫–∏ (r/X.Y.Z –∏–ª–∏ r-x.y.z)
    - |
      if echo "$CI_COMMIT_REF_NAME" | grep -qE '^r[/-][0-9]+\.[0-9]+\.[0-9]+$'; then
        VERSION=$(echo "$CI_COMMIT_REF_NAME" | sed -E 's/^r[\/-]([0-9]+\.[0-9]+\.[0-9]+)$/\1/')
        export VERSION
      else
        echo "ERROR: Branch name must match pattern r/X.Y.Z or r-x.y.z"
        exit 1
      fi
    - export REGISTRY_URL="${REGISTRY_URL:-archpad-cr.registry.twcstorage.ru}"
    - export REGISTRY_IMAGE_PREFIX="${REGISTRY_IMAGE_PREFIX:-archpad}"
  script:
    - 'echo "‚úÖ Images built and pushed successfully"'
    - 'echo ""'
    - 'echo "Built images (version $VERSION, commit $COMMIT_SHA):"'
    - 'echo "  - arch-repo-service:${VERSION}-${COMMIT_SHA} (latest)"'
    - 'echo "  - tenant-service:${VERSION}-${COMMIT_SHA} (latest)"'
    - 'echo "  - hasura-sync-service:${VERSION}-${COMMIT_SHA} (latest)"'
    - 'echo "  - portal:${VERSION}-${COMMIT_SHA} (latest)"'
    - echo ""
    - 'echo "üì¶ ArgoCD Image Updater will automatically detect new images and update Kubernetes manifests"'
    - 'echo "   See: docs/ARGOCD_IMAGE_UPDATER_SETUP.md for details"'
  rules:
    # –ó–∞–ø—É—Å–∫–∞–µ–º —Ç–æ–ª—å–∫–æ –¥–ª—è –≤–µ—Ç–æ–∫ –≤–∏–¥–∞ r/X.Y.Z –∏–ª–∏ r-x.y.z
    - if: $CI_COMMIT_REF_NAME =~ /^r[\/-][0-9]+\.[0-9]+\.[0-9]+$/
  needs:
    - job: update:versions
      artifacts: false
