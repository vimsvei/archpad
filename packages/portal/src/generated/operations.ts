export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
export type MakeEmpty<T extends { [key: string]: unknown }, K extends keyof T> = { [_ in K]?: never };
export type Incremental<T> = T | { [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: { input: string; output: string; }
  String: { input: string; output: string; }
  Boolean: { input: boolean; output: boolean; }
  Int: { input: number; output: number; }
  Float: { input: number; output: number; }
  assessment_type_enum: { input: any; output: any; }
  capability_assessment_type_enum: { input: any; output: any; }
  data_access_kind_enum: { input: any; output: any; }
  directory_kind_enum: { input: any; output: any; }
  directory_link_type_enum: { input: any; output: any; }
  environment_enum: { input: any; output: any; }
  interface_method_enum: { input: any; output: any; }
  layer_kind_enum: { input: any; output: any; }
  motivation_kind_enum: { input: any; output: any; }
  motivation_priority_enum: { input: any; output: any; }
  motivation_status_enum: { input: any; output: any; }
  network_abstraction_level_enum: { input: any; output: any; }
  network_scope_enum: { input: any; output: any; }
  node_kind_enum: { input: any; output: any; }
  risk_category_enum: { input: any; output: any; }
  risk_status_enum: { input: any; output: any; }
  smallint: { input: any; output: any; }
  solution_implementation_status_enum: { input: any; output: any; }
  solution_item_impact_type_enum: { input: any; output: any; }
  solution_life_cycle_enum: { input: any; output: any; }
  stakeholder_role_enum: { input: any; output: any; }
  system_architecture_kind_enum: { input: any; output: any; }
  system_software_kind_enum: { input: any; output: any; }
  timestamptz: { input: any; output: any; }
  uuid: { input: any; output: any; }
};

/** columns and relationships of "components" */
export type ApplicationComponent = {
  __typename?: 'ApplicationComponent';
  /** An array relationship */
  actorRole: Array<ApplicationComponentBusinessActorRoleMap>;
  /** An aggregate relationship */
  actorRole_aggregate: ApplicationComponentBusinessActorRoleMap_Aggregate;
  /** An array relationship */
  capabilities: Array<CapabilityApplicationComponentMap>;
  /** An aggregate relationship */
  capabilities_aggregate: CapabilityApplicationComponentMap_Aggregate;
  /** An array relationship */
  children: Array<ApplicationComponentHierarchyMap>;
  /** An aggregate relationship */
  children_aggregate: ApplicationComponentHierarchyMap_Aggregate;
  code: Scalars['String']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  criticalLevel?: Maybe<DirectoryObject>;
  criticalLevelId?: Maybe<Scalars['uuid']['output']>;
  /** An array relationship */
  dataObjects: Array<ApplicationComponentDataObjectMap>;
  /** An array relationship */
  dataObjectsInFunctions: Array<ApplicationFunctionDataObjectMap>;
  /** An aggregate relationship */
  dataObjectsInFunctions_aggregate: ApplicationFunctionDataObjectMap_Aggregate;
  /** An aggregate relationship */
  dataObjects_aggregate: ApplicationComponentDataObjectMap_Aggregate;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  directories: Array<ApplicationComponentDirectoryMap>;
  /** An aggregate relationship */
  directories_aggregate: ApplicationComponentDirectoryMap_Aggregate;
  /** An array relationship */
  events: Array<ApplicationComponentEventMap>;
  /** An aggregate relationship */
  events_aggregate: ApplicationComponentEventMap_Aggregate;
  /** An object relationship */
  failoverType?: Maybe<DirectoryObject>;
  failoverTypeId?: Maybe<Scalars['uuid']['output']>;
  /** An array relationship */
  functions: Array<ApplicationComponentFunctionMap>;
  /** An aggregate relationship */
  functions_aggregate: ApplicationComponentFunctionMap_Aggregate;
  id: Scalars['uuid']['output'];
  /** An array relationship */
  interfaces: Array<ApplicationComponentInterfaceMap>;
  /** An aggregate relationship */
  interfaces_aggregate: ApplicationComponentInterfaceMap_Aggregate;
  /** An object relationship */
  licenseType?: Maybe<DirectoryObject>;
  licenseTypeId?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  monitoringLevel?: Maybe<DirectoryObject>;
  monitoringLevelId?: Maybe<Scalars['uuid']['output']>;
  name: Scalars['String']['output'];
  /** An array relationship */
  networks: Array<ApplicationComponentTechnologyLogicalNetworkMap>;
  /** An aggregate relationship */
  networks_aggregate: ApplicationComponentTechnologyLogicalNetworkMap_Aggregate;
  /** An array relationship */
  nodes: Array<ApplicationComponentTechnologyNodeMap>;
  /** An aggregate relationship */
  nodes_aggregate: ApplicationComponentTechnologyNodeMap_Aggregate;
  /** An array relationship */
  parents: Array<ApplicationComponentHierarchyMap>;
  /** An aggregate relationship */
  parents_aggregate: ApplicationComponentHierarchyMap_Aggregate;
  /** An array relationship */
  products: Array<ApplicationComponentProductMap>;
  /** An aggregate relationship */
  products_aggregate: ApplicationComponentProductMap_Aggregate;
  /** An object relationship */
  recoveryTime?: Maybe<DirectoryObject>;
  recoveryTimeId?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  redundancyType?: Maybe<DirectoryObject>;
  redundancyTypeId?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  scalingType?: Maybe<DirectoryObject>;
  scalingTypeId?: Maybe<Scalars['uuid']['output']>;
  /** An array relationship */
  solutions: Array<SolutionApplicationComponentMap>;
  /** An aggregate relationship */
  solutions_aggregate: SolutionApplicationComponentMap_Aggregate;
  /** An array relationship */
  sourceComponent: Array<FlowGeneric>;
  /** An aggregate relationship */
  sourceComponent_aggregate: FlowGeneric_Aggregate;
  /** An array relationship */
  stakeholders: Array<ApplicationComponentStakeholderMap>;
  /** An aggregate relationship */
  stakeholders_aggregate: ApplicationComponentStakeholderMap_Aggregate;
  /** An object relationship */
  state?: Maybe<DirectoryObject>;
  stateId?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  style?: Maybe<DirectoryObject>;
  styleId?: Maybe<Scalars['uuid']['output']>;
  /** An array relationship */
  systemSoftware: Array<ApplicationComponentSystemSoftwareMap>;
  /** An aggregate relationship */
  systemSoftware_aggregate: ApplicationComponentSystemSoftwareMap_Aggregate;
  /** An array relationship */
  targetComponent: Array<FlowGeneric>;
  /** An aggregate relationship */
  targetComponent_aggregate: FlowGeneric_Aggregate;
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};


/** columns and relationships of "components" */
export type ApplicationComponentActorRoleArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentBusinessActorRoleMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentBusinessActorRoleMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentBusinessActorRoleMap_Bool_Exp>;
};


/** columns and relationships of "components" */
export type ApplicationComponentActorRole_AggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentBusinessActorRoleMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentBusinessActorRoleMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentBusinessActorRoleMap_Bool_Exp>;
};


/** columns and relationships of "components" */
export type ApplicationComponentCapabilitiesArgs = {
  distinct_on?: InputMaybe<Array<CapabilityApplicationComponentMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CapabilityApplicationComponentMap_Order_By>>;
  where?: InputMaybe<CapabilityApplicationComponentMap_Bool_Exp>;
};


/** columns and relationships of "components" */
export type ApplicationComponentCapabilities_AggregateArgs = {
  distinct_on?: InputMaybe<Array<CapabilityApplicationComponentMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CapabilityApplicationComponentMap_Order_By>>;
  where?: InputMaybe<CapabilityApplicationComponentMap_Bool_Exp>;
};


/** columns and relationships of "components" */
export type ApplicationComponentChildrenArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentHierarchyMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentHierarchyMap_Bool_Exp>;
};


/** columns and relationships of "components" */
export type ApplicationComponentChildren_AggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentHierarchyMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentHierarchyMap_Bool_Exp>;
};


/** columns and relationships of "components" */
export type ApplicationComponentDataObjectsArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentDataObjectMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentDataObjectMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentDataObjectMap_Bool_Exp>;
};


/** columns and relationships of "components" */
export type ApplicationComponentDataObjectsInFunctionsArgs = {
  distinct_on?: InputMaybe<Array<ApplicationFunctionDataObjectMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationFunctionDataObjectMap_Order_By>>;
  where?: InputMaybe<ApplicationFunctionDataObjectMap_Bool_Exp>;
};


/** columns and relationships of "components" */
export type ApplicationComponentDataObjectsInFunctions_AggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationFunctionDataObjectMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationFunctionDataObjectMap_Order_By>>;
  where?: InputMaybe<ApplicationFunctionDataObjectMap_Bool_Exp>;
};


/** columns and relationships of "components" */
export type ApplicationComponentDataObjects_AggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentDataObjectMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentDataObjectMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentDataObjectMap_Bool_Exp>;
};


/** columns and relationships of "components" */
export type ApplicationComponentDirectoriesArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentDirectoryMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentDirectoryMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentDirectoryMap_Bool_Exp>;
};


/** columns and relationships of "components" */
export type ApplicationComponentDirectories_AggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentDirectoryMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentDirectoryMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentDirectoryMap_Bool_Exp>;
};


/** columns and relationships of "components" */
export type ApplicationComponentEventsArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentEventMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentEventMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentEventMap_Bool_Exp>;
};


/** columns and relationships of "components" */
export type ApplicationComponentEvents_AggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentEventMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentEventMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentEventMap_Bool_Exp>;
};


/** columns and relationships of "components" */
export type ApplicationComponentFunctionsArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentFunctionMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentFunctionMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentFunctionMap_Bool_Exp>;
};


/** columns and relationships of "components" */
export type ApplicationComponentFunctions_AggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentFunctionMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentFunctionMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentFunctionMap_Bool_Exp>;
};


/** columns and relationships of "components" */
export type ApplicationComponentInterfacesArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentInterfaceMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentInterfaceMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentInterfaceMap_Bool_Exp>;
};


/** columns and relationships of "components" */
export type ApplicationComponentInterfaces_AggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentInterfaceMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentInterfaceMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentInterfaceMap_Bool_Exp>;
};


/** columns and relationships of "components" */
export type ApplicationComponentNetworksArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentTechnologyLogicalNetworkMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentTechnologyLogicalNetworkMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentTechnologyLogicalNetworkMap_Bool_Exp>;
};


/** columns and relationships of "components" */
export type ApplicationComponentNetworks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentTechnologyLogicalNetworkMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentTechnologyLogicalNetworkMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentTechnologyLogicalNetworkMap_Bool_Exp>;
};


/** columns and relationships of "components" */
export type ApplicationComponentNodesArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentTechnologyNodeMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentTechnologyNodeMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentTechnologyNodeMap_Bool_Exp>;
};


/** columns and relationships of "components" */
export type ApplicationComponentNodes_AggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentTechnologyNodeMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentTechnologyNodeMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentTechnologyNodeMap_Bool_Exp>;
};


/** columns and relationships of "components" */
export type ApplicationComponentParentsArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentHierarchyMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentHierarchyMap_Bool_Exp>;
};


/** columns and relationships of "components" */
export type ApplicationComponentParents_AggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentHierarchyMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentHierarchyMap_Bool_Exp>;
};


/** columns and relationships of "components" */
export type ApplicationComponentProductsArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentProductMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentProductMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentProductMap_Bool_Exp>;
};


/** columns and relationships of "components" */
export type ApplicationComponentProducts_AggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentProductMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentProductMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentProductMap_Bool_Exp>;
};


/** columns and relationships of "components" */
export type ApplicationComponentSolutionsArgs = {
  distinct_on?: InputMaybe<Array<SolutionApplicationComponentMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionApplicationComponentMap_Order_By>>;
  where?: InputMaybe<SolutionApplicationComponentMap_Bool_Exp>;
};


/** columns and relationships of "components" */
export type ApplicationComponentSolutions_AggregateArgs = {
  distinct_on?: InputMaybe<Array<SolutionApplicationComponentMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionApplicationComponentMap_Order_By>>;
  where?: InputMaybe<SolutionApplicationComponentMap_Bool_Exp>;
};


/** columns and relationships of "components" */
export type ApplicationComponentSourceComponentArgs = {
  distinct_on?: InputMaybe<Array<FlowGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FlowGeneric_Order_By>>;
  where?: InputMaybe<FlowGeneric_Bool_Exp>;
};


/** columns and relationships of "components" */
export type ApplicationComponentSourceComponent_AggregateArgs = {
  distinct_on?: InputMaybe<Array<FlowGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FlowGeneric_Order_By>>;
  where?: InputMaybe<FlowGeneric_Bool_Exp>;
};


/** columns and relationships of "components" */
export type ApplicationComponentStakeholdersArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentStakeholderMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentStakeholderMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentStakeholderMap_Bool_Exp>;
};


/** columns and relationships of "components" */
export type ApplicationComponentStakeholders_AggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentStakeholderMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentStakeholderMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentStakeholderMap_Bool_Exp>;
};


/** columns and relationships of "components" */
export type ApplicationComponentSystemSoftwareArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentSystemSoftwareMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentSystemSoftwareMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentSystemSoftwareMap_Bool_Exp>;
};


/** columns and relationships of "components" */
export type ApplicationComponentSystemSoftware_AggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentSystemSoftwareMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentSystemSoftwareMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentSystemSoftwareMap_Bool_Exp>;
};


/** columns and relationships of "components" */
export type ApplicationComponentTargetComponentArgs = {
  distinct_on?: InputMaybe<Array<FlowGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FlowGeneric_Order_By>>;
  where?: InputMaybe<FlowGeneric_Bool_Exp>;
};


/** columns and relationships of "components" */
export type ApplicationComponentTargetComponent_AggregateArgs = {
  distinct_on?: InputMaybe<Array<FlowGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FlowGeneric_Order_By>>;
  where?: InputMaybe<FlowGeneric_Bool_Exp>;
};

/** columns and relationships of "map_application_component_actor_role" */
export type ApplicationComponentBusinessActorRoleMap = {
  __typename?: 'ApplicationComponentBusinessActorRoleMap';
  actorId: Scalars['uuid']['output'];
  /** An object relationship */
  component: ApplicationComponent;
  componentId: Scalars['uuid']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  roleId: Scalars['uuid']['output'];
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "map_application_component_actor_role" */
export type ApplicationComponentBusinessActorRoleMap_Aggregate = {
  __typename?: 'ApplicationComponentBusinessActorRoleMap_aggregate';
  aggregate?: Maybe<ApplicationComponentBusinessActorRoleMap_Aggregate_Fields>;
  nodes: Array<ApplicationComponentBusinessActorRoleMap>;
};

export type ApplicationComponentBusinessActorRoleMap_Aggregate_Bool_Exp = {
  count?: InputMaybe<ApplicationComponentBusinessActorRoleMap_Aggregate_Bool_Exp_Count>;
};

export type ApplicationComponentBusinessActorRoleMap_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<ApplicationComponentBusinessActorRoleMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ApplicationComponentBusinessActorRoleMap_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "map_application_component_actor_role" */
export type ApplicationComponentBusinessActorRoleMap_Aggregate_Fields = {
  __typename?: 'ApplicationComponentBusinessActorRoleMap_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<ApplicationComponentBusinessActorRoleMap_Max_Fields>;
  min?: Maybe<ApplicationComponentBusinessActorRoleMap_Min_Fields>;
};


/** aggregate fields of "map_application_component_actor_role" */
export type ApplicationComponentBusinessActorRoleMap_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<ApplicationComponentBusinessActorRoleMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "map_application_component_actor_role" */
export type ApplicationComponentBusinessActorRoleMap_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<ApplicationComponentBusinessActorRoleMap_Max_Order_By>;
  min?: InputMaybe<ApplicationComponentBusinessActorRoleMap_Min_Order_By>;
};

/** input type for inserting array relation for remote table "map_application_component_actor_role" */
export type ApplicationComponentBusinessActorRoleMap_Arr_Rel_Insert_Input = {
  data: Array<ApplicationComponentBusinessActorRoleMap_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<ApplicationComponentBusinessActorRoleMap_On_Conflict>;
};

/** Boolean expression to filter rows from the table "map_application_component_actor_role". All fields are combined with a logical 'AND'. */
export type ApplicationComponentBusinessActorRoleMap_Bool_Exp = {
  _and?: InputMaybe<Array<ApplicationComponentBusinessActorRoleMap_Bool_Exp>>;
  _not?: InputMaybe<ApplicationComponentBusinessActorRoleMap_Bool_Exp>;
  _or?: InputMaybe<Array<ApplicationComponentBusinessActorRoleMap_Bool_Exp>>;
  actorId?: InputMaybe<Uuid_Comparison_Exp>;
  component?: InputMaybe<ApplicationComponent_Bool_Exp>;
  componentId?: InputMaybe<Uuid_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  roleId?: InputMaybe<Uuid_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "map_application_component_actor_role" */
export enum ApplicationComponentBusinessActorRoleMap_Constraint {
  /** unique or primary key constraint on columns "component_id", "actor_id", "role_id" */
  MapApplicationComponentActorRolePkey = 'map_application_component_actor_role_pkey'
}

/** input type for inserting data into table "map_application_component_actor_role" */
export type ApplicationComponentBusinessActorRoleMap_Insert_Input = {
  actorId?: InputMaybe<Scalars['uuid']['input']>;
  component?: InputMaybe<ApplicationComponent_Obj_Rel_Insert_Input>;
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  roleId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type ApplicationComponentBusinessActorRoleMap_Max_Fields = {
  __typename?: 'ApplicationComponentBusinessActorRoleMap_max_fields';
  actorId?: Maybe<Scalars['uuid']['output']>;
  componentId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  roleId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "map_application_component_actor_role" */
export type ApplicationComponentBusinessActorRoleMap_Max_Order_By = {
  actorId?: InputMaybe<Order_By>;
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  roleId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type ApplicationComponentBusinessActorRoleMap_Min_Fields = {
  __typename?: 'ApplicationComponentBusinessActorRoleMap_min_fields';
  actorId?: Maybe<Scalars['uuid']['output']>;
  componentId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  roleId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "map_application_component_actor_role" */
export type ApplicationComponentBusinessActorRoleMap_Min_Order_By = {
  actorId?: InputMaybe<Order_By>;
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  roleId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "map_application_component_actor_role" */
export type ApplicationComponentBusinessActorRoleMap_Mutation_Response = {
  __typename?: 'ApplicationComponentBusinessActorRoleMap_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<ApplicationComponentBusinessActorRoleMap>;
};

/** on_conflict condition type for table "map_application_component_actor_role" */
export type ApplicationComponentBusinessActorRoleMap_On_Conflict = {
  constraint: ApplicationComponentBusinessActorRoleMap_Constraint;
  update_columns?: Array<ApplicationComponentBusinessActorRoleMap_Update_Column>;
  where?: InputMaybe<ApplicationComponentBusinessActorRoleMap_Bool_Exp>;
};

/** Ordering options when selecting data from "map_application_component_actor_role". */
export type ApplicationComponentBusinessActorRoleMap_Order_By = {
  actorId?: InputMaybe<Order_By>;
  component?: InputMaybe<ApplicationComponent_Order_By>;
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  roleId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: map_application_component_actor_role */
export type ApplicationComponentBusinessActorRoleMap_Pk_Columns_Input = {
  actorId: Scalars['uuid']['input'];
  componentId: Scalars['uuid']['input'];
  roleId: Scalars['uuid']['input'];
};

/** select columns of table "map_application_component_actor_role" */
export enum ApplicationComponentBusinessActorRoleMap_Select_Column {
  /** column name */
  ActorId = 'actorId',
  /** column name */
  ComponentId = 'componentId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  RoleId = 'roleId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "map_application_component_actor_role" */
export type ApplicationComponentBusinessActorRoleMap_Set_Input = {
  actorId?: InputMaybe<Scalars['uuid']['input']>;
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  roleId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "ApplicationComponentBusinessActorRoleMap" */
export type ApplicationComponentBusinessActorRoleMap_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: ApplicationComponentBusinessActorRoleMap_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type ApplicationComponentBusinessActorRoleMap_Stream_Cursor_Value_Input = {
  actorId?: InputMaybe<Scalars['uuid']['input']>;
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  roleId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "map_application_component_actor_role" */
export enum ApplicationComponentBusinessActorRoleMap_Update_Column {
  /** column name */
  ActorId = 'actorId',
  /** column name */
  ComponentId = 'componentId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  RoleId = 'roleId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type ApplicationComponentBusinessActorRoleMap_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ApplicationComponentBusinessActorRoleMap_Set_Input>;
  /** filter the rows which have to be updated */
  where: ApplicationComponentBusinessActorRoleMap_Bool_Exp;
};

/** columns and relationships of "map_application_component_data_object" */
export type ApplicationComponentDataObjectMap = {
  __typename?: 'ApplicationComponentDataObjectMap';
  /** An object relationship */
  component: ApplicationComponent;
  componentId: Scalars['uuid']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  dataObject: DataObject;
  dataObjectId: Scalars['uuid']['output'];
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  /** An array relationship */
  requestDataObject: Array<FlowGeneric>;
  /** An aggregate relationship */
  requestDataObject_aggregate: FlowGeneric_Aggregate;
  /** An array relationship */
  responseDataObject: Array<FlowGeneric>;
  /** An aggregate relationship */
  responseDataObject_aggregate: FlowGeneric_Aggregate;
  /** An array relationship */
  solutions: Array<SolutionDataObjectMap>;
  /** An aggregate relationship */
  solutions_aggregate: SolutionDataObjectMap_Aggregate;
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};


/** columns and relationships of "map_application_component_data_object" */
export type ApplicationComponentDataObjectMapRequestDataObjectArgs = {
  distinct_on?: InputMaybe<Array<FlowGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FlowGeneric_Order_By>>;
  where?: InputMaybe<FlowGeneric_Bool_Exp>;
};


/** columns and relationships of "map_application_component_data_object" */
export type ApplicationComponentDataObjectMapRequestDataObject_AggregateArgs = {
  distinct_on?: InputMaybe<Array<FlowGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FlowGeneric_Order_By>>;
  where?: InputMaybe<FlowGeneric_Bool_Exp>;
};


/** columns and relationships of "map_application_component_data_object" */
export type ApplicationComponentDataObjectMapResponseDataObjectArgs = {
  distinct_on?: InputMaybe<Array<FlowGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FlowGeneric_Order_By>>;
  where?: InputMaybe<FlowGeneric_Bool_Exp>;
};


/** columns and relationships of "map_application_component_data_object" */
export type ApplicationComponentDataObjectMapResponseDataObject_AggregateArgs = {
  distinct_on?: InputMaybe<Array<FlowGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FlowGeneric_Order_By>>;
  where?: InputMaybe<FlowGeneric_Bool_Exp>;
};


/** columns and relationships of "map_application_component_data_object" */
export type ApplicationComponentDataObjectMapSolutionsArgs = {
  distinct_on?: InputMaybe<Array<SolutionDataObjectMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionDataObjectMap_Order_By>>;
  where?: InputMaybe<SolutionDataObjectMap_Bool_Exp>;
};


/** columns and relationships of "map_application_component_data_object" */
export type ApplicationComponentDataObjectMapSolutions_AggregateArgs = {
  distinct_on?: InputMaybe<Array<SolutionDataObjectMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionDataObjectMap_Order_By>>;
  where?: InputMaybe<SolutionDataObjectMap_Bool_Exp>;
};

/** aggregated selection of "map_application_component_data_object" */
export type ApplicationComponentDataObjectMap_Aggregate = {
  __typename?: 'ApplicationComponentDataObjectMap_aggregate';
  aggregate?: Maybe<ApplicationComponentDataObjectMap_Aggregate_Fields>;
  nodes: Array<ApplicationComponentDataObjectMap>;
};

export type ApplicationComponentDataObjectMap_Aggregate_Bool_Exp = {
  count?: InputMaybe<ApplicationComponentDataObjectMap_Aggregate_Bool_Exp_Count>;
};

export type ApplicationComponentDataObjectMap_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<ApplicationComponentDataObjectMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ApplicationComponentDataObjectMap_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "map_application_component_data_object" */
export type ApplicationComponentDataObjectMap_Aggregate_Fields = {
  __typename?: 'ApplicationComponentDataObjectMap_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<ApplicationComponentDataObjectMap_Max_Fields>;
  min?: Maybe<ApplicationComponentDataObjectMap_Min_Fields>;
};


/** aggregate fields of "map_application_component_data_object" */
export type ApplicationComponentDataObjectMap_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<ApplicationComponentDataObjectMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "map_application_component_data_object" */
export type ApplicationComponentDataObjectMap_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<ApplicationComponentDataObjectMap_Max_Order_By>;
  min?: InputMaybe<ApplicationComponentDataObjectMap_Min_Order_By>;
};

/** input type for inserting array relation for remote table "map_application_component_data_object" */
export type ApplicationComponentDataObjectMap_Arr_Rel_Insert_Input = {
  data: Array<ApplicationComponentDataObjectMap_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<ApplicationComponentDataObjectMap_On_Conflict>;
};

/** Boolean expression to filter rows from the table "map_application_component_data_object". All fields are combined with a logical 'AND'. */
export type ApplicationComponentDataObjectMap_Bool_Exp = {
  _and?: InputMaybe<Array<ApplicationComponentDataObjectMap_Bool_Exp>>;
  _not?: InputMaybe<ApplicationComponentDataObjectMap_Bool_Exp>;
  _or?: InputMaybe<Array<ApplicationComponentDataObjectMap_Bool_Exp>>;
  component?: InputMaybe<ApplicationComponent_Bool_Exp>;
  componentId?: InputMaybe<Uuid_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  dataObject?: InputMaybe<DataObject_Bool_Exp>;
  dataObjectId?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  requestDataObject?: InputMaybe<FlowGeneric_Bool_Exp>;
  requestDataObject_aggregate?: InputMaybe<FlowGeneric_Aggregate_Bool_Exp>;
  responseDataObject?: InputMaybe<FlowGeneric_Bool_Exp>;
  responseDataObject_aggregate?: InputMaybe<FlowGeneric_Aggregate_Bool_Exp>;
  solutions?: InputMaybe<SolutionDataObjectMap_Bool_Exp>;
  solutions_aggregate?: InputMaybe<SolutionDataObjectMap_Aggregate_Bool_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "map_application_component_data_object" */
export enum ApplicationComponentDataObjectMap_Constraint {
  /** unique or primary key constraint on columns "data_object_id", "component_id" */
  MapApplicationComponentDataObjectPkey = 'map_application_component_data_object_pkey'
}

/** input type for inserting data into table "map_application_component_data_object" */
export type ApplicationComponentDataObjectMap_Insert_Input = {
  component?: InputMaybe<ApplicationComponent_Obj_Rel_Insert_Input>;
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  dataObject?: InputMaybe<DataObject_Obj_Rel_Insert_Input>;
  dataObjectId?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  requestDataObject?: InputMaybe<FlowGeneric_Arr_Rel_Insert_Input>;
  responseDataObject?: InputMaybe<FlowGeneric_Arr_Rel_Insert_Input>;
  solutions?: InputMaybe<SolutionDataObjectMap_Arr_Rel_Insert_Input>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type ApplicationComponentDataObjectMap_Max_Fields = {
  __typename?: 'ApplicationComponentDataObjectMap_max_fields';
  componentId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  dataObjectId?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "map_application_component_data_object" */
export type ApplicationComponentDataObjectMap_Max_Order_By = {
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  dataObjectId?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type ApplicationComponentDataObjectMap_Min_Fields = {
  __typename?: 'ApplicationComponentDataObjectMap_min_fields';
  componentId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  dataObjectId?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "map_application_component_data_object" */
export type ApplicationComponentDataObjectMap_Min_Order_By = {
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  dataObjectId?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "map_application_component_data_object" */
export type ApplicationComponentDataObjectMap_Mutation_Response = {
  __typename?: 'ApplicationComponentDataObjectMap_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<ApplicationComponentDataObjectMap>;
};

/** on_conflict condition type for table "map_application_component_data_object" */
export type ApplicationComponentDataObjectMap_On_Conflict = {
  constraint: ApplicationComponentDataObjectMap_Constraint;
  update_columns?: Array<ApplicationComponentDataObjectMap_Update_Column>;
  where?: InputMaybe<ApplicationComponentDataObjectMap_Bool_Exp>;
};

/** Ordering options when selecting data from "map_application_component_data_object". */
export type ApplicationComponentDataObjectMap_Order_By = {
  component?: InputMaybe<ApplicationComponent_Order_By>;
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  dataObject?: InputMaybe<DataObject_Order_By>;
  dataObjectId?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  requestDataObject_aggregate?: InputMaybe<FlowGeneric_Aggregate_Order_By>;
  responseDataObject_aggregate?: InputMaybe<FlowGeneric_Aggregate_Order_By>;
  solutions_aggregate?: InputMaybe<SolutionDataObjectMap_Aggregate_Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: map_application_component_data_object */
export type ApplicationComponentDataObjectMap_Pk_Columns_Input = {
  componentId: Scalars['uuid']['input'];
  dataObjectId: Scalars['uuid']['input'];
};

/** select columns of table "map_application_component_data_object" */
export enum ApplicationComponentDataObjectMap_Select_Column {
  /** column name */
  ComponentId = 'componentId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DataObjectId = 'dataObjectId',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "map_application_component_data_object" */
export type ApplicationComponentDataObjectMap_Set_Input = {
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  dataObjectId?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "ApplicationComponentDataObjectMap" */
export type ApplicationComponentDataObjectMap_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: ApplicationComponentDataObjectMap_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type ApplicationComponentDataObjectMap_Stream_Cursor_Value_Input = {
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  dataObjectId?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "map_application_component_data_object" */
export enum ApplicationComponentDataObjectMap_Update_Column {
  /** column name */
  ComponentId = 'componentId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DataObjectId = 'dataObjectId',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type ApplicationComponentDataObjectMap_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ApplicationComponentDataObjectMap_Set_Input>;
  /** filter the rows which have to be updated */
  where: ApplicationComponentDataObjectMap_Bool_Exp;
};

/** columns and relationships of "map_application_component_directory" */
export type ApplicationComponentDirectoryMap = {
  __typename?: 'ApplicationComponentDirectoryMap';
  /** An object relationship */
  component: ApplicationComponent;
  componentId: Scalars['uuid']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  directory: DirectoryObject;
  directoryId: Scalars['uuid']['output'];
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "map_application_component_directory" */
export type ApplicationComponentDirectoryMap_Aggregate = {
  __typename?: 'ApplicationComponentDirectoryMap_aggregate';
  aggregate?: Maybe<ApplicationComponentDirectoryMap_Aggregate_Fields>;
  nodes: Array<ApplicationComponentDirectoryMap>;
};

export type ApplicationComponentDirectoryMap_Aggregate_Bool_Exp = {
  count?: InputMaybe<ApplicationComponentDirectoryMap_Aggregate_Bool_Exp_Count>;
};

export type ApplicationComponentDirectoryMap_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<ApplicationComponentDirectoryMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ApplicationComponentDirectoryMap_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "map_application_component_directory" */
export type ApplicationComponentDirectoryMap_Aggregate_Fields = {
  __typename?: 'ApplicationComponentDirectoryMap_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<ApplicationComponentDirectoryMap_Max_Fields>;
  min?: Maybe<ApplicationComponentDirectoryMap_Min_Fields>;
};


/** aggregate fields of "map_application_component_directory" */
export type ApplicationComponentDirectoryMap_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<ApplicationComponentDirectoryMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "map_application_component_directory" */
export type ApplicationComponentDirectoryMap_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<ApplicationComponentDirectoryMap_Max_Order_By>;
  min?: InputMaybe<ApplicationComponentDirectoryMap_Min_Order_By>;
};

/** input type for inserting array relation for remote table "map_application_component_directory" */
export type ApplicationComponentDirectoryMap_Arr_Rel_Insert_Input = {
  data: Array<ApplicationComponentDirectoryMap_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<ApplicationComponentDirectoryMap_On_Conflict>;
};

/** Boolean expression to filter rows from the table "map_application_component_directory". All fields are combined with a logical 'AND'. */
export type ApplicationComponentDirectoryMap_Bool_Exp = {
  _and?: InputMaybe<Array<ApplicationComponentDirectoryMap_Bool_Exp>>;
  _not?: InputMaybe<ApplicationComponentDirectoryMap_Bool_Exp>;
  _or?: InputMaybe<Array<ApplicationComponentDirectoryMap_Bool_Exp>>;
  component?: InputMaybe<ApplicationComponent_Bool_Exp>;
  componentId?: InputMaybe<Uuid_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  directory?: InputMaybe<DirectoryObject_Bool_Exp>;
  directoryId?: InputMaybe<Uuid_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "map_application_component_directory" */
export enum ApplicationComponentDirectoryMap_Constraint {
  /** unique or primary key constraint on columns "component_id", "directory_id" */
  MapApplicationComponentDirectoryPkey = 'map_application_component_directory_pkey'
}

/** input type for inserting data into table "map_application_component_directory" */
export type ApplicationComponentDirectoryMap_Insert_Input = {
  component?: InputMaybe<ApplicationComponent_Obj_Rel_Insert_Input>;
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  directory?: InputMaybe<DirectoryObject_Obj_Rel_Insert_Input>;
  directoryId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type ApplicationComponentDirectoryMap_Max_Fields = {
  __typename?: 'ApplicationComponentDirectoryMap_max_fields';
  componentId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  directoryId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "map_application_component_directory" */
export type ApplicationComponentDirectoryMap_Max_Order_By = {
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  directoryId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type ApplicationComponentDirectoryMap_Min_Fields = {
  __typename?: 'ApplicationComponentDirectoryMap_min_fields';
  componentId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  directoryId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "map_application_component_directory" */
export type ApplicationComponentDirectoryMap_Min_Order_By = {
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  directoryId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "map_application_component_directory" */
export type ApplicationComponentDirectoryMap_Mutation_Response = {
  __typename?: 'ApplicationComponentDirectoryMap_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<ApplicationComponentDirectoryMap>;
};

/** on_conflict condition type for table "map_application_component_directory" */
export type ApplicationComponentDirectoryMap_On_Conflict = {
  constraint: ApplicationComponentDirectoryMap_Constraint;
  update_columns?: Array<ApplicationComponentDirectoryMap_Update_Column>;
  where?: InputMaybe<ApplicationComponentDirectoryMap_Bool_Exp>;
};

/** Ordering options when selecting data from "map_application_component_directory". */
export type ApplicationComponentDirectoryMap_Order_By = {
  component?: InputMaybe<ApplicationComponent_Order_By>;
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  directory?: InputMaybe<DirectoryObject_Order_By>;
  directoryId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: map_application_component_directory */
export type ApplicationComponentDirectoryMap_Pk_Columns_Input = {
  componentId: Scalars['uuid']['input'];
  directoryId: Scalars['uuid']['input'];
};

/** select columns of table "map_application_component_directory" */
export enum ApplicationComponentDirectoryMap_Select_Column {
  /** column name */
  ComponentId = 'componentId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  DirectoryId = 'directoryId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "map_application_component_directory" */
export type ApplicationComponentDirectoryMap_Set_Input = {
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  directoryId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "ApplicationComponentDirectoryMap" */
export type ApplicationComponentDirectoryMap_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: ApplicationComponentDirectoryMap_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type ApplicationComponentDirectoryMap_Stream_Cursor_Value_Input = {
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  directoryId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "map_application_component_directory" */
export enum ApplicationComponentDirectoryMap_Update_Column {
  /** column name */
  ComponentId = 'componentId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  DirectoryId = 'directoryId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type ApplicationComponentDirectoryMap_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ApplicationComponentDirectoryMap_Set_Input>;
  /** filter the rows which have to be updated */
  where: ApplicationComponentDirectoryMap_Bool_Exp;
};

/** columns and relationships of "map_application_component_event" */
export type ApplicationComponentEventMap = {
  __typename?: 'ApplicationComponentEventMap';
  /** An object relationship */
  component: ApplicationComponent;
  componentId: Scalars['uuid']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  event: EventGeneric;
  eventId: Scalars['uuid']['output'];
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "map_application_component_event" */
export type ApplicationComponentEventMap_Aggregate = {
  __typename?: 'ApplicationComponentEventMap_aggregate';
  aggregate?: Maybe<ApplicationComponentEventMap_Aggregate_Fields>;
  nodes: Array<ApplicationComponentEventMap>;
};

export type ApplicationComponentEventMap_Aggregate_Bool_Exp = {
  count?: InputMaybe<ApplicationComponentEventMap_Aggregate_Bool_Exp_Count>;
};

export type ApplicationComponentEventMap_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<ApplicationComponentEventMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ApplicationComponentEventMap_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "map_application_component_event" */
export type ApplicationComponentEventMap_Aggregate_Fields = {
  __typename?: 'ApplicationComponentEventMap_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<ApplicationComponentEventMap_Max_Fields>;
  min?: Maybe<ApplicationComponentEventMap_Min_Fields>;
};


/** aggregate fields of "map_application_component_event" */
export type ApplicationComponentEventMap_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<ApplicationComponentEventMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "map_application_component_event" */
export type ApplicationComponentEventMap_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<ApplicationComponentEventMap_Max_Order_By>;
  min?: InputMaybe<ApplicationComponentEventMap_Min_Order_By>;
};

/** input type for inserting array relation for remote table "map_application_component_event" */
export type ApplicationComponentEventMap_Arr_Rel_Insert_Input = {
  data: Array<ApplicationComponentEventMap_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<ApplicationComponentEventMap_On_Conflict>;
};

/** Boolean expression to filter rows from the table "map_application_component_event". All fields are combined with a logical 'AND'. */
export type ApplicationComponentEventMap_Bool_Exp = {
  _and?: InputMaybe<Array<ApplicationComponentEventMap_Bool_Exp>>;
  _not?: InputMaybe<ApplicationComponentEventMap_Bool_Exp>;
  _or?: InputMaybe<Array<ApplicationComponentEventMap_Bool_Exp>>;
  component?: InputMaybe<ApplicationComponent_Bool_Exp>;
  componentId?: InputMaybe<Uuid_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  event?: InputMaybe<EventGeneric_Bool_Exp>;
  eventId?: InputMaybe<Uuid_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "map_application_component_event" */
export enum ApplicationComponentEventMap_Constraint {
  /** unique or primary key constraint on columns "component_id", "event_id" */
  MapApplicationComponentEventPkey = 'map_application_component_event_pkey'
}

/** input type for inserting data into table "map_application_component_event" */
export type ApplicationComponentEventMap_Insert_Input = {
  component?: InputMaybe<ApplicationComponent_Obj_Rel_Insert_Input>;
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  event?: InputMaybe<EventGeneric_Obj_Rel_Insert_Input>;
  eventId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type ApplicationComponentEventMap_Max_Fields = {
  __typename?: 'ApplicationComponentEventMap_max_fields';
  componentId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  eventId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "map_application_component_event" */
export type ApplicationComponentEventMap_Max_Order_By = {
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  eventId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type ApplicationComponentEventMap_Min_Fields = {
  __typename?: 'ApplicationComponentEventMap_min_fields';
  componentId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  eventId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "map_application_component_event" */
export type ApplicationComponentEventMap_Min_Order_By = {
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  eventId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "map_application_component_event" */
export type ApplicationComponentEventMap_Mutation_Response = {
  __typename?: 'ApplicationComponentEventMap_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<ApplicationComponentEventMap>;
};

/** on_conflict condition type for table "map_application_component_event" */
export type ApplicationComponentEventMap_On_Conflict = {
  constraint: ApplicationComponentEventMap_Constraint;
  update_columns?: Array<ApplicationComponentEventMap_Update_Column>;
  where?: InputMaybe<ApplicationComponentEventMap_Bool_Exp>;
};

/** Ordering options when selecting data from "map_application_component_event". */
export type ApplicationComponentEventMap_Order_By = {
  component?: InputMaybe<ApplicationComponent_Order_By>;
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  event?: InputMaybe<EventGeneric_Order_By>;
  eventId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: map_application_component_event */
export type ApplicationComponentEventMap_Pk_Columns_Input = {
  componentId: Scalars['uuid']['input'];
  eventId: Scalars['uuid']['input'];
};

/** select columns of table "map_application_component_event" */
export enum ApplicationComponentEventMap_Select_Column {
  /** column name */
  ComponentId = 'componentId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  EventId = 'eventId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "map_application_component_event" */
export type ApplicationComponentEventMap_Set_Input = {
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  eventId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "ApplicationComponentEventMap" */
export type ApplicationComponentEventMap_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: ApplicationComponentEventMap_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type ApplicationComponentEventMap_Stream_Cursor_Value_Input = {
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  eventId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "map_application_component_event" */
export enum ApplicationComponentEventMap_Update_Column {
  /** column name */
  ComponentId = 'componentId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  EventId = 'eventId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type ApplicationComponentEventMap_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ApplicationComponentEventMap_Set_Input>;
  /** filter the rows which have to be updated */
  where: ApplicationComponentEventMap_Bool_Exp;
};

/** columns and relationships of "map_application_component_function" */
export type ApplicationComponentFunctionMap = {
  __typename?: 'ApplicationComponentFunctionMap';
  /** An object relationship */
  component: ApplicationComponent;
  componentId: Scalars['uuid']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  function: FunctionGeneric;
  /** An array relationship */
  functionComponent: Array<SolutionApplicationFunctionMap>;
  /** An aggregate relationship */
  functionComponent_aggregate: SolutionApplicationFunctionMap_Aggregate;
  functionId: Scalars['uuid']['output'];
  /** An array relationship */
  interfaces: Array<ApplicationFunctionInterfaceMap>;
  /** An aggregate relationship */
  interfaces_aggregate: ApplicationFunctionInterfaceMap_Aggregate;
  /** An array relationship */
  sourceFunction: Array<FlowGeneric>;
  /** An aggregate relationship */
  sourceFunction_aggregate: FlowGeneric_Aggregate;
  /** An array relationship */
  targetFunction: Array<FlowGeneric>;
  /** An aggregate relationship */
  targetFunction_aggregate: FlowGeneric_Aggregate;
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};


/** columns and relationships of "map_application_component_function" */
export type ApplicationComponentFunctionMapFunctionComponentArgs = {
  distinct_on?: InputMaybe<Array<SolutionApplicationFunctionMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionApplicationFunctionMap_Order_By>>;
  where?: InputMaybe<SolutionApplicationFunctionMap_Bool_Exp>;
};


/** columns and relationships of "map_application_component_function" */
export type ApplicationComponentFunctionMapFunctionComponent_AggregateArgs = {
  distinct_on?: InputMaybe<Array<SolutionApplicationFunctionMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionApplicationFunctionMap_Order_By>>;
  where?: InputMaybe<SolutionApplicationFunctionMap_Bool_Exp>;
};


/** columns and relationships of "map_application_component_function" */
export type ApplicationComponentFunctionMapInterfacesArgs = {
  distinct_on?: InputMaybe<Array<ApplicationFunctionInterfaceMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationFunctionInterfaceMap_Order_By>>;
  where?: InputMaybe<ApplicationFunctionInterfaceMap_Bool_Exp>;
};


/** columns and relationships of "map_application_component_function" */
export type ApplicationComponentFunctionMapInterfaces_AggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationFunctionInterfaceMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationFunctionInterfaceMap_Order_By>>;
  where?: InputMaybe<ApplicationFunctionInterfaceMap_Bool_Exp>;
};


/** columns and relationships of "map_application_component_function" */
export type ApplicationComponentFunctionMapSourceFunctionArgs = {
  distinct_on?: InputMaybe<Array<FlowGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FlowGeneric_Order_By>>;
  where?: InputMaybe<FlowGeneric_Bool_Exp>;
};


/** columns and relationships of "map_application_component_function" */
export type ApplicationComponentFunctionMapSourceFunction_AggregateArgs = {
  distinct_on?: InputMaybe<Array<FlowGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FlowGeneric_Order_By>>;
  where?: InputMaybe<FlowGeneric_Bool_Exp>;
};


/** columns and relationships of "map_application_component_function" */
export type ApplicationComponentFunctionMapTargetFunctionArgs = {
  distinct_on?: InputMaybe<Array<FlowGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FlowGeneric_Order_By>>;
  where?: InputMaybe<FlowGeneric_Bool_Exp>;
};


/** columns and relationships of "map_application_component_function" */
export type ApplicationComponentFunctionMapTargetFunction_AggregateArgs = {
  distinct_on?: InputMaybe<Array<FlowGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FlowGeneric_Order_By>>;
  where?: InputMaybe<FlowGeneric_Bool_Exp>;
};

/** aggregated selection of "map_application_component_function" */
export type ApplicationComponentFunctionMap_Aggregate = {
  __typename?: 'ApplicationComponentFunctionMap_aggregate';
  aggregate?: Maybe<ApplicationComponentFunctionMap_Aggregate_Fields>;
  nodes: Array<ApplicationComponentFunctionMap>;
};

export type ApplicationComponentFunctionMap_Aggregate_Bool_Exp = {
  count?: InputMaybe<ApplicationComponentFunctionMap_Aggregate_Bool_Exp_Count>;
};

export type ApplicationComponentFunctionMap_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<ApplicationComponentFunctionMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ApplicationComponentFunctionMap_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "map_application_component_function" */
export type ApplicationComponentFunctionMap_Aggregate_Fields = {
  __typename?: 'ApplicationComponentFunctionMap_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<ApplicationComponentFunctionMap_Max_Fields>;
  min?: Maybe<ApplicationComponentFunctionMap_Min_Fields>;
};


/** aggregate fields of "map_application_component_function" */
export type ApplicationComponentFunctionMap_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<ApplicationComponentFunctionMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "map_application_component_function" */
export type ApplicationComponentFunctionMap_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<ApplicationComponentFunctionMap_Max_Order_By>;
  min?: InputMaybe<ApplicationComponentFunctionMap_Min_Order_By>;
};

/** input type for inserting array relation for remote table "map_application_component_function" */
export type ApplicationComponentFunctionMap_Arr_Rel_Insert_Input = {
  data: Array<ApplicationComponentFunctionMap_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<ApplicationComponentFunctionMap_On_Conflict>;
};

/** Boolean expression to filter rows from the table "map_application_component_function". All fields are combined with a logical 'AND'. */
export type ApplicationComponentFunctionMap_Bool_Exp = {
  _and?: InputMaybe<Array<ApplicationComponentFunctionMap_Bool_Exp>>;
  _not?: InputMaybe<ApplicationComponentFunctionMap_Bool_Exp>;
  _or?: InputMaybe<Array<ApplicationComponentFunctionMap_Bool_Exp>>;
  component?: InputMaybe<ApplicationComponent_Bool_Exp>;
  componentId?: InputMaybe<Uuid_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  function?: InputMaybe<FunctionGeneric_Bool_Exp>;
  functionComponent?: InputMaybe<SolutionApplicationFunctionMap_Bool_Exp>;
  functionComponent_aggregate?: InputMaybe<SolutionApplicationFunctionMap_Aggregate_Bool_Exp>;
  functionId?: InputMaybe<Uuid_Comparison_Exp>;
  interfaces?: InputMaybe<ApplicationFunctionInterfaceMap_Bool_Exp>;
  interfaces_aggregate?: InputMaybe<ApplicationFunctionInterfaceMap_Aggregate_Bool_Exp>;
  sourceFunction?: InputMaybe<FlowGeneric_Bool_Exp>;
  sourceFunction_aggregate?: InputMaybe<FlowGeneric_Aggregate_Bool_Exp>;
  targetFunction?: InputMaybe<FlowGeneric_Bool_Exp>;
  targetFunction_aggregate?: InputMaybe<FlowGeneric_Aggregate_Bool_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "map_application_component_function" */
export enum ApplicationComponentFunctionMap_Constraint {
  /** unique or primary key constraint on columns "component_id", "function_id" */
  MapApplicationComponentFunctionPkey = 'map_application_component_function_pkey'
}

/** input type for inserting data into table "map_application_component_function" */
export type ApplicationComponentFunctionMap_Insert_Input = {
  component?: InputMaybe<ApplicationComponent_Obj_Rel_Insert_Input>;
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  function?: InputMaybe<FunctionGeneric_Obj_Rel_Insert_Input>;
  functionComponent?: InputMaybe<SolutionApplicationFunctionMap_Arr_Rel_Insert_Input>;
  functionId?: InputMaybe<Scalars['uuid']['input']>;
  interfaces?: InputMaybe<ApplicationFunctionInterfaceMap_Arr_Rel_Insert_Input>;
  sourceFunction?: InputMaybe<FlowGeneric_Arr_Rel_Insert_Input>;
  targetFunction?: InputMaybe<FlowGeneric_Arr_Rel_Insert_Input>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type ApplicationComponentFunctionMap_Max_Fields = {
  __typename?: 'ApplicationComponentFunctionMap_max_fields';
  componentId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  functionId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "map_application_component_function" */
export type ApplicationComponentFunctionMap_Max_Order_By = {
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  functionId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type ApplicationComponentFunctionMap_Min_Fields = {
  __typename?: 'ApplicationComponentFunctionMap_min_fields';
  componentId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  functionId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "map_application_component_function" */
export type ApplicationComponentFunctionMap_Min_Order_By = {
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  functionId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "map_application_component_function" */
export type ApplicationComponentFunctionMap_Mutation_Response = {
  __typename?: 'ApplicationComponentFunctionMap_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<ApplicationComponentFunctionMap>;
};

/** on_conflict condition type for table "map_application_component_function" */
export type ApplicationComponentFunctionMap_On_Conflict = {
  constraint: ApplicationComponentFunctionMap_Constraint;
  update_columns?: Array<ApplicationComponentFunctionMap_Update_Column>;
  where?: InputMaybe<ApplicationComponentFunctionMap_Bool_Exp>;
};

/** Ordering options when selecting data from "map_application_component_function". */
export type ApplicationComponentFunctionMap_Order_By = {
  component?: InputMaybe<ApplicationComponent_Order_By>;
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  function?: InputMaybe<FunctionGeneric_Order_By>;
  functionComponent_aggregate?: InputMaybe<SolutionApplicationFunctionMap_Aggregate_Order_By>;
  functionId?: InputMaybe<Order_By>;
  interfaces_aggregate?: InputMaybe<ApplicationFunctionInterfaceMap_Aggregate_Order_By>;
  sourceFunction_aggregate?: InputMaybe<FlowGeneric_Aggregate_Order_By>;
  targetFunction_aggregate?: InputMaybe<FlowGeneric_Aggregate_Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: map_application_component_function */
export type ApplicationComponentFunctionMap_Pk_Columns_Input = {
  componentId: Scalars['uuid']['input'];
  functionId: Scalars['uuid']['input'];
};

/** select columns of table "map_application_component_function" */
export enum ApplicationComponentFunctionMap_Select_Column {
  /** column name */
  ComponentId = 'componentId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  FunctionId = 'functionId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "map_application_component_function" */
export type ApplicationComponentFunctionMap_Set_Input = {
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  functionId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "ApplicationComponentFunctionMap" */
export type ApplicationComponentFunctionMap_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: ApplicationComponentFunctionMap_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type ApplicationComponentFunctionMap_Stream_Cursor_Value_Input = {
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  functionId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "map_application_component_function" */
export enum ApplicationComponentFunctionMap_Update_Column {
  /** column name */
  ComponentId = 'componentId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  FunctionId = 'functionId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type ApplicationComponentFunctionMap_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ApplicationComponentFunctionMap_Set_Input>;
  /** filter the rows which have to be updated */
  where: ApplicationComponentFunctionMap_Bool_Exp;
};

/** columns and relationships of "map_application_component_hierarchy" */
export type ApplicationComponentHierarchyMap = {
  __typename?: 'ApplicationComponentHierarchyMap';
  /** An object relationship */
  componentChild: ApplicationComponent;
  componentChildId: Scalars['uuid']['output'];
  /** An object relationship */
  componentParent: ApplicationComponent;
  componentParentId: Scalars['uuid']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  order?: Maybe<Scalars['Int']['output']>;
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "map_application_component_hierarchy" */
export type ApplicationComponentHierarchyMap_Aggregate = {
  __typename?: 'ApplicationComponentHierarchyMap_aggregate';
  aggregate?: Maybe<ApplicationComponentHierarchyMap_Aggregate_Fields>;
  nodes: Array<ApplicationComponentHierarchyMap>;
};

export type ApplicationComponentHierarchyMap_Aggregate_Bool_Exp = {
  count?: InputMaybe<ApplicationComponentHierarchyMap_Aggregate_Bool_Exp_Count>;
};

export type ApplicationComponentHierarchyMap_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<ApplicationComponentHierarchyMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ApplicationComponentHierarchyMap_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "map_application_component_hierarchy" */
export type ApplicationComponentHierarchyMap_Aggregate_Fields = {
  __typename?: 'ApplicationComponentHierarchyMap_aggregate_fields';
  avg?: Maybe<ApplicationComponentHierarchyMap_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<ApplicationComponentHierarchyMap_Max_Fields>;
  min?: Maybe<ApplicationComponentHierarchyMap_Min_Fields>;
  stddev?: Maybe<ApplicationComponentHierarchyMap_Stddev_Fields>;
  stddev_pop?: Maybe<ApplicationComponentHierarchyMap_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<ApplicationComponentHierarchyMap_Stddev_Samp_Fields>;
  sum?: Maybe<ApplicationComponentHierarchyMap_Sum_Fields>;
  var_pop?: Maybe<ApplicationComponentHierarchyMap_Var_Pop_Fields>;
  var_samp?: Maybe<ApplicationComponentHierarchyMap_Var_Samp_Fields>;
  variance?: Maybe<ApplicationComponentHierarchyMap_Variance_Fields>;
};


/** aggregate fields of "map_application_component_hierarchy" */
export type ApplicationComponentHierarchyMap_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<ApplicationComponentHierarchyMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "map_application_component_hierarchy" */
export type ApplicationComponentHierarchyMap_Aggregate_Order_By = {
  avg?: InputMaybe<ApplicationComponentHierarchyMap_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<ApplicationComponentHierarchyMap_Max_Order_By>;
  min?: InputMaybe<ApplicationComponentHierarchyMap_Min_Order_By>;
  stddev?: InputMaybe<ApplicationComponentHierarchyMap_Stddev_Order_By>;
  stddev_pop?: InputMaybe<ApplicationComponentHierarchyMap_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<ApplicationComponentHierarchyMap_Stddev_Samp_Order_By>;
  sum?: InputMaybe<ApplicationComponentHierarchyMap_Sum_Order_By>;
  var_pop?: InputMaybe<ApplicationComponentHierarchyMap_Var_Pop_Order_By>;
  var_samp?: InputMaybe<ApplicationComponentHierarchyMap_Var_Samp_Order_By>;
  variance?: InputMaybe<ApplicationComponentHierarchyMap_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "map_application_component_hierarchy" */
export type ApplicationComponentHierarchyMap_Arr_Rel_Insert_Input = {
  data: Array<ApplicationComponentHierarchyMap_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<ApplicationComponentHierarchyMap_On_Conflict>;
};

/** aggregate avg on columns */
export type ApplicationComponentHierarchyMap_Avg_Fields = {
  __typename?: 'ApplicationComponentHierarchyMap_avg_fields';
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "map_application_component_hierarchy" */
export type ApplicationComponentHierarchyMap_Avg_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "map_application_component_hierarchy". All fields are combined with a logical 'AND'. */
export type ApplicationComponentHierarchyMap_Bool_Exp = {
  _and?: InputMaybe<Array<ApplicationComponentHierarchyMap_Bool_Exp>>;
  _not?: InputMaybe<ApplicationComponentHierarchyMap_Bool_Exp>;
  _or?: InputMaybe<Array<ApplicationComponentHierarchyMap_Bool_Exp>>;
  componentChild?: InputMaybe<ApplicationComponent_Bool_Exp>;
  componentChildId?: InputMaybe<Uuid_Comparison_Exp>;
  componentParent?: InputMaybe<ApplicationComponent_Bool_Exp>;
  componentParentId?: InputMaybe<Uuid_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  order?: InputMaybe<Int_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "map_application_component_hierarchy" */
export enum ApplicationComponentHierarchyMap_Constraint {
  /** unique or primary key constraint on columns "component_child_id", "component_parent_id" */
  MapApplicationComponentHierarchyPkey = 'map_application_component_hierarchy_pkey'
}

/** input type for incrementing numeric columns in table "map_application_component_hierarchy" */
export type ApplicationComponentHierarchyMap_Inc_Input = {
  order?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "map_application_component_hierarchy" */
export type ApplicationComponentHierarchyMap_Insert_Input = {
  componentChild?: InputMaybe<ApplicationComponent_Obj_Rel_Insert_Input>;
  componentChildId?: InputMaybe<Scalars['uuid']['input']>;
  componentParent?: InputMaybe<ApplicationComponent_Obj_Rel_Insert_Input>;
  componentParentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type ApplicationComponentHierarchyMap_Max_Fields = {
  __typename?: 'ApplicationComponentHierarchyMap_max_fields';
  componentChildId?: Maybe<Scalars['uuid']['output']>;
  componentParentId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  order?: Maybe<Scalars['Int']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "map_application_component_hierarchy" */
export type ApplicationComponentHierarchyMap_Max_Order_By = {
  componentChildId?: InputMaybe<Order_By>;
  componentParentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  order?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type ApplicationComponentHierarchyMap_Min_Fields = {
  __typename?: 'ApplicationComponentHierarchyMap_min_fields';
  componentChildId?: Maybe<Scalars['uuid']['output']>;
  componentParentId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  order?: Maybe<Scalars['Int']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "map_application_component_hierarchy" */
export type ApplicationComponentHierarchyMap_Min_Order_By = {
  componentChildId?: InputMaybe<Order_By>;
  componentParentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  order?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "map_application_component_hierarchy" */
export type ApplicationComponentHierarchyMap_Mutation_Response = {
  __typename?: 'ApplicationComponentHierarchyMap_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<ApplicationComponentHierarchyMap>;
};

/** on_conflict condition type for table "map_application_component_hierarchy" */
export type ApplicationComponentHierarchyMap_On_Conflict = {
  constraint: ApplicationComponentHierarchyMap_Constraint;
  update_columns?: Array<ApplicationComponentHierarchyMap_Update_Column>;
  where?: InputMaybe<ApplicationComponentHierarchyMap_Bool_Exp>;
};

/** Ordering options when selecting data from "map_application_component_hierarchy". */
export type ApplicationComponentHierarchyMap_Order_By = {
  componentChild?: InputMaybe<ApplicationComponent_Order_By>;
  componentChildId?: InputMaybe<Order_By>;
  componentParent?: InputMaybe<ApplicationComponent_Order_By>;
  componentParentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  order?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: map_application_component_hierarchy */
export type ApplicationComponentHierarchyMap_Pk_Columns_Input = {
  componentChildId: Scalars['uuid']['input'];
  componentParentId: Scalars['uuid']['input'];
};

/** select columns of table "map_application_component_hierarchy" */
export enum ApplicationComponentHierarchyMap_Select_Column {
  /** column name */
  ComponentChildId = 'componentChildId',
  /** column name */
  ComponentParentId = 'componentParentId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Order = 'order',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "map_application_component_hierarchy" */
export type ApplicationComponentHierarchyMap_Set_Input = {
  componentChildId?: InputMaybe<Scalars['uuid']['input']>;
  componentParentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type ApplicationComponentHierarchyMap_Stddev_Fields = {
  __typename?: 'ApplicationComponentHierarchyMap_stddev_fields';
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "map_application_component_hierarchy" */
export type ApplicationComponentHierarchyMap_Stddev_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type ApplicationComponentHierarchyMap_Stddev_Pop_Fields = {
  __typename?: 'ApplicationComponentHierarchyMap_stddev_pop_fields';
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "map_application_component_hierarchy" */
export type ApplicationComponentHierarchyMap_Stddev_Pop_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type ApplicationComponentHierarchyMap_Stddev_Samp_Fields = {
  __typename?: 'ApplicationComponentHierarchyMap_stddev_samp_fields';
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "map_application_component_hierarchy" */
export type ApplicationComponentHierarchyMap_Stddev_Samp_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "ApplicationComponentHierarchyMap" */
export type ApplicationComponentHierarchyMap_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: ApplicationComponentHierarchyMap_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type ApplicationComponentHierarchyMap_Stream_Cursor_Value_Input = {
  componentChildId?: InputMaybe<Scalars['uuid']['input']>;
  componentParentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type ApplicationComponentHierarchyMap_Sum_Fields = {
  __typename?: 'ApplicationComponentHierarchyMap_sum_fields';
  order?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "map_application_component_hierarchy" */
export type ApplicationComponentHierarchyMap_Sum_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** update columns of table "map_application_component_hierarchy" */
export enum ApplicationComponentHierarchyMap_Update_Column {
  /** column name */
  ComponentChildId = 'componentChildId',
  /** column name */
  ComponentParentId = 'componentParentId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Order = 'order',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type ApplicationComponentHierarchyMap_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<ApplicationComponentHierarchyMap_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ApplicationComponentHierarchyMap_Set_Input>;
  /** filter the rows which have to be updated */
  where: ApplicationComponentHierarchyMap_Bool_Exp;
};

/** aggregate var_pop on columns */
export type ApplicationComponentHierarchyMap_Var_Pop_Fields = {
  __typename?: 'ApplicationComponentHierarchyMap_var_pop_fields';
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "map_application_component_hierarchy" */
export type ApplicationComponentHierarchyMap_Var_Pop_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type ApplicationComponentHierarchyMap_Var_Samp_Fields = {
  __typename?: 'ApplicationComponentHierarchyMap_var_samp_fields';
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "map_application_component_hierarchy" */
export type ApplicationComponentHierarchyMap_Var_Samp_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type ApplicationComponentHierarchyMap_Variance_Fields = {
  __typename?: 'ApplicationComponentHierarchyMap_variance_fields';
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "map_application_component_hierarchy" */
export type ApplicationComponentHierarchyMap_Variance_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** columns and relationships of "map_application_component_interface" */
export type ApplicationComponentInterfaceMap = {
  __typename?: 'ApplicationComponentInterfaceMap';
  /** An object relationship */
  component: ApplicationComponent;
  componentId: Scalars['uuid']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  interface: InterfaceGeneric;
  interfaceId: Scalars['uuid']['output'];
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "map_application_component_interface" */
export type ApplicationComponentInterfaceMap_Aggregate = {
  __typename?: 'ApplicationComponentInterfaceMap_aggregate';
  aggregate?: Maybe<ApplicationComponentInterfaceMap_Aggregate_Fields>;
  nodes: Array<ApplicationComponentInterfaceMap>;
};

export type ApplicationComponentInterfaceMap_Aggregate_Bool_Exp = {
  count?: InputMaybe<ApplicationComponentInterfaceMap_Aggregate_Bool_Exp_Count>;
};

export type ApplicationComponentInterfaceMap_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<ApplicationComponentInterfaceMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ApplicationComponentInterfaceMap_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "map_application_component_interface" */
export type ApplicationComponentInterfaceMap_Aggregate_Fields = {
  __typename?: 'ApplicationComponentInterfaceMap_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<ApplicationComponentInterfaceMap_Max_Fields>;
  min?: Maybe<ApplicationComponentInterfaceMap_Min_Fields>;
};


/** aggregate fields of "map_application_component_interface" */
export type ApplicationComponentInterfaceMap_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<ApplicationComponentInterfaceMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "map_application_component_interface" */
export type ApplicationComponentInterfaceMap_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<ApplicationComponentInterfaceMap_Max_Order_By>;
  min?: InputMaybe<ApplicationComponentInterfaceMap_Min_Order_By>;
};

/** input type for inserting array relation for remote table "map_application_component_interface" */
export type ApplicationComponentInterfaceMap_Arr_Rel_Insert_Input = {
  data: Array<ApplicationComponentInterfaceMap_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<ApplicationComponentInterfaceMap_On_Conflict>;
};

/** Boolean expression to filter rows from the table "map_application_component_interface". All fields are combined with a logical 'AND'. */
export type ApplicationComponentInterfaceMap_Bool_Exp = {
  _and?: InputMaybe<Array<ApplicationComponentInterfaceMap_Bool_Exp>>;
  _not?: InputMaybe<ApplicationComponentInterfaceMap_Bool_Exp>;
  _or?: InputMaybe<Array<ApplicationComponentInterfaceMap_Bool_Exp>>;
  component?: InputMaybe<ApplicationComponent_Bool_Exp>;
  componentId?: InputMaybe<Uuid_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  interface?: InputMaybe<InterfaceGeneric_Bool_Exp>;
  interfaceId?: InputMaybe<Uuid_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "map_application_component_interface" */
export enum ApplicationComponentInterfaceMap_Constraint {
  /** unique or primary key constraint on columns "interface_id", "component_id" */
  MapApplicationComponentInterfacePkey = 'map_application_component_interface_pkey'
}

/** input type for inserting data into table "map_application_component_interface" */
export type ApplicationComponentInterfaceMap_Insert_Input = {
  component?: InputMaybe<ApplicationComponent_Obj_Rel_Insert_Input>;
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  interface?: InputMaybe<InterfaceGeneric_Obj_Rel_Insert_Input>;
  interfaceId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type ApplicationComponentInterfaceMap_Max_Fields = {
  __typename?: 'ApplicationComponentInterfaceMap_max_fields';
  componentId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  interfaceId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "map_application_component_interface" */
export type ApplicationComponentInterfaceMap_Max_Order_By = {
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  interfaceId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type ApplicationComponentInterfaceMap_Min_Fields = {
  __typename?: 'ApplicationComponentInterfaceMap_min_fields';
  componentId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  interfaceId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "map_application_component_interface" */
export type ApplicationComponentInterfaceMap_Min_Order_By = {
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  interfaceId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "map_application_component_interface" */
export type ApplicationComponentInterfaceMap_Mutation_Response = {
  __typename?: 'ApplicationComponentInterfaceMap_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<ApplicationComponentInterfaceMap>;
};

/** on_conflict condition type for table "map_application_component_interface" */
export type ApplicationComponentInterfaceMap_On_Conflict = {
  constraint: ApplicationComponentInterfaceMap_Constraint;
  update_columns?: Array<ApplicationComponentInterfaceMap_Update_Column>;
  where?: InputMaybe<ApplicationComponentInterfaceMap_Bool_Exp>;
};

/** Ordering options when selecting data from "map_application_component_interface". */
export type ApplicationComponentInterfaceMap_Order_By = {
  component?: InputMaybe<ApplicationComponent_Order_By>;
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  interface?: InputMaybe<InterfaceGeneric_Order_By>;
  interfaceId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: map_application_component_interface */
export type ApplicationComponentInterfaceMap_Pk_Columns_Input = {
  componentId: Scalars['uuid']['input'];
  interfaceId: Scalars['uuid']['input'];
};

/** select columns of table "map_application_component_interface" */
export enum ApplicationComponentInterfaceMap_Select_Column {
  /** column name */
  ComponentId = 'componentId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  InterfaceId = 'interfaceId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "map_application_component_interface" */
export type ApplicationComponentInterfaceMap_Set_Input = {
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  interfaceId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "ApplicationComponentInterfaceMap" */
export type ApplicationComponentInterfaceMap_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: ApplicationComponentInterfaceMap_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type ApplicationComponentInterfaceMap_Stream_Cursor_Value_Input = {
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  interfaceId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "map_application_component_interface" */
export enum ApplicationComponentInterfaceMap_Update_Column {
  /** column name */
  ComponentId = 'componentId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  InterfaceId = 'interfaceId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type ApplicationComponentInterfaceMap_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ApplicationComponentInterfaceMap_Set_Input>;
  /** filter the rows which have to be updated */
  where: ApplicationComponentInterfaceMap_Bool_Exp;
};

/** columns and relationships of "map_application_component_product" */
export type ApplicationComponentProductMap = {
  __typename?: 'ApplicationComponentProductMap';
  /** An object relationship */
  component: ApplicationComponent;
  componentId: Scalars['uuid']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  product: BusinessProduct;
  productId: Scalars['uuid']['output'];
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "map_application_component_product" */
export type ApplicationComponentProductMap_Aggregate = {
  __typename?: 'ApplicationComponentProductMap_aggregate';
  aggregate?: Maybe<ApplicationComponentProductMap_Aggregate_Fields>;
  nodes: Array<ApplicationComponentProductMap>;
};

export type ApplicationComponentProductMap_Aggregate_Bool_Exp = {
  count?: InputMaybe<ApplicationComponentProductMap_Aggregate_Bool_Exp_Count>;
};

export type ApplicationComponentProductMap_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<ApplicationComponentProductMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ApplicationComponentProductMap_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "map_application_component_product" */
export type ApplicationComponentProductMap_Aggregate_Fields = {
  __typename?: 'ApplicationComponentProductMap_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<ApplicationComponentProductMap_Max_Fields>;
  min?: Maybe<ApplicationComponentProductMap_Min_Fields>;
};


/** aggregate fields of "map_application_component_product" */
export type ApplicationComponentProductMap_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<ApplicationComponentProductMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "map_application_component_product" */
export type ApplicationComponentProductMap_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<ApplicationComponentProductMap_Max_Order_By>;
  min?: InputMaybe<ApplicationComponentProductMap_Min_Order_By>;
};

/** input type for inserting array relation for remote table "map_application_component_product" */
export type ApplicationComponentProductMap_Arr_Rel_Insert_Input = {
  data: Array<ApplicationComponentProductMap_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<ApplicationComponentProductMap_On_Conflict>;
};

/** Boolean expression to filter rows from the table "map_application_component_product". All fields are combined with a logical 'AND'. */
export type ApplicationComponentProductMap_Bool_Exp = {
  _and?: InputMaybe<Array<ApplicationComponentProductMap_Bool_Exp>>;
  _not?: InputMaybe<ApplicationComponentProductMap_Bool_Exp>;
  _or?: InputMaybe<Array<ApplicationComponentProductMap_Bool_Exp>>;
  component?: InputMaybe<ApplicationComponent_Bool_Exp>;
  componentId?: InputMaybe<Uuid_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  product?: InputMaybe<BusinessProduct_Bool_Exp>;
  productId?: InputMaybe<Uuid_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "map_application_component_product" */
export enum ApplicationComponentProductMap_Constraint {
  /** unique or primary key constraint on columns "product_id", "component_id" */
  MapApplicationComponentProductPkey = 'map_application_component_product_pkey'
}

/** input type for inserting data into table "map_application_component_product" */
export type ApplicationComponentProductMap_Insert_Input = {
  component?: InputMaybe<ApplicationComponent_Obj_Rel_Insert_Input>;
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  product?: InputMaybe<BusinessProduct_Obj_Rel_Insert_Input>;
  productId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type ApplicationComponentProductMap_Max_Fields = {
  __typename?: 'ApplicationComponentProductMap_max_fields';
  componentId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  productId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "map_application_component_product" */
export type ApplicationComponentProductMap_Max_Order_By = {
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  productId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type ApplicationComponentProductMap_Min_Fields = {
  __typename?: 'ApplicationComponentProductMap_min_fields';
  componentId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  productId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "map_application_component_product" */
export type ApplicationComponentProductMap_Min_Order_By = {
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  productId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "map_application_component_product" */
export type ApplicationComponentProductMap_Mutation_Response = {
  __typename?: 'ApplicationComponentProductMap_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<ApplicationComponentProductMap>;
};

/** on_conflict condition type for table "map_application_component_product" */
export type ApplicationComponentProductMap_On_Conflict = {
  constraint: ApplicationComponentProductMap_Constraint;
  update_columns?: Array<ApplicationComponentProductMap_Update_Column>;
  where?: InputMaybe<ApplicationComponentProductMap_Bool_Exp>;
};

/** Ordering options when selecting data from "map_application_component_product". */
export type ApplicationComponentProductMap_Order_By = {
  component?: InputMaybe<ApplicationComponent_Order_By>;
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  product?: InputMaybe<BusinessProduct_Order_By>;
  productId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: map_application_component_product */
export type ApplicationComponentProductMap_Pk_Columns_Input = {
  componentId: Scalars['uuid']['input'];
  productId: Scalars['uuid']['input'];
};

/** select columns of table "map_application_component_product" */
export enum ApplicationComponentProductMap_Select_Column {
  /** column name */
  ComponentId = 'componentId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  ProductId = 'productId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "map_application_component_product" */
export type ApplicationComponentProductMap_Set_Input = {
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  productId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "ApplicationComponentProductMap" */
export type ApplicationComponentProductMap_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: ApplicationComponentProductMap_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type ApplicationComponentProductMap_Stream_Cursor_Value_Input = {
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  productId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "map_application_component_product" */
export enum ApplicationComponentProductMap_Update_Column {
  /** column name */
  ComponentId = 'componentId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  ProductId = 'productId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type ApplicationComponentProductMap_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ApplicationComponentProductMap_Set_Input>;
  /** filter the rows which have to be updated */
  where: ApplicationComponentProductMap_Bool_Exp;
};

/** columns and relationships of "map_application_component_stakeholder" */
export type ApplicationComponentStakeholderMap = {
  __typename?: 'ApplicationComponentStakeholderMap';
  /** An object relationship */
  component: ApplicationComponent;
  componentId: Scalars['uuid']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  role: Scalars['stakeholder_role_enum']['output'];
  roleId: Scalars['uuid']['output'];
  /** An object relationship */
  stakeholder: Stakeholder;
  stakeholderId: Scalars['uuid']['output'];
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "map_application_component_stakeholder" */
export type ApplicationComponentStakeholderMap_Aggregate = {
  __typename?: 'ApplicationComponentStakeholderMap_aggregate';
  aggregate?: Maybe<ApplicationComponentStakeholderMap_Aggregate_Fields>;
  nodes: Array<ApplicationComponentStakeholderMap>;
};

export type ApplicationComponentStakeholderMap_Aggregate_Bool_Exp = {
  count?: InputMaybe<ApplicationComponentStakeholderMap_Aggregate_Bool_Exp_Count>;
};

export type ApplicationComponentStakeholderMap_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<ApplicationComponentStakeholderMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ApplicationComponentStakeholderMap_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "map_application_component_stakeholder" */
export type ApplicationComponentStakeholderMap_Aggregate_Fields = {
  __typename?: 'ApplicationComponentStakeholderMap_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<ApplicationComponentStakeholderMap_Max_Fields>;
  min?: Maybe<ApplicationComponentStakeholderMap_Min_Fields>;
};


/** aggregate fields of "map_application_component_stakeholder" */
export type ApplicationComponentStakeholderMap_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<ApplicationComponentStakeholderMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "map_application_component_stakeholder" */
export type ApplicationComponentStakeholderMap_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<ApplicationComponentStakeholderMap_Max_Order_By>;
  min?: InputMaybe<ApplicationComponentStakeholderMap_Min_Order_By>;
};

/** input type for inserting array relation for remote table "map_application_component_stakeholder" */
export type ApplicationComponentStakeholderMap_Arr_Rel_Insert_Input = {
  data: Array<ApplicationComponentStakeholderMap_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<ApplicationComponentStakeholderMap_On_Conflict>;
};

/** Boolean expression to filter rows from the table "map_application_component_stakeholder". All fields are combined with a logical 'AND'. */
export type ApplicationComponentStakeholderMap_Bool_Exp = {
  _and?: InputMaybe<Array<ApplicationComponentStakeholderMap_Bool_Exp>>;
  _not?: InputMaybe<ApplicationComponentStakeholderMap_Bool_Exp>;
  _or?: InputMaybe<Array<ApplicationComponentStakeholderMap_Bool_Exp>>;
  component?: InputMaybe<ApplicationComponent_Bool_Exp>;
  componentId?: InputMaybe<Uuid_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  role?: InputMaybe<Stakeholder_Role_Enum_Comparison_Exp>;
  roleId?: InputMaybe<Uuid_Comparison_Exp>;
  stakeholder?: InputMaybe<Stakeholder_Bool_Exp>;
  stakeholderId?: InputMaybe<Uuid_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "map_application_component_stakeholder" */
export enum ApplicationComponentStakeholderMap_Constraint {
  /** unique or primary key constraint on columns "component_id", "stakeholder_id" */
  MapApplicationComponentStakeholderPkey = 'map_application_component_stakeholder_pkey'
}

/** input type for inserting data into table "map_application_component_stakeholder" */
export type ApplicationComponentStakeholderMap_Insert_Input = {
  component?: InputMaybe<ApplicationComponent_Obj_Rel_Insert_Input>;
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  role?: InputMaybe<Scalars['stakeholder_role_enum']['input']>;
  roleId?: InputMaybe<Scalars['uuid']['input']>;
  stakeholder?: InputMaybe<Stakeholder_Obj_Rel_Insert_Input>;
  stakeholderId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type ApplicationComponentStakeholderMap_Max_Fields = {
  __typename?: 'ApplicationComponentStakeholderMap_max_fields';
  componentId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  role?: Maybe<Scalars['stakeholder_role_enum']['output']>;
  roleId?: Maybe<Scalars['uuid']['output']>;
  stakeholderId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "map_application_component_stakeholder" */
export type ApplicationComponentStakeholderMap_Max_Order_By = {
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  role?: InputMaybe<Order_By>;
  roleId?: InputMaybe<Order_By>;
  stakeholderId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type ApplicationComponentStakeholderMap_Min_Fields = {
  __typename?: 'ApplicationComponentStakeholderMap_min_fields';
  componentId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  role?: Maybe<Scalars['stakeholder_role_enum']['output']>;
  roleId?: Maybe<Scalars['uuid']['output']>;
  stakeholderId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "map_application_component_stakeholder" */
export type ApplicationComponentStakeholderMap_Min_Order_By = {
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  role?: InputMaybe<Order_By>;
  roleId?: InputMaybe<Order_By>;
  stakeholderId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "map_application_component_stakeholder" */
export type ApplicationComponentStakeholderMap_Mutation_Response = {
  __typename?: 'ApplicationComponentStakeholderMap_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<ApplicationComponentStakeholderMap>;
};

/** on_conflict condition type for table "map_application_component_stakeholder" */
export type ApplicationComponentStakeholderMap_On_Conflict = {
  constraint: ApplicationComponentStakeholderMap_Constraint;
  update_columns?: Array<ApplicationComponentStakeholderMap_Update_Column>;
  where?: InputMaybe<ApplicationComponentStakeholderMap_Bool_Exp>;
};

/** Ordering options when selecting data from "map_application_component_stakeholder". */
export type ApplicationComponentStakeholderMap_Order_By = {
  component?: InputMaybe<ApplicationComponent_Order_By>;
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  role?: InputMaybe<Order_By>;
  roleId?: InputMaybe<Order_By>;
  stakeholder?: InputMaybe<Stakeholder_Order_By>;
  stakeholderId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: map_application_component_stakeholder */
export type ApplicationComponentStakeholderMap_Pk_Columns_Input = {
  componentId: Scalars['uuid']['input'];
  stakeholderId: Scalars['uuid']['input'];
};

/** select columns of table "map_application_component_stakeholder" */
export enum ApplicationComponentStakeholderMap_Select_Column {
  /** column name */
  ComponentId = 'componentId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Role = 'role',
  /** column name */
  RoleId = 'roleId',
  /** column name */
  StakeholderId = 'stakeholderId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "map_application_component_stakeholder" */
export type ApplicationComponentStakeholderMap_Set_Input = {
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  role?: InputMaybe<Scalars['stakeholder_role_enum']['input']>;
  roleId?: InputMaybe<Scalars['uuid']['input']>;
  stakeholderId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "ApplicationComponentStakeholderMap" */
export type ApplicationComponentStakeholderMap_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: ApplicationComponentStakeholderMap_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type ApplicationComponentStakeholderMap_Stream_Cursor_Value_Input = {
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  role?: InputMaybe<Scalars['stakeholder_role_enum']['input']>;
  roleId?: InputMaybe<Scalars['uuid']['input']>;
  stakeholderId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "map_application_component_stakeholder" */
export enum ApplicationComponentStakeholderMap_Update_Column {
  /** column name */
  ComponentId = 'componentId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Role = 'role',
  /** column name */
  RoleId = 'roleId',
  /** column name */
  StakeholderId = 'stakeholderId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type ApplicationComponentStakeholderMap_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ApplicationComponentStakeholderMap_Set_Input>;
  /** filter the rows which have to be updated */
  where: ApplicationComponentStakeholderMap_Bool_Exp;
};

/** columns and relationships of "map_application_component_system_software" */
export type ApplicationComponentSystemSoftwareMap = {
  __typename?: 'ApplicationComponentSystemSoftwareMap';
  /** An object relationship */
  component: ApplicationComponent;
  componentId: Scalars['uuid']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  kind: Scalars['system_software_kind_enum']['output'];
  /** An object relationship */
  systemSoftware: SystemSoftware;
  systemSoftwareId: Scalars['uuid']['output'];
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "map_application_component_system_software" */
export type ApplicationComponentSystemSoftwareMap_Aggregate = {
  __typename?: 'ApplicationComponentSystemSoftwareMap_aggregate';
  aggregate?: Maybe<ApplicationComponentSystemSoftwareMap_Aggregate_Fields>;
  nodes: Array<ApplicationComponentSystemSoftwareMap>;
};

export type ApplicationComponentSystemSoftwareMap_Aggregate_Bool_Exp = {
  count?: InputMaybe<ApplicationComponentSystemSoftwareMap_Aggregate_Bool_Exp_Count>;
};

export type ApplicationComponentSystemSoftwareMap_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<ApplicationComponentSystemSoftwareMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ApplicationComponentSystemSoftwareMap_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "map_application_component_system_software" */
export type ApplicationComponentSystemSoftwareMap_Aggregate_Fields = {
  __typename?: 'ApplicationComponentSystemSoftwareMap_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<ApplicationComponentSystemSoftwareMap_Max_Fields>;
  min?: Maybe<ApplicationComponentSystemSoftwareMap_Min_Fields>;
};


/** aggregate fields of "map_application_component_system_software" */
export type ApplicationComponentSystemSoftwareMap_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<ApplicationComponentSystemSoftwareMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "map_application_component_system_software" */
export type ApplicationComponentSystemSoftwareMap_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<ApplicationComponentSystemSoftwareMap_Max_Order_By>;
  min?: InputMaybe<ApplicationComponentSystemSoftwareMap_Min_Order_By>;
};

/** input type for inserting array relation for remote table "map_application_component_system_software" */
export type ApplicationComponentSystemSoftwareMap_Arr_Rel_Insert_Input = {
  data: Array<ApplicationComponentSystemSoftwareMap_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<ApplicationComponentSystemSoftwareMap_On_Conflict>;
};

/** Boolean expression to filter rows from the table "map_application_component_system_software". All fields are combined with a logical 'AND'. */
export type ApplicationComponentSystemSoftwareMap_Bool_Exp = {
  _and?: InputMaybe<Array<ApplicationComponentSystemSoftwareMap_Bool_Exp>>;
  _not?: InputMaybe<ApplicationComponentSystemSoftwareMap_Bool_Exp>;
  _or?: InputMaybe<Array<ApplicationComponentSystemSoftwareMap_Bool_Exp>>;
  component?: InputMaybe<ApplicationComponent_Bool_Exp>;
  componentId?: InputMaybe<Uuid_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  kind?: InputMaybe<System_Software_Kind_Enum_Comparison_Exp>;
  systemSoftware?: InputMaybe<SystemSoftware_Bool_Exp>;
  systemSoftwareId?: InputMaybe<Uuid_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "map_application_component_system_software" */
export enum ApplicationComponentSystemSoftwareMap_Constraint {
  /** unique or primary key constraint on columns "system_software_id", "component_id" */
  MapApplicationComponentSystemSoftwarePkey = 'map_application_component_system_software_pkey'
}

/** input type for inserting data into table "map_application_component_system_software" */
export type ApplicationComponentSystemSoftwareMap_Insert_Input = {
  component?: InputMaybe<ApplicationComponent_Obj_Rel_Insert_Input>;
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  kind?: InputMaybe<Scalars['system_software_kind_enum']['input']>;
  systemSoftware?: InputMaybe<SystemSoftware_Obj_Rel_Insert_Input>;
  systemSoftwareId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type ApplicationComponentSystemSoftwareMap_Max_Fields = {
  __typename?: 'ApplicationComponentSystemSoftwareMap_max_fields';
  componentId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  kind?: Maybe<Scalars['system_software_kind_enum']['output']>;
  systemSoftwareId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "map_application_component_system_software" */
export type ApplicationComponentSystemSoftwareMap_Max_Order_By = {
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  kind?: InputMaybe<Order_By>;
  systemSoftwareId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type ApplicationComponentSystemSoftwareMap_Min_Fields = {
  __typename?: 'ApplicationComponentSystemSoftwareMap_min_fields';
  componentId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  kind?: Maybe<Scalars['system_software_kind_enum']['output']>;
  systemSoftwareId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "map_application_component_system_software" */
export type ApplicationComponentSystemSoftwareMap_Min_Order_By = {
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  kind?: InputMaybe<Order_By>;
  systemSoftwareId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "map_application_component_system_software" */
export type ApplicationComponentSystemSoftwareMap_Mutation_Response = {
  __typename?: 'ApplicationComponentSystemSoftwareMap_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<ApplicationComponentSystemSoftwareMap>;
};

/** on_conflict condition type for table "map_application_component_system_software" */
export type ApplicationComponentSystemSoftwareMap_On_Conflict = {
  constraint: ApplicationComponentSystemSoftwareMap_Constraint;
  update_columns?: Array<ApplicationComponentSystemSoftwareMap_Update_Column>;
  where?: InputMaybe<ApplicationComponentSystemSoftwareMap_Bool_Exp>;
};

/** Ordering options when selecting data from "map_application_component_system_software". */
export type ApplicationComponentSystemSoftwareMap_Order_By = {
  component?: InputMaybe<ApplicationComponent_Order_By>;
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  kind?: InputMaybe<Order_By>;
  systemSoftware?: InputMaybe<SystemSoftware_Order_By>;
  systemSoftwareId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: map_application_component_system_software */
export type ApplicationComponentSystemSoftwareMap_Pk_Columns_Input = {
  componentId: Scalars['uuid']['input'];
  systemSoftwareId: Scalars['uuid']['input'];
};

/** select columns of table "map_application_component_system_software" */
export enum ApplicationComponentSystemSoftwareMap_Select_Column {
  /** column name */
  ComponentId = 'componentId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Kind = 'kind',
  /** column name */
  SystemSoftwareId = 'systemSoftwareId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "map_application_component_system_software" */
export type ApplicationComponentSystemSoftwareMap_Set_Input = {
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  kind?: InputMaybe<Scalars['system_software_kind_enum']['input']>;
  systemSoftwareId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "ApplicationComponentSystemSoftwareMap" */
export type ApplicationComponentSystemSoftwareMap_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: ApplicationComponentSystemSoftwareMap_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type ApplicationComponentSystemSoftwareMap_Stream_Cursor_Value_Input = {
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  kind?: InputMaybe<Scalars['system_software_kind_enum']['input']>;
  systemSoftwareId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "map_application_component_system_software" */
export enum ApplicationComponentSystemSoftwareMap_Update_Column {
  /** column name */
  ComponentId = 'componentId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Kind = 'kind',
  /** column name */
  SystemSoftwareId = 'systemSoftwareId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type ApplicationComponentSystemSoftwareMap_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ApplicationComponentSystemSoftwareMap_Set_Input>;
  /** filter the rows which have to be updated */
  where: ApplicationComponentSystemSoftwareMap_Bool_Exp;
};

/** columns and relationships of "map_application_component_technology_logical_network" */
export type ApplicationComponentTechnologyLogicalNetworkMap = {
  __typename?: 'ApplicationComponentTechnologyLogicalNetworkMap';
  /** An object relationship */
  component: ApplicationComponent;
  componentId: Scalars['uuid']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  logicalNetwork: TechnologyNetwork;
  logicalNetworkId: Scalars['uuid']['output'];
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "map_application_component_technology_logical_network" */
export type ApplicationComponentTechnologyLogicalNetworkMap_Aggregate = {
  __typename?: 'ApplicationComponentTechnologyLogicalNetworkMap_aggregate';
  aggregate?: Maybe<ApplicationComponentTechnologyLogicalNetworkMap_Aggregate_Fields>;
  nodes: Array<ApplicationComponentTechnologyLogicalNetworkMap>;
};

export type ApplicationComponentTechnologyLogicalNetworkMap_Aggregate_Bool_Exp = {
  count?: InputMaybe<ApplicationComponentTechnologyLogicalNetworkMap_Aggregate_Bool_Exp_Count>;
};

export type ApplicationComponentTechnologyLogicalNetworkMap_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<ApplicationComponentTechnologyLogicalNetworkMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ApplicationComponentTechnologyLogicalNetworkMap_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "map_application_component_technology_logical_network" */
export type ApplicationComponentTechnologyLogicalNetworkMap_Aggregate_Fields = {
  __typename?: 'ApplicationComponentTechnologyLogicalNetworkMap_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<ApplicationComponentTechnologyLogicalNetworkMap_Max_Fields>;
  min?: Maybe<ApplicationComponentTechnologyLogicalNetworkMap_Min_Fields>;
};


/** aggregate fields of "map_application_component_technology_logical_network" */
export type ApplicationComponentTechnologyLogicalNetworkMap_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<ApplicationComponentTechnologyLogicalNetworkMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "map_application_component_technology_logical_network" */
export type ApplicationComponentTechnologyLogicalNetworkMap_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<ApplicationComponentTechnologyLogicalNetworkMap_Max_Order_By>;
  min?: InputMaybe<ApplicationComponentTechnologyLogicalNetworkMap_Min_Order_By>;
};

/** input type for inserting array relation for remote table "map_application_component_technology_logical_network" */
export type ApplicationComponentTechnologyLogicalNetworkMap_Arr_Rel_Insert_Input = {
  data: Array<ApplicationComponentTechnologyLogicalNetworkMap_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<ApplicationComponentTechnologyLogicalNetworkMap_On_Conflict>;
};

/** Boolean expression to filter rows from the table "map_application_component_technology_logical_network". All fields are combined with a logical 'AND'. */
export type ApplicationComponentTechnologyLogicalNetworkMap_Bool_Exp = {
  _and?: InputMaybe<Array<ApplicationComponentTechnologyLogicalNetworkMap_Bool_Exp>>;
  _not?: InputMaybe<ApplicationComponentTechnologyLogicalNetworkMap_Bool_Exp>;
  _or?: InputMaybe<Array<ApplicationComponentTechnologyLogicalNetworkMap_Bool_Exp>>;
  component?: InputMaybe<ApplicationComponent_Bool_Exp>;
  componentId?: InputMaybe<Uuid_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  logicalNetwork?: InputMaybe<TechnologyNetwork_Bool_Exp>;
  logicalNetworkId?: InputMaybe<Uuid_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "map_application_component_technology_logical_network" */
export enum ApplicationComponentTechnologyLogicalNetworkMap_Constraint {
  /** unique or primary key constraint on columns "logical_network_id", "component_id" */
  MapApplicationComponentTechnologyLogicalNetworkPkey = 'map_application_component_technology_logical_network_pkey'
}

/** input type for inserting data into table "map_application_component_technology_logical_network" */
export type ApplicationComponentTechnologyLogicalNetworkMap_Insert_Input = {
  component?: InputMaybe<ApplicationComponent_Obj_Rel_Insert_Input>;
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  logicalNetwork?: InputMaybe<TechnologyNetwork_Obj_Rel_Insert_Input>;
  logicalNetworkId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type ApplicationComponentTechnologyLogicalNetworkMap_Max_Fields = {
  __typename?: 'ApplicationComponentTechnologyLogicalNetworkMap_max_fields';
  componentId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  logicalNetworkId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "map_application_component_technology_logical_network" */
export type ApplicationComponentTechnologyLogicalNetworkMap_Max_Order_By = {
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  logicalNetworkId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type ApplicationComponentTechnologyLogicalNetworkMap_Min_Fields = {
  __typename?: 'ApplicationComponentTechnologyLogicalNetworkMap_min_fields';
  componentId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  logicalNetworkId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "map_application_component_technology_logical_network" */
export type ApplicationComponentTechnologyLogicalNetworkMap_Min_Order_By = {
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  logicalNetworkId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "map_application_component_technology_logical_network" */
export type ApplicationComponentTechnologyLogicalNetworkMap_Mutation_Response = {
  __typename?: 'ApplicationComponentTechnologyLogicalNetworkMap_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<ApplicationComponentTechnologyLogicalNetworkMap>;
};

/** on_conflict condition type for table "map_application_component_technology_logical_network" */
export type ApplicationComponentTechnologyLogicalNetworkMap_On_Conflict = {
  constraint: ApplicationComponentTechnologyLogicalNetworkMap_Constraint;
  update_columns?: Array<ApplicationComponentTechnologyLogicalNetworkMap_Update_Column>;
  where?: InputMaybe<ApplicationComponentTechnologyLogicalNetworkMap_Bool_Exp>;
};

/** Ordering options when selecting data from "map_application_component_technology_logical_network". */
export type ApplicationComponentTechnologyLogicalNetworkMap_Order_By = {
  component?: InputMaybe<ApplicationComponent_Order_By>;
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  logicalNetwork?: InputMaybe<TechnologyNetwork_Order_By>;
  logicalNetworkId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: map_application_component_technology_logical_network */
export type ApplicationComponentTechnologyLogicalNetworkMap_Pk_Columns_Input = {
  componentId: Scalars['uuid']['input'];
  logicalNetworkId: Scalars['uuid']['input'];
};

/** select columns of table "map_application_component_technology_logical_network" */
export enum ApplicationComponentTechnologyLogicalNetworkMap_Select_Column {
  /** column name */
  ComponentId = 'componentId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  LogicalNetworkId = 'logicalNetworkId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "map_application_component_technology_logical_network" */
export type ApplicationComponentTechnologyLogicalNetworkMap_Set_Input = {
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  logicalNetworkId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "ApplicationComponentTechnologyLogicalNetworkMap" */
export type ApplicationComponentTechnologyLogicalNetworkMap_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: ApplicationComponentTechnologyLogicalNetworkMap_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type ApplicationComponentTechnologyLogicalNetworkMap_Stream_Cursor_Value_Input = {
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  logicalNetworkId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "map_application_component_technology_logical_network" */
export enum ApplicationComponentTechnologyLogicalNetworkMap_Update_Column {
  /** column name */
  ComponentId = 'componentId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  LogicalNetworkId = 'logicalNetworkId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type ApplicationComponentTechnologyLogicalNetworkMap_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ApplicationComponentTechnologyLogicalNetworkMap_Set_Input>;
  /** filter the rows which have to be updated */
  where: ApplicationComponentTechnologyLogicalNetworkMap_Bool_Exp;
};

/** columns and relationships of "map_application_component_technology_node" */
export type ApplicationComponentTechnologyNodeMap = {
  __typename?: 'ApplicationComponentTechnologyNodeMap';
  /** An object relationship */
  component: ApplicationComponent;
  componentId: Scalars['uuid']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  node: TechnologyNode;
  nodeId: Scalars['uuid']['output'];
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "map_application_component_technology_node" */
export type ApplicationComponentTechnologyNodeMap_Aggregate = {
  __typename?: 'ApplicationComponentTechnologyNodeMap_aggregate';
  aggregate?: Maybe<ApplicationComponentTechnologyNodeMap_Aggregate_Fields>;
  nodes: Array<ApplicationComponentTechnologyNodeMap>;
};

export type ApplicationComponentTechnologyNodeMap_Aggregate_Bool_Exp = {
  count?: InputMaybe<ApplicationComponentTechnologyNodeMap_Aggregate_Bool_Exp_Count>;
};

export type ApplicationComponentTechnologyNodeMap_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<ApplicationComponentTechnologyNodeMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ApplicationComponentTechnologyNodeMap_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "map_application_component_technology_node" */
export type ApplicationComponentTechnologyNodeMap_Aggregate_Fields = {
  __typename?: 'ApplicationComponentTechnologyNodeMap_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<ApplicationComponentTechnologyNodeMap_Max_Fields>;
  min?: Maybe<ApplicationComponentTechnologyNodeMap_Min_Fields>;
};


/** aggregate fields of "map_application_component_technology_node" */
export type ApplicationComponentTechnologyNodeMap_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<ApplicationComponentTechnologyNodeMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "map_application_component_technology_node" */
export type ApplicationComponentTechnologyNodeMap_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<ApplicationComponentTechnologyNodeMap_Max_Order_By>;
  min?: InputMaybe<ApplicationComponentTechnologyNodeMap_Min_Order_By>;
};

/** input type for inserting array relation for remote table "map_application_component_technology_node" */
export type ApplicationComponentTechnologyNodeMap_Arr_Rel_Insert_Input = {
  data: Array<ApplicationComponentTechnologyNodeMap_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<ApplicationComponentTechnologyNodeMap_On_Conflict>;
};

/** Boolean expression to filter rows from the table "map_application_component_technology_node". All fields are combined with a logical 'AND'. */
export type ApplicationComponentTechnologyNodeMap_Bool_Exp = {
  _and?: InputMaybe<Array<ApplicationComponentTechnologyNodeMap_Bool_Exp>>;
  _not?: InputMaybe<ApplicationComponentTechnologyNodeMap_Bool_Exp>;
  _or?: InputMaybe<Array<ApplicationComponentTechnologyNodeMap_Bool_Exp>>;
  component?: InputMaybe<ApplicationComponent_Bool_Exp>;
  componentId?: InputMaybe<Uuid_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  node?: InputMaybe<TechnologyNode_Bool_Exp>;
  nodeId?: InputMaybe<Uuid_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "map_application_component_technology_node" */
export enum ApplicationComponentTechnologyNodeMap_Constraint {
  /** unique or primary key constraint on columns "node_id", "component_id" */
  MapApplicationComponentTechnologyNodePkey = 'map_application_component_technology_node_pkey'
}

/** input type for inserting data into table "map_application_component_technology_node" */
export type ApplicationComponentTechnologyNodeMap_Insert_Input = {
  component?: InputMaybe<ApplicationComponent_Obj_Rel_Insert_Input>;
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  node?: InputMaybe<TechnologyNode_Obj_Rel_Insert_Input>;
  nodeId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type ApplicationComponentTechnologyNodeMap_Max_Fields = {
  __typename?: 'ApplicationComponentTechnologyNodeMap_max_fields';
  componentId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  nodeId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "map_application_component_technology_node" */
export type ApplicationComponentTechnologyNodeMap_Max_Order_By = {
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  nodeId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type ApplicationComponentTechnologyNodeMap_Min_Fields = {
  __typename?: 'ApplicationComponentTechnologyNodeMap_min_fields';
  componentId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  nodeId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "map_application_component_technology_node" */
export type ApplicationComponentTechnologyNodeMap_Min_Order_By = {
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  nodeId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "map_application_component_technology_node" */
export type ApplicationComponentTechnologyNodeMap_Mutation_Response = {
  __typename?: 'ApplicationComponentTechnologyNodeMap_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<ApplicationComponentTechnologyNodeMap>;
};

/** on_conflict condition type for table "map_application_component_technology_node" */
export type ApplicationComponentTechnologyNodeMap_On_Conflict = {
  constraint: ApplicationComponentTechnologyNodeMap_Constraint;
  update_columns?: Array<ApplicationComponentTechnologyNodeMap_Update_Column>;
  where?: InputMaybe<ApplicationComponentTechnologyNodeMap_Bool_Exp>;
};

/** Ordering options when selecting data from "map_application_component_technology_node". */
export type ApplicationComponentTechnologyNodeMap_Order_By = {
  component?: InputMaybe<ApplicationComponent_Order_By>;
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  node?: InputMaybe<TechnologyNode_Order_By>;
  nodeId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: map_application_component_technology_node */
export type ApplicationComponentTechnologyNodeMap_Pk_Columns_Input = {
  componentId: Scalars['uuid']['input'];
  nodeId: Scalars['uuid']['input'];
};

/** select columns of table "map_application_component_technology_node" */
export enum ApplicationComponentTechnologyNodeMap_Select_Column {
  /** column name */
  ComponentId = 'componentId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  NodeId = 'nodeId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "map_application_component_technology_node" */
export type ApplicationComponentTechnologyNodeMap_Set_Input = {
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  nodeId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "ApplicationComponentTechnologyNodeMap" */
export type ApplicationComponentTechnologyNodeMap_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: ApplicationComponentTechnologyNodeMap_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type ApplicationComponentTechnologyNodeMap_Stream_Cursor_Value_Input = {
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  nodeId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "map_application_component_technology_node" */
export enum ApplicationComponentTechnologyNodeMap_Update_Column {
  /** column name */
  ComponentId = 'componentId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  NodeId = 'nodeId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type ApplicationComponentTechnologyNodeMap_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ApplicationComponentTechnologyNodeMap_Set_Input>;
  /** filter the rows which have to be updated */
  where: ApplicationComponentTechnologyNodeMap_Bool_Exp;
};

/** aggregated selection of "components" */
export type ApplicationComponent_Aggregate = {
  __typename?: 'ApplicationComponent_aggregate';
  aggregate?: Maybe<ApplicationComponent_Aggregate_Fields>;
  nodes: Array<ApplicationComponent>;
};

export type ApplicationComponent_Aggregate_Bool_Exp = {
  count?: InputMaybe<ApplicationComponent_Aggregate_Bool_Exp_Count>;
};

export type ApplicationComponent_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<ApplicationComponent_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ApplicationComponent_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "components" */
export type ApplicationComponent_Aggregate_Fields = {
  __typename?: 'ApplicationComponent_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<ApplicationComponent_Max_Fields>;
  min?: Maybe<ApplicationComponent_Min_Fields>;
};


/** aggregate fields of "components" */
export type ApplicationComponent_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<ApplicationComponent_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "components" */
export type ApplicationComponent_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<ApplicationComponent_Max_Order_By>;
  min?: InputMaybe<ApplicationComponent_Min_Order_By>;
};

/** input type for inserting array relation for remote table "components" */
export type ApplicationComponent_Arr_Rel_Insert_Input = {
  data: Array<ApplicationComponent_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<ApplicationComponent_On_Conflict>;
};

/** Boolean expression to filter rows from the table "components". All fields are combined with a logical 'AND'. */
export type ApplicationComponent_Bool_Exp = {
  _and?: InputMaybe<Array<ApplicationComponent_Bool_Exp>>;
  _not?: InputMaybe<ApplicationComponent_Bool_Exp>;
  _or?: InputMaybe<Array<ApplicationComponent_Bool_Exp>>;
  actorRole?: InputMaybe<ApplicationComponentBusinessActorRoleMap_Bool_Exp>;
  actorRole_aggregate?: InputMaybe<ApplicationComponentBusinessActorRoleMap_Aggregate_Bool_Exp>;
  capabilities?: InputMaybe<CapabilityApplicationComponentMap_Bool_Exp>;
  capabilities_aggregate?: InputMaybe<CapabilityApplicationComponentMap_Aggregate_Bool_Exp>;
  children?: InputMaybe<ApplicationComponentHierarchyMap_Bool_Exp>;
  children_aggregate?: InputMaybe<ApplicationComponentHierarchyMap_Aggregate_Bool_Exp>;
  code?: InputMaybe<String_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  criticalLevel?: InputMaybe<DirectoryObject_Bool_Exp>;
  criticalLevelId?: InputMaybe<Uuid_Comparison_Exp>;
  dataObjects?: InputMaybe<ApplicationComponentDataObjectMap_Bool_Exp>;
  dataObjectsInFunctions?: InputMaybe<ApplicationFunctionDataObjectMap_Bool_Exp>;
  dataObjectsInFunctions_aggregate?: InputMaybe<ApplicationFunctionDataObjectMap_Aggregate_Bool_Exp>;
  dataObjects_aggregate?: InputMaybe<ApplicationComponentDataObjectMap_Aggregate_Bool_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  directories?: InputMaybe<ApplicationComponentDirectoryMap_Bool_Exp>;
  directories_aggregate?: InputMaybe<ApplicationComponentDirectoryMap_Aggregate_Bool_Exp>;
  events?: InputMaybe<ApplicationComponentEventMap_Bool_Exp>;
  events_aggregate?: InputMaybe<ApplicationComponentEventMap_Aggregate_Bool_Exp>;
  failoverType?: InputMaybe<DirectoryObject_Bool_Exp>;
  failoverTypeId?: InputMaybe<Uuid_Comparison_Exp>;
  functions?: InputMaybe<ApplicationComponentFunctionMap_Bool_Exp>;
  functions_aggregate?: InputMaybe<ApplicationComponentFunctionMap_Aggregate_Bool_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  interfaces?: InputMaybe<ApplicationComponentInterfaceMap_Bool_Exp>;
  interfaces_aggregate?: InputMaybe<ApplicationComponentInterfaceMap_Aggregate_Bool_Exp>;
  licenseType?: InputMaybe<DirectoryObject_Bool_Exp>;
  licenseTypeId?: InputMaybe<Uuid_Comparison_Exp>;
  monitoringLevel?: InputMaybe<DirectoryObject_Bool_Exp>;
  monitoringLevelId?: InputMaybe<Uuid_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  networks?: InputMaybe<ApplicationComponentTechnologyLogicalNetworkMap_Bool_Exp>;
  networks_aggregate?: InputMaybe<ApplicationComponentTechnologyLogicalNetworkMap_Aggregate_Bool_Exp>;
  nodes?: InputMaybe<ApplicationComponentTechnologyNodeMap_Bool_Exp>;
  nodes_aggregate?: InputMaybe<ApplicationComponentTechnologyNodeMap_Aggregate_Bool_Exp>;
  parents?: InputMaybe<ApplicationComponentHierarchyMap_Bool_Exp>;
  parents_aggregate?: InputMaybe<ApplicationComponentHierarchyMap_Aggregate_Bool_Exp>;
  products?: InputMaybe<ApplicationComponentProductMap_Bool_Exp>;
  products_aggregate?: InputMaybe<ApplicationComponentProductMap_Aggregate_Bool_Exp>;
  recoveryTime?: InputMaybe<DirectoryObject_Bool_Exp>;
  recoveryTimeId?: InputMaybe<Uuid_Comparison_Exp>;
  redundancyType?: InputMaybe<DirectoryObject_Bool_Exp>;
  redundancyTypeId?: InputMaybe<Uuid_Comparison_Exp>;
  scalingType?: InputMaybe<DirectoryObject_Bool_Exp>;
  scalingTypeId?: InputMaybe<Uuid_Comparison_Exp>;
  solutions?: InputMaybe<SolutionApplicationComponentMap_Bool_Exp>;
  solutions_aggregate?: InputMaybe<SolutionApplicationComponentMap_Aggregate_Bool_Exp>;
  sourceComponent?: InputMaybe<FlowGeneric_Bool_Exp>;
  sourceComponent_aggregate?: InputMaybe<FlowGeneric_Aggregate_Bool_Exp>;
  stakeholders?: InputMaybe<ApplicationComponentStakeholderMap_Bool_Exp>;
  stakeholders_aggregate?: InputMaybe<ApplicationComponentStakeholderMap_Aggregate_Bool_Exp>;
  state?: InputMaybe<DirectoryObject_Bool_Exp>;
  stateId?: InputMaybe<Uuid_Comparison_Exp>;
  style?: InputMaybe<DirectoryObject_Bool_Exp>;
  styleId?: InputMaybe<Uuid_Comparison_Exp>;
  systemSoftware?: InputMaybe<ApplicationComponentSystemSoftwareMap_Bool_Exp>;
  systemSoftware_aggregate?: InputMaybe<ApplicationComponentSystemSoftwareMap_Aggregate_Bool_Exp>;
  targetComponent?: InputMaybe<FlowGeneric_Bool_Exp>;
  targetComponent_aggregate?: InputMaybe<FlowGeneric_Aggregate_Bool_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "components" */
export enum ApplicationComponent_Constraint {
  /** unique or primary key constraint on columns "code" */
  ComponentsCodeUnique = 'components_code_unique',
  /** unique or primary key constraint on columns "id" */
  ComponentsPkey = 'components_pkey'
}

/** input type for inserting data into table "components" */
export type ApplicationComponent_Insert_Input = {
  actorRole?: InputMaybe<ApplicationComponentBusinessActorRoleMap_Arr_Rel_Insert_Input>;
  capabilities?: InputMaybe<CapabilityApplicationComponentMap_Arr_Rel_Insert_Input>;
  children?: InputMaybe<ApplicationComponentHierarchyMap_Arr_Rel_Insert_Input>;
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  criticalLevel?: InputMaybe<DirectoryObject_Obj_Rel_Insert_Input>;
  criticalLevelId?: InputMaybe<Scalars['uuid']['input']>;
  dataObjects?: InputMaybe<ApplicationComponentDataObjectMap_Arr_Rel_Insert_Input>;
  dataObjectsInFunctions?: InputMaybe<ApplicationFunctionDataObjectMap_Arr_Rel_Insert_Input>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  directories?: InputMaybe<ApplicationComponentDirectoryMap_Arr_Rel_Insert_Input>;
  events?: InputMaybe<ApplicationComponentEventMap_Arr_Rel_Insert_Input>;
  failoverType?: InputMaybe<DirectoryObject_Obj_Rel_Insert_Input>;
  failoverTypeId?: InputMaybe<Scalars['uuid']['input']>;
  functions?: InputMaybe<ApplicationComponentFunctionMap_Arr_Rel_Insert_Input>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  interfaces?: InputMaybe<ApplicationComponentInterfaceMap_Arr_Rel_Insert_Input>;
  licenseType?: InputMaybe<DirectoryObject_Obj_Rel_Insert_Input>;
  licenseTypeId?: InputMaybe<Scalars['uuid']['input']>;
  monitoringLevel?: InputMaybe<DirectoryObject_Obj_Rel_Insert_Input>;
  monitoringLevelId?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  networks?: InputMaybe<ApplicationComponentTechnologyLogicalNetworkMap_Arr_Rel_Insert_Input>;
  nodes?: InputMaybe<ApplicationComponentTechnologyNodeMap_Arr_Rel_Insert_Input>;
  parents?: InputMaybe<ApplicationComponentHierarchyMap_Arr_Rel_Insert_Input>;
  products?: InputMaybe<ApplicationComponentProductMap_Arr_Rel_Insert_Input>;
  recoveryTime?: InputMaybe<DirectoryObject_Obj_Rel_Insert_Input>;
  recoveryTimeId?: InputMaybe<Scalars['uuid']['input']>;
  redundancyType?: InputMaybe<DirectoryObject_Obj_Rel_Insert_Input>;
  redundancyTypeId?: InputMaybe<Scalars['uuid']['input']>;
  scalingType?: InputMaybe<DirectoryObject_Obj_Rel_Insert_Input>;
  scalingTypeId?: InputMaybe<Scalars['uuid']['input']>;
  solutions?: InputMaybe<SolutionApplicationComponentMap_Arr_Rel_Insert_Input>;
  sourceComponent?: InputMaybe<FlowGeneric_Arr_Rel_Insert_Input>;
  stakeholders?: InputMaybe<ApplicationComponentStakeholderMap_Arr_Rel_Insert_Input>;
  state?: InputMaybe<DirectoryObject_Obj_Rel_Insert_Input>;
  stateId?: InputMaybe<Scalars['uuid']['input']>;
  style?: InputMaybe<DirectoryObject_Obj_Rel_Insert_Input>;
  styleId?: InputMaybe<Scalars['uuid']['input']>;
  systemSoftware?: InputMaybe<ApplicationComponentSystemSoftwareMap_Arr_Rel_Insert_Input>;
  targetComponent?: InputMaybe<FlowGeneric_Arr_Rel_Insert_Input>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type ApplicationComponent_Max_Fields = {
  __typename?: 'ApplicationComponent_max_fields';
  code?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  criticalLevelId?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  failoverTypeId?: Maybe<Scalars['uuid']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  licenseTypeId?: Maybe<Scalars['uuid']['output']>;
  monitoringLevelId?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  recoveryTimeId?: Maybe<Scalars['uuid']['output']>;
  redundancyTypeId?: Maybe<Scalars['uuid']['output']>;
  scalingTypeId?: Maybe<Scalars['uuid']['output']>;
  stateId?: Maybe<Scalars['uuid']['output']>;
  styleId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "components" */
export type ApplicationComponent_Max_Order_By = {
  code?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  criticalLevelId?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  failoverTypeId?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  licenseTypeId?: InputMaybe<Order_By>;
  monitoringLevelId?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  recoveryTimeId?: InputMaybe<Order_By>;
  redundancyTypeId?: InputMaybe<Order_By>;
  scalingTypeId?: InputMaybe<Order_By>;
  stateId?: InputMaybe<Order_By>;
  styleId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type ApplicationComponent_Min_Fields = {
  __typename?: 'ApplicationComponent_min_fields';
  code?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  criticalLevelId?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  failoverTypeId?: Maybe<Scalars['uuid']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  licenseTypeId?: Maybe<Scalars['uuid']['output']>;
  monitoringLevelId?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  recoveryTimeId?: Maybe<Scalars['uuid']['output']>;
  redundancyTypeId?: Maybe<Scalars['uuid']['output']>;
  scalingTypeId?: Maybe<Scalars['uuid']['output']>;
  stateId?: Maybe<Scalars['uuid']['output']>;
  styleId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "components" */
export type ApplicationComponent_Min_Order_By = {
  code?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  criticalLevelId?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  failoverTypeId?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  licenseTypeId?: InputMaybe<Order_By>;
  monitoringLevelId?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  recoveryTimeId?: InputMaybe<Order_By>;
  redundancyTypeId?: InputMaybe<Order_By>;
  scalingTypeId?: InputMaybe<Order_By>;
  stateId?: InputMaybe<Order_By>;
  styleId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "components" */
export type ApplicationComponent_Mutation_Response = {
  __typename?: 'ApplicationComponent_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<ApplicationComponent>;
};

/** input type for inserting object relation for remote table "components" */
export type ApplicationComponent_Obj_Rel_Insert_Input = {
  data: ApplicationComponent_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<ApplicationComponent_On_Conflict>;
};

/** on_conflict condition type for table "components" */
export type ApplicationComponent_On_Conflict = {
  constraint: ApplicationComponent_Constraint;
  update_columns?: Array<ApplicationComponent_Update_Column>;
  where?: InputMaybe<ApplicationComponent_Bool_Exp>;
};

/** Ordering options when selecting data from "components". */
export type ApplicationComponent_Order_By = {
  actorRole_aggregate?: InputMaybe<ApplicationComponentBusinessActorRoleMap_Aggregate_Order_By>;
  capabilities_aggregate?: InputMaybe<CapabilityApplicationComponentMap_Aggregate_Order_By>;
  children_aggregate?: InputMaybe<ApplicationComponentHierarchyMap_Aggregate_Order_By>;
  code?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  criticalLevel?: InputMaybe<DirectoryObject_Order_By>;
  criticalLevelId?: InputMaybe<Order_By>;
  dataObjectsInFunctions_aggregate?: InputMaybe<ApplicationFunctionDataObjectMap_Aggregate_Order_By>;
  dataObjects_aggregate?: InputMaybe<ApplicationComponentDataObjectMap_Aggregate_Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  directories_aggregate?: InputMaybe<ApplicationComponentDirectoryMap_Aggregate_Order_By>;
  events_aggregate?: InputMaybe<ApplicationComponentEventMap_Aggregate_Order_By>;
  failoverType?: InputMaybe<DirectoryObject_Order_By>;
  failoverTypeId?: InputMaybe<Order_By>;
  functions_aggregate?: InputMaybe<ApplicationComponentFunctionMap_Aggregate_Order_By>;
  id?: InputMaybe<Order_By>;
  interfaces_aggregate?: InputMaybe<ApplicationComponentInterfaceMap_Aggregate_Order_By>;
  licenseType?: InputMaybe<DirectoryObject_Order_By>;
  licenseTypeId?: InputMaybe<Order_By>;
  monitoringLevel?: InputMaybe<DirectoryObject_Order_By>;
  monitoringLevelId?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  networks_aggregate?: InputMaybe<ApplicationComponentTechnologyLogicalNetworkMap_Aggregate_Order_By>;
  nodes_aggregate?: InputMaybe<ApplicationComponentTechnologyNodeMap_Aggregate_Order_By>;
  parents_aggregate?: InputMaybe<ApplicationComponentHierarchyMap_Aggregate_Order_By>;
  products_aggregate?: InputMaybe<ApplicationComponentProductMap_Aggregate_Order_By>;
  recoveryTime?: InputMaybe<DirectoryObject_Order_By>;
  recoveryTimeId?: InputMaybe<Order_By>;
  redundancyType?: InputMaybe<DirectoryObject_Order_By>;
  redundancyTypeId?: InputMaybe<Order_By>;
  scalingType?: InputMaybe<DirectoryObject_Order_By>;
  scalingTypeId?: InputMaybe<Order_By>;
  solutions_aggregate?: InputMaybe<SolutionApplicationComponentMap_Aggregate_Order_By>;
  sourceComponent_aggregate?: InputMaybe<FlowGeneric_Aggregate_Order_By>;
  stakeholders_aggregate?: InputMaybe<ApplicationComponentStakeholderMap_Aggregate_Order_By>;
  state?: InputMaybe<DirectoryObject_Order_By>;
  stateId?: InputMaybe<Order_By>;
  style?: InputMaybe<DirectoryObject_Order_By>;
  styleId?: InputMaybe<Order_By>;
  systemSoftware_aggregate?: InputMaybe<ApplicationComponentSystemSoftwareMap_Aggregate_Order_By>;
  targetComponent_aggregate?: InputMaybe<FlowGeneric_Aggregate_Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: components */
export type ApplicationComponent_Pk_Columns_Input = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "components" */
export enum ApplicationComponent_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  CriticalLevelId = 'criticalLevelId',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  FailoverTypeId = 'failoverTypeId',
  /** column name */
  Id = 'id',
  /** column name */
  LicenseTypeId = 'licenseTypeId',
  /** column name */
  MonitoringLevelId = 'monitoringLevelId',
  /** column name */
  Name = 'name',
  /** column name */
  RecoveryTimeId = 'recoveryTimeId',
  /** column name */
  RedundancyTypeId = 'redundancyTypeId',
  /** column name */
  ScalingTypeId = 'scalingTypeId',
  /** column name */
  StateId = 'stateId',
  /** column name */
  StyleId = 'styleId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "components" */
export type ApplicationComponent_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  criticalLevelId?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  failoverTypeId?: InputMaybe<Scalars['uuid']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  licenseTypeId?: InputMaybe<Scalars['uuid']['input']>;
  monitoringLevelId?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  recoveryTimeId?: InputMaybe<Scalars['uuid']['input']>;
  redundancyTypeId?: InputMaybe<Scalars['uuid']['input']>;
  scalingTypeId?: InputMaybe<Scalars['uuid']['input']>;
  stateId?: InputMaybe<Scalars['uuid']['input']>;
  styleId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "ApplicationComponent" */
export type ApplicationComponent_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: ApplicationComponent_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type ApplicationComponent_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  criticalLevelId?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  failoverTypeId?: InputMaybe<Scalars['uuid']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  licenseTypeId?: InputMaybe<Scalars['uuid']['input']>;
  monitoringLevelId?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  recoveryTimeId?: InputMaybe<Scalars['uuid']['input']>;
  redundancyTypeId?: InputMaybe<Scalars['uuid']['input']>;
  scalingTypeId?: InputMaybe<Scalars['uuid']['input']>;
  stateId?: InputMaybe<Scalars['uuid']['input']>;
  styleId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "components" */
export enum ApplicationComponent_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  CriticalLevelId = 'criticalLevelId',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  FailoverTypeId = 'failoverTypeId',
  /** column name */
  Id = 'id',
  /** column name */
  LicenseTypeId = 'licenseTypeId',
  /** column name */
  MonitoringLevelId = 'monitoringLevelId',
  /** column name */
  Name = 'name',
  /** column name */
  RecoveryTimeId = 'recoveryTimeId',
  /** column name */
  RedundancyTypeId = 'redundancyTypeId',
  /** column name */
  ScalingTypeId = 'scalingTypeId',
  /** column name */
  StateId = 'stateId',
  /** column name */
  StyleId = 'styleId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type ApplicationComponent_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ApplicationComponent_Set_Input>;
  /** filter the rows which have to be updated */
  where: ApplicationComponent_Bool_Exp;
};

/** columns and relationships of "map_application_function_data_object" */
export type ApplicationFunctionDataObjectMap = {
  __typename?: 'ApplicationFunctionDataObjectMap';
  accessKind: Scalars['data_access_kind_enum']['output'];
  /** An object relationship */
  component: ApplicationComponent;
  componentId: Scalars['uuid']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  dataObject: DataObject;
  dataObjectId: Scalars['uuid']['output'];
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  functionId: Scalars['uuid']['output'];
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "map_application_function_data_object" */
export type ApplicationFunctionDataObjectMap_Aggregate = {
  __typename?: 'ApplicationFunctionDataObjectMap_aggregate';
  aggregate?: Maybe<ApplicationFunctionDataObjectMap_Aggregate_Fields>;
  nodes: Array<ApplicationFunctionDataObjectMap>;
};

export type ApplicationFunctionDataObjectMap_Aggregate_Bool_Exp = {
  count?: InputMaybe<ApplicationFunctionDataObjectMap_Aggregate_Bool_Exp_Count>;
};

export type ApplicationFunctionDataObjectMap_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<ApplicationFunctionDataObjectMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ApplicationFunctionDataObjectMap_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "map_application_function_data_object" */
export type ApplicationFunctionDataObjectMap_Aggregate_Fields = {
  __typename?: 'ApplicationFunctionDataObjectMap_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<ApplicationFunctionDataObjectMap_Max_Fields>;
  min?: Maybe<ApplicationFunctionDataObjectMap_Min_Fields>;
};


/** aggregate fields of "map_application_function_data_object" */
export type ApplicationFunctionDataObjectMap_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<ApplicationFunctionDataObjectMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "map_application_function_data_object" */
export type ApplicationFunctionDataObjectMap_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<ApplicationFunctionDataObjectMap_Max_Order_By>;
  min?: InputMaybe<ApplicationFunctionDataObjectMap_Min_Order_By>;
};

/** input type for inserting array relation for remote table "map_application_function_data_object" */
export type ApplicationFunctionDataObjectMap_Arr_Rel_Insert_Input = {
  data: Array<ApplicationFunctionDataObjectMap_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<ApplicationFunctionDataObjectMap_On_Conflict>;
};

/** Boolean expression to filter rows from the table "map_application_function_data_object". All fields are combined with a logical 'AND'. */
export type ApplicationFunctionDataObjectMap_Bool_Exp = {
  _and?: InputMaybe<Array<ApplicationFunctionDataObjectMap_Bool_Exp>>;
  _not?: InputMaybe<ApplicationFunctionDataObjectMap_Bool_Exp>;
  _or?: InputMaybe<Array<ApplicationFunctionDataObjectMap_Bool_Exp>>;
  accessKind?: InputMaybe<Data_Access_Kind_Enum_Comparison_Exp>;
  component?: InputMaybe<ApplicationComponent_Bool_Exp>;
  componentId?: InputMaybe<Uuid_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  dataObject?: InputMaybe<DataObject_Bool_Exp>;
  dataObjectId?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  functionId?: InputMaybe<Uuid_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "map_application_function_data_object" */
export enum ApplicationFunctionDataObjectMap_Constraint {
  /** unique or primary key constraint on columns "data_object_id", "component_id", "function_id" */
  MapApplicationFunctionDataObjectPkey = 'map_application_function_data_object_pkey'
}

/** input type for inserting data into table "map_application_function_data_object" */
export type ApplicationFunctionDataObjectMap_Insert_Input = {
  accessKind?: InputMaybe<Scalars['data_access_kind_enum']['input']>;
  component?: InputMaybe<ApplicationComponent_Obj_Rel_Insert_Input>;
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  dataObject?: InputMaybe<DataObject_Obj_Rel_Insert_Input>;
  dataObjectId?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  functionId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type ApplicationFunctionDataObjectMap_Max_Fields = {
  __typename?: 'ApplicationFunctionDataObjectMap_max_fields';
  accessKind?: Maybe<Scalars['data_access_kind_enum']['output']>;
  componentId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  dataObjectId?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  functionId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "map_application_function_data_object" */
export type ApplicationFunctionDataObjectMap_Max_Order_By = {
  accessKind?: InputMaybe<Order_By>;
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  dataObjectId?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  functionId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type ApplicationFunctionDataObjectMap_Min_Fields = {
  __typename?: 'ApplicationFunctionDataObjectMap_min_fields';
  accessKind?: Maybe<Scalars['data_access_kind_enum']['output']>;
  componentId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  dataObjectId?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  functionId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "map_application_function_data_object" */
export type ApplicationFunctionDataObjectMap_Min_Order_By = {
  accessKind?: InputMaybe<Order_By>;
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  dataObjectId?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  functionId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "map_application_function_data_object" */
export type ApplicationFunctionDataObjectMap_Mutation_Response = {
  __typename?: 'ApplicationFunctionDataObjectMap_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<ApplicationFunctionDataObjectMap>;
};

/** on_conflict condition type for table "map_application_function_data_object" */
export type ApplicationFunctionDataObjectMap_On_Conflict = {
  constraint: ApplicationFunctionDataObjectMap_Constraint;
  update_columns?: Array<ApplicationFunctionDataObjectMap_Update_Column>;
  where?: InputMaybe<ApplicationFunctionDataObjectMap_Bool_Exp>;
};

/** Ordering options when selecting data from "map_application_function_data_object". */
export type ApplicationFunctionDataObjectMap_Order_By = {
  accessKind?: InputMaybe<Order_By>;
  component?: InputMaybe<ApplicationComponent_Order_By>;
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  dataObject?: InputMaybe<DataObject_Order_By>;
  dataObjectId?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  functionId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: map_application_function_data_object */
export type ApplicationFunctionDataObjectMap_Pk_Columns_Input = {
  componentId: Scalars['uuid']['input'];
  dataObjectId: Scalars['uuid']['input'];
  functionId: Scalars['uuid']['input'];
};

/** select columns of table "map_application_function_data_object" */
export enum ApplicationFunctionDataObjectMap_Select_Column {
  /** column name */
  AccessKind = 'accessKind',
  /** column name */
  ComponentId = 'componentId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DataObjectId = 'dataObjectId',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  FunctionId = 'functionId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "map_application_function_data_object" */
export type ApplicationFunctionDataObjectMap_Set_Input = {
  accessKind?: InputMaybe<Scalars['data_access_kind_enum']['input']>;
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  dataObjectId?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  functionId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "ApplicationFunctionDataObjectMap" */
export type ApplicationFunctionDataObjectMap_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: ApplicationFunctionDataObjectMap_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type ApplicationFunctionDataObjectMap_Stream_Cursor_Value_Input = {
  accessKind?: InputMaybe<Scalars['data_access_kind_enum']['input']>;
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  dataObjectId?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  functionId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "map_application_function_data_object" */
export enum ApplicationFunctionDataObjectMap_Update_Column {
  /** column name */
  AccessKind = 'accessKind',
  /** column name */
  ComponentId = 'componentId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DataObjectId = 'dataObjectId',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  FunctionId = 'functionId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type ApplicationFunctionDataObjectMap_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ApplicationFunctionDataObjectMap_Set_Input>;
  /** filter the rows which have to be updated */
  where: ApplicationFunctionDataObjectMap_Bool_Exp;
};

/** columns and relationships of "map_application_interface_function" */
export type ApplicationFunctionInterfaceMap = {
  __typename?: 'ApplicationFunctionInterfaceMap';
  componentId: Scalars['uuid']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  functionId: Scalars['uuid']['output'];
  /** An object relationship */
  interface: InterfaceGeneric;
  interfaceId: Scalars['uuid']['output'];
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "map_application_interface_function" */
export type ApplicationFunctionInterfaceMap_Aggregate = {
  __typename?: 'ApplicationFunctionInterfaceMap_aggregate';
  aggregate?: Maybe<ApplicationFunctionInterfaceMap_Aggregate_Fields>;
  nodes: Array<ApplicationFunctionInterfaceMap>;
};

export type ApplicationFunctionInterfaceMap_Aggregate_Bool_Exp = {
  count?: InputMaybe<ApplicationFunctionInterfaceMap_Aggregate_Bool_Exp_Count>;
};

export type ApplicationFunctionInterfaceMap_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<ApplicationFunctionInterfaceMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<ApplicationFunctionInterfaceMap_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "map_application_interface_function" */
export type ApplicationFunctionInterfaceMap_Aggregate_Fields = {
  __typename?: 'ApplicationFunctionInterfaceMap_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<ApplicationFunctionInterfaceMap_Max_Fields>;
  min?: Maybe<ApplicationFunctionInterfaceMap_Min_Fields>;
};


/** aggregate fields of "map_application_interface_function" */
export type ApplicationFunctionInterfaceMap_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<ApplicationFunctionInterfaceMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "map_application_interface_function" */
export type ApplicationFunctionInterfaceMap_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<ApplicationFunctionInterfaceMap_Max_Order_By>;
  min?: InputMaybe<ApplicationFunctionInterfaceMap_Min_Order_By>;
};

/** input type for inserting array relation for remote table "map_application_interface_function" */
export type ApplicationFunctionInterfaceMap_Arr_Rel_Insert_Input = {
  data: Array<ApplicationFunctionInterfaceMap_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<ApplicationFunctionInterfaceMap_On_Conflict>;
};

/** Boolean expression to filter rows from the table "map_application_interface_function". All fields are combined with a logical 'AND'. */
export type ApplicationFunctionInterfaceMap_Bool_Exp = {
  _and?: InputMaybe<Array<ApplicationFunctionInterfaceMap_Bool_Exp>>;
  _not?: InputMaybe<ApplicationFunctionInterfaceMap_Bool_Exp>;
  _or?: InputMaybe<Array<ApplicationFunctionInterfaceMap_Bool_Exp>>;
  componentId?: InputMaybe<Uuid_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  functionId?: InputMaybe<Uuid_Comparison_Exp>;
  interface?: InputMaybe<InterfaceGeneric_Bool_Exp>;
  interfaceId?: InputMaybe<Uuid_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "map_application_interface_function" */
export enum ApplicationFunctionInterfaceMap_Constraint {
  /** unique or primary key constraint on columns "interface_id", "component_id", "function_id" */
  MapApplicationInterfaceFunctionPkey = 'map_application_interface_function_pkey'
}

/** input type for inserting data into table "map_application_interface_function" */
export type ApplicationFunctionInterfaceMap_Insert_Input = {
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  functionId?: InputMaybe<Scalars['uuid']['input']>;
  interface?: InputMaybe<InterfaceGeneric_Obj_Rel_Insert_Input>;
  interfaceId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type ApplicationFunctionInterfaceMap_Max_Fields = {
  __typename?: 'ApplicationFunctionInterfaceMap_max_fields';
  componentId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  functionId?: Maybe<Scalars['uuid']['output']>;
  interfaceId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "map_application_interface_function" */
export type ApplicationFunctionInterfaceMap_Max_Order_By = {
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  functionId?: InputMaybe<Order_By>;
  interfaceId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type ApplicationFunctionInterfaceMap_Min_Fields = {
  __typename?: 'ApplicationFunctionInterfaceMap_min_fields';
  componentId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  functionId?: Maybe<Scalars['uuid']['output']>;
  interfaceId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "map_application_interface_function" */
export type ApplicationFunctionInterfaceMap_Min_Order_By = {
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  functionId?: InputMaybe<Order_By>;
  interfaceId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "map_application_interface_function" */
export type ApplicationFunctionInterfaceMap_Mutation_Response = {
  __typename?: 'ApplicationFunctionInterfaceMap_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<ApplicationFunctionInterfaceMap>;
};

/** on_conflict condition type for table "map_application_interface_function" */
export type ApplicationFunctionInterfaceMap_On_Conflict = {
  constraint: ApplicationFunctionInterfaceMap_Constraint;
  update_columns?: Array<ApplicationFunctionInterfaceMap_Update_Column>;
  where?: InputMaybe<ApplicationFunctionInterfaceMap_Bool_Exp>;
};

/** Ordering options when selecting data from "map_application_interface_function". */
export type ApplicationFunctionInterfaceMap_Order_By = {
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  functionId?: InputMaybe<Order_By>;
  interface?: InputMaybe<InterfaceGeneric_Order_By>;
  interfaceId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: map_application_interface_function */
export type ApplicationFunctionInterfaceMap_Pk_Columns_Input = {
  componentId: Scalars['uuid']['input'];
  functionId: Scalars['uuid']['input'];
  interfaceId: Scalars['uuid']['input'];
};

/** select columns of table "map_application_interface_function" */
export enum ApplicationFunctionInterfaceMap_Select_Column {
  /** column name */
  ComponentId = 'componentId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  FunctionId = 'functionId',
  /** column name */
  InterfaceId = 'interfaceId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "map_application_interface_function" */
export type ApplicationFunctionInterfaceMap_Set_Input = {
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  functionId?: InputMaybe<Scalars['uuid']['input']>;
  interfaceId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "ApplicationFunctionInterfaceMap" */
export type ApplicationFunctionInterfaceMap_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: ApplicationFunctionInterfaceMap_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type ApplicationFunctionInterfaceMap_Stream_Cursor_Value_Input = {
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  functionId?: InputMaybe<Scalars['uuid']['input']>;
  interfaceId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "map_application_interface_function" */
export enum ApplicationFunctionInterfaceMap_Update_Column {
  /** column name */
  ComponentId = 'componentId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  FunctionId = 'functionId',
  /** column name */
  InterfaceId = 'interfaceId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type ApplicationFunctionInterfaceMap_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ApplicationFunctionInterfaceMap_Set_Input>;
  /** filter the rows which have to be updated */
  where: ApplicationFunctionInterfaceMap_Bool_Exp;
};

/** Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'. */
export type Boolean_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['Boolean']['input']>;
  _gt?: InputMaybe<Scalars['Boolean']['input']>;
  _gte?: InputMaybe<Scalars['Boolean']['input']>;
  _in?: InputMaybe<Array<Scalars['Boolean']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['Boolean']['input']>;
  _lte?: InputMaybe<Scalars['Boolean']['input']>;
  _neq?: InputMaybe<Scalars['Boolean']['input']>;
  _nin?: InputMaybe<Array<Scalars['Boolean']['input']>>;
};

/** columns and relationships of "actors" */
export type BusinessActor = {
  __typename?: 'BusinessActor';
  code: Scalars['String']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['uuid']['output'];
  name: Scalars['String']['output'];
  /** An array relationship */
  roles: Array<BusinessActorRoleMap>;
  /** An aggregate relationship */
  roles_aggregate: BusinessActorRoleMap_Aggregate;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};


/** columns and relationships of "actors" */
export type BusinessActorRolesArgs = {
  distinct_on?: InputMaybe<Array<BusinessActorRoleMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessActorRoleMap_Order_By>>;
  where?: InputMaybe<BusinessActorRoleMap_Bool_Exp>;
};


/** columns and relationships of "actors" */
export type BusinessActorRoles_AggregateArgs = {
  distinct_on?: InputMaybe<Array<BusinessActorRoleMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessActorRoleMap_Order_By>>;
  where?: InputMaybe<BusinessActorRoleMap_Bool_Exp>;
};

/** columns and relationships of "map_business_actor_role" */
export type BusinessActorRoleMap = {
  __typename?: 'BusinessActorRoleMap';
  /** An object relationship */
  actor: BusinessActor;
  actorId: Scalars['uuid']['output'];
  /** An array relationship */
  components: Array<ApplicationComponentBusinessActorRoleMap>;
  /** An aggregate relationship */
  components_aggregate: ApplicationComponentBusinessActorRoleMap_Aggregate;
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  role: BusinessRole;
  roleId: Scalars['uuid']['output'];
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};


/** columns and relationships of "map_business_actor_role" */
export type BusinessActorRoleMapComponentsArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentBusinessActorRoleMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentBusinessActorRoleMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentBusinessActorRoleMap_Bool_Exp>;
};


/** columns and relationships of "map_business_actor_role" */
export type BusinessActorRoleMapComponents_AggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentBusinessActorRoleMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentBusinessActorRoleMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentBusinessActorRoleMap_Bool_Exp>;
};

/** aggregated selection of "map_business_actor_role" */
export type BusinessActorRoleMap_Aggregate = {
  __typename?: 'BusinessActorRoleMap_aggregate';
  aggregate?: Maybe<BusinessActorRoleMap_Aggregate_Fields>;
  nodes: Array<BusinessActorRoleMap>;
};

export type BusinessActorRoleMap_Aggregate_Bool_Exp = {
  count?: InputMaybe<BusinessActorRoleMap_Aggregate_Bool_Exp_Count>;
};

export type BusinessActorRoleMap_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<BusinessActorRoleMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<BusinessActorRoleMap_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "map_business_actor_role" */
export type BusinessActorRoleMap_Aggregate_Fields = {
  __typename?: 'BusinessActorRoleMap_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<BusinessActorRoleMap_Max_Fields>;
  min?: Maybe<BusinessActorRoleMap_Min_Fields>;
};


/** aggregate fields of "map_business_actor_role" */
export type BusinessActorRoleMap_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<BusinessActorRoleMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "map_business_actor_role" */
export type BusinessActorRoleMap_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<BusinessActorRoleMap_Max_Order_By>;
  min?: InputMaybe<BusinessActorRoleMap_Min_Order_By>;
};

/** input type for inserting array relation for remote table "map_business_actor_role" */
export type BusinessActorRoleMap_Arr_Rel_Insert_Input = {
  data: Array<BusinessActorRoleMap_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<BusinessActorRoleMap_On_Conflict>;
};

/** Boolean expression to filter rows from the table "map_business_actor_role". All fields are combined with a logical 'AND'. */
export type BusinessActorRoleMap_Bool_Exp = {
  _and?: InputMaybe<Array<BusinessActorRoleMap_Bool_Exp>>;
  _not?: InputMaybe<BusinessActorRoleMap_Bool_Exp>;
  _or?: InputMaybe<Array<BusinessActorRoleMap_Bool_Exp>>;
  actor?: InputMaybe<BusinessActor_Bool_Exp>;
  actorId?: InputMaybe<Uuid_Comparison_Exp>;
  components?: InputMaybe<ApplicationComponentBusinessActorRoleMap_Bool_Exp>;
  components_aggregate?: InputMaybe<ApplicationComponentBusinessActorRoleMap_Aggregate_Bool_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  role?: InputMaybe<BusinessRole_Bool_Exp>;
  roleId?: InputMaybe<Uuid_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "map_business_actor_role" */
export enum BusinessActorRoleMap_Constraint {
  /** unique or primary key constraint on columns "actor_id", "role_id" */
  MapBusinessActorRoleActorIdRoleIdUnique = 'map_business_actor_role_actor_id_role_id_unique',
  /** unique or primary key constraint on columns "actor_id", "role_id" */
  MapBusinessActorRolePkey = 'map_business_actor_role_pkey'
}

/** input type for inserting data into table "map_business_actor_role" */
export type BusinessActorRoleMap_Insert_Input = {
  actor?: InputMaybe<BusinessActor_Obj_Rel_Insert_Input>;
  actorId?: InputMaybe<Scalars['uuid']['input']>;
  components?: InputMaybe<ApplicationComponentBusinessActorRoleMap_Arr_Rel_Insert_Input>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  role?: InputMaybe<BusinessRole_Obj_Rel_Insert_Input>;
  roleId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type BusinessActorRoleMap_Max_Fields = {
  __typename?: 'BusinessActorRoleMap_max_fields';
  actorId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  roleId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "map_business_actor_role" */
export type BusinessActorRoleMap_Max_Order_By = {
  actorId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  roleId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type BusinessActorRoleMap_Min_Fields = {
  __typename?: 'BusinessActorRoleMap_min_fields';
  actorId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  roleId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "map_business_actor_role" */
export type BusinessActorRoleMap_Min_Order_By = {
  actorId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  roleId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "map_business_actor_role" */
export type BusinessActorRoleMap_Mutation_Response = {
  __typename?: 'BusinessActorRoleMap_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<BusinessActorRoleMap>;
};

/** on_conflict condition type for table "map_business_actor_role" */
export type BusinessActorRoleMap_On_Conflict = {
  constraint: BusinessActorRoleMap_Constraint;
  update_columns?: Array<BusinessActorRoleMap_Update_Column>;
  where?: InputMaybe<BusinessActorRoleMap_Bool_Exp>;
};

/** Ordering options when selecting data from "map_business_actor_role". */
export type BusinessActorRoleMap_Order_By = {
  actor?: InputMaybe<BusinessActor_Order_By>;
  actorId?: InputMaybe<Order_By>;
  components_aggregate?: InputMaybe<ApplicationComponentBusinessActorRoleMap_Aggregate_Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  role?: InputMaybe<BusinessRole_Order_By>;
  roleId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: map_business_actor_role */
export type BusinessActorRoleMap_Pk_Columns_Input = {
  actorId: Scalars['uuid']['input'];
  roleId: Scalars['uuid']['input'];
};

/** select columns of table "map_business_actor_role" */
export enum BusinessActorRoleMap_Select_Column {
  /** column name */
  ActorId = 'actorId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  RoleId = 'roleId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "map_business_actor_role" */
export type BusinessActorRoleMap_Set_Input = {
  actorId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  roleId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "BusinessActorRoleMap" */
export type BusinessActorRoleMap_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: BusinessActorRoleMap_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type BusinessActorRoleMap_Stream_Cursor_Value_Input = {
  actorId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  roleId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "map_business_actor_role" */
export enum BusinessActorRoleMap_Update_Column {
  /** column name */
  ActorId = 'actorId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  RoleId = 'roleId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type BusinessActorRoleMap_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<BusinessActorRoleMap_Set_Input>;
  /** filter the rows which have to be updated */
  where: BusinessActorRoleMap_Bool_Exp;
};

/** aggregated selection of "actors" */
export type BusinessActor_Aggregate = {
  __typename?: 'BusinessActor_aggregate';
  aggregate?: Maybe<BusinessActor_Aggregate_Fields>;
  nodes: Array<BusinessActor>;
};

/** aggregate fields of "actors" */
export type BusinessActor_Aggregate_Fields = {
  __typename?: 'BusinessActor_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<BusinessActor_Max_Fields>;
  min?: Maybe<BusinessActor_Min_Fields>;
};


/** aggregate fields of "actors" */
export type BusinessActor_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<BusinessActor_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "actors". All fields are combined with a logical 'AND'. */
export type BusinessActor_Bool_Exp = {
  _and?: InputMaybe<Array<BusinessActor_Bool_Exp>>;
  _not?: InputMaybe<BusinessActor_Bool_Exp>;
  _or?: InputMaybe<Array<BusinessActor_Bool_Exp>>;
  code?: InputMaybe<String_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  roles?: InputMaybe<BusinessActorRoleMap_Bool_Exp>;
  roles_aggregate?: InputMaybe<BusinessActorRoleMap_Aggregate_Bool_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "actors" */
export enum BusinessActor_Constraint {
  /** unique or primary key constraint on columns "code" */
  ActorsCodeUnique = 'actors_code_unique',
  /** unique or primary key constraint on columns "id" */
  ActorsPkey = 'actors_pkey'
}

/** input type for inserting data into table "actors" */
export type BusinessActor_Insert_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  roles?: InputMaybe<BusinessActorRoleMap_Arr_Rel_Insert_Input>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type BusinessActor_Max_Fields = {
  __typename?: 'BusinessActor_max_fields';
  code?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type BusinessActor_Min_Fields = {
  __typename?: 'BusinessActor_min_fields';
  code?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "actors" */
export type BusinessActor_Mutation_Response = {
  __typename?: 'BusinessActor_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<BusinessActor>;
};

/** input type for inserting object relation for remote table "actors" */
export type BusinessActor_Obj_Rel_Insert_Input = {
  data: BusinessActor_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<BusinessActor_On_Conflict>;
};

/** on_conflict condition type for table "actors" */
export type BusinessActor_On_Conflict = {
  constraint: BusinessActor_Constraint;
  update_columns?: Array<BusinessActor_Update_Column>;
  where?: InputMaybe<BusinessActor_Bool_Exp>;
};

/** Ordering options when selecting data from "actors". */
export type BusinessActor_Order_By = {
  code?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  roles_aggregate?: InputMaybe<BusinessActorRoleMap_Aggregate_Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: actors */
export type BusinessActor_Pk_Columns_Input = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "actors" */
export enum BusinessActor_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "actors" */
export type BusinessActor_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "BusinessActor" */
export type BusinessActor_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: BusinessActor_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type BusinessActor_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "actors" */
export enum BusinessActor_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type BusinessActor_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<BusinessActor_Set_Input>;
  /** filter the rows which have to be updated */
  where: BusinessActor_Bool_Exp;
};

/** columns and relationships of "map_business_process_function" */
export type BusinessProcessFunctionMap = {
  __typename?: 'BusinessProcessFunctionMap';
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  function: FunctionGeneric;
  functionId: Scalars['uuid']['output'];
  /** An object relationship */
  process: ProcessGeneric;
  processId: Scalars['uuid']['output'];
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "map_business_process_function" */
export type BusinessProcessFunctionMap_Aggregate = {
  __typename?: 'BusinessProcessFunctionMap_aggregate';
  aggregate?: Maybe<BusinessProcessFunctionMap_Aggregate_Fields>;
  nodes: Array<BusinessProcessFunctionMap>;
};

export type BusinessProcessFunctionMap_Aggregate_Bool_Exp = {
  count?: InputMaybe<BusinessProcessFunctionMap_Aggregate_Bool_Exp_Count>;
};

export type BusinessProcessFunctionMap_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<BusinessProcessFunctionMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<BusinessProcessFunctionMap_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "map_business_process_function" */
export type BusinessProcessFunctionMap_Aggregate_Fields = {
  __typename?: 'BusinessProcessFunctionMap_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<BusinessProcessFunctionMap_Max_Fields>;
  min?: Maybe<BusinessProcessFunctionMap_Min_Fields>;
};


/** aggregate fields of "map_business_process_function" */
export type BusinessProcessFunctionMap_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<BusinessProcessFunctionMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "map_business_process_function" */
export type BusinessProcessFunctionMap_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<BusinessProcessFunctionMap_Max_Order_By>;
  min?: InputMaybe<BusinessProcessFunctionMap_Min_Order_By>;
};

/** input type for inserting array relation for remote table "map_business_process_function" */
export type BusinessProcessFunctionMap_Arr_Rel_Insert_Input = {
  data: Array<BusinessProcessFunctionMap_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<BusinessProcessFunctionMap_On_Conflict>;
};

/** Boolean expression to filter rows from the table "map_business_process_function". All fields are combined with a logical 'AND'. */
export type BusinessProcessFunctionMap_Bool_Exp = {
  _and?: InputMaybe<Array<BusinessProcessFunctionMap_Bool_Exp>>;
  _not?: InputMaybe<BusinessProcessFunctionMap_Bool_Exp>;
  _or?: InputMaybe<Array<BusinessProcessFunctionMap_Bool_Exp>>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  function?: InputMaybe<FunctionGeneric_Bool_Exp>;
  functionId?: InputMaybe<Uuid_Comparison_Exp>;
  process?: InputMaybe<ProcessGeneric_Bool_Exp>;
  processId?: InputMaybe<Uuid_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "map_business_process_function" */
export enum BusinessProcessFunctionMap_Constraint {
  /** unique or primary key constraint on columns "function_id", "process_id" */
  MapBusinessProcessFunctionPkey = 'map_business_process_function_pkey'
}

/** input type for inserting data into table "map_business_process_function" */
export type BusinessProcessFunctionMap_Insert_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  function?: InputMaybe<FunctionGeneric_Obj_Rel_Insert_Input>;
  functionId?: InputMaybe<Scalars['uuid']['input']>;
  process?: InputMaybe<ProcessGeneric_Obj_Rel_Insert_Input>;
  processId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type BusinessProcessFunctionMap_Max_Fields = {
  __typename?: 'BusinessProcessFunctionMap_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  functionId?: Maybe<Scalars['uuid']['output']>;
  processId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "map_business_process_function" */
export type BusinessProcessFunctionMap_Max_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  functionId?: InputMaybe<Order_By>;
  processId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type BusinessProcessFunctionMap_Min_Fields = {
  __typename?: 'BusinessProcessFunctionMap_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  functionId?: Maybe<Scalars['uuid']['output']>;
  processId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "map_business_process_function" */
export type BusinessProcessFunctionMap_Min_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  functionId?: InputMaybe<Order_By>;
  processId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "map_business_process_function" */
export type BusinessProcessFunctionMap_Mutation_Response = {
  __typename?: 'BusinessProcessFunctionMap_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<BusinessProcessFunctionMap>;
};

/** on_conflict condition type for table "map_business_process_function" */
export type BusinessProcessFunctionMap_On_Conflict = {
  constraint: BusinessProcessFunctionMap_Constraint;
  update_columns?: Array<BusinessProcessFunctionMap_Update_Column>;
  where?: InputMaybe<BusinessProcessFunctionMap_Bool_Exp>;
};

/** Ordering options when selecting data from "map_business_process_function". */
export type BusinessProcessFunctionMap_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  function?: InputMaybe<FunctionGeneric_Order_By>;
  functionId?: InputMaybe<Order_By>;
  process?: InputMaybe<ProcessGeneric_Order_By>;
  processId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: map_business_process_function */
export type BusinessProcessFunctionMap_Pk_Columns_Input = {
  functionId: Scalars['uuid']['input'];
  processId: Scalars['uuid']['input'];
};

/** select columns of table "map_business_process_function" */
export enum BusinessProcessFunctionMap_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  FunctionId = 'functionId',
  /** column name */
  ProcessId = 'processId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "map_business_process_function" */
export type BusinessProcessFunctionMap_Set_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  functionId?: InputMaybe<Scalars['uuid']['input']>;
  processId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "BusinessProcessFunctionMap" */
export type BusinessProcessFunctionMap_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: BusinessProcessFunctionMap_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type BusinessProcessFunctionMap_Stream_Cursor_Value_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  functionId?: InputMaybe<Scalars['uuid']['input']>;
  processId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "map_business_process_function" */
export enum BusinessProcessFunctionMap_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  FunctionId = 'functionId',
  /** column name */
  ProcessId = 'processId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type BusinessProcessFunctionMap_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<BusinessProcessFunctionMap_Set_Input>;
  /** filter the rows which have to be updated */
  where: BusinessProcessFunctionMap_Bool_Exp;
};

/** columns and relationships of "map_business_process_hierarchy" */
export type BusinessProcessHierarchyMap = {
  __typename?: 'BusinessProcessHierarchyMap';
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  processChild: ProcessGeneric;
  processChildId: Scalars['uuid']['output'];
  /** An object relationship */
  processParent: ProcessGeneric;
  processParentId: Scalars['uuid']['output'];
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "map_business_process_hierarchy" */
export type BusinessProcessHierarchyMap_Aggregate = {
  __typename?: 'BusinessProcessHierarchyMap_aggregate';
  aggregate?: Maybe<BusinessProcessHierarchyMap_Aggregate_Fields>;
  nodes: Array<BusinessProcessHierarchyMap>;
};

export type BusinessProcessHierarchyMap_Aggregate_Bool_Exp = {
  count?: InputMaybe<BusinessProcessHierarchyMap_Aggregate_Bool_Exp_Count>;
};

export type BusinessProcessHierarchyMap_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<BusinessProcessHierarchyMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<BusinessProcessHierarchyMap_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "map_business_process_hierarchy" */
export type BusinessProcessHierarchyMap_Aggregate_Fields = {
  __typename?: 'BusinessProcessHierarchyMap_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<BusinessProcessHierarchyMap_Max_Fields>;
  min?: Maybe<BusinessProcessHierarchyMap_Min_Fields>;
};


/** aggregate fields of "map_business_process_hierarchy" */
export type BusinessProcessHierarchyMap_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<BusinessProcessHierarchyMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "map_business_process_hierarchy" */
export type BusinessProcessHierarchyMap_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<BusinessProcessHierarchyMap_Max_Order_By>;
  min?: InputMaybe<BusinessProcessHierarchyMap_Min_Order_By>;
};

/** input type for inserting array relation for remote table "map_business_process_hierarchy" */
export type BusinessProcessHierarchyMap_Arr_Rel_Insert_Input = {
  data: Array<BusinessProcessHierarchyMap_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<BusinessProcessHierarchyMap_On_Conflict>;
};

/** Boolean expression to filter rows from the table "map_business_process_hierarchy". All fields are combined with a logical 'AND'. */
export type BusinessProcessHierarchyMap_Bool_Exp = {
  _and?: InputMaybe<Array<BusinessProcessHierarchyMap_Bool_Exp>>;
  _not?: InputMaybe<BusinessProcessHierarchyMap_Bool_Exp>;
  _or?: InputMaybe<Array<BusinessProcessHierarchyMap_Bool_Exp>>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  processChild?: InputMaybe<ProcessGeneric_Bool_Exp>;
  processChildId?: InputMaybe<Uuid_Comparison_Exp>;
  processParent?: InputMaybe<ProcessGeneric_Bool_Exp>;
  processParentId?: InputMaybe<Uuid_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "map_business_process_hierarchy" */
export enum BusinessProcessHierarchyMap_Constraint {
  /** unique or primary key constraint on columns "process_child_id", "process_parent_id" */
  MapBusinessProcessHierarchyPkey = 'map_business_process_hierarchy_pkey'
}

/** input type for inserting data into table "map_business_process_hierarchy" */
export type BusinessProcessHierarchyMap_Insert_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  processChild?: InputMaybe<ProcessGeneric_Obj_Rel_Insert_Input>;
  processChildId?: InputMaybe<Scalars['uuid']['input']>;
  processParent?: InputMaybe<ProcessGeneric_Obj_Rel_Insert_Input>;
  processParentId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type BusinessProcessHierarchyMap_Max_Fields = {
  __typename?: 'BusinessProcessHierarchyMap_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  processChildId?: Maybe<Scalars['uuid']['output']>;
  processParentId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "map_business_process_hierarchy" */
export type BusinessProcessHierarchyMap_Max_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  processChildId?: InputMaybe<Order_By>;
  processParentId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type BusinessProcessHierarchyMap_Min_Fields = {
  __typename?: 'BusinessProcessHierarchyMap_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  processChildId?: Maybe<Scalars['uuid']['output']>;
  processParentId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "map_business_process_hierarchy" */
export type BusinessProcessHierarchyMap_Min_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  processChildId?: InputMaybe<Order_By>;
  processParentId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "map_business_process_hierarchy" */
export type BusinessProcessHierarchyMap_Mutation_Response = {
  __typename?: 'BusinessProcessHierarchyMap_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<BusinessProcessHierarchyMap>;
};

/** on_conflict condition type for table "map_business_process_hierarchy" */
export type BusinessProcessHierarchyMap_On_Conflict = {
  constraint: BusinessProcessHierarchyMap_Constraint;
  update_columns?: Array<BusinessProcessHierarchyMap_Update_Column>;
  where?: InputMaybe<BusinessProcessHierarchyMap_Bool_Exp>;
};

/** Ordering options when selecting data from "map_business_process_hierarchy". */
export type BusinessProcessHierarchyMap_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  processChild?: InputMaybe<ProcessGeneric_Order_By>;
  processChildId?: InputMaybe<Order_By>;
  processParent?: InputMaybe<ProcessGeneric_Order_By>;
  processParentId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: map_business_process_hierarchy */
export type BusinessProcessHierarchyMap_Pk_Columns_Input = {
  processChildId: Scalars['uuid']['input'];
  processParentId: Scalars['uuid']['input'];
};

/** select columns of table "map_business_process_hierarchy" */
export enum BusinessProcessHierarchyMap_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  ProcessChildId = 'processChildId',
  /** column name */
  ProcessParentId = 'processParentId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "map_business_process_hierarchy" */
export type BusinessProcessHierarchyMap_Set_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  processChildId?: InputMaybe<Scalars['uuid']['input']>;
  processParentId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "BusinessProcessHierarchyMap" */
export type BusinessProcessHierarchyMap_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: BusinessProcessHierarchyMap_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type BusinessProcessHierarchyMap_Stream_Cursor_Value_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  processChildId?: InputMaybe<Scalars['uuid']['input']>;
  processParentId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "map_business_process_hierarchy" */
export enum BusinessProcessHierarchyMap_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  ProcessChildId = 'processChildId',
  /** column name */
  ProcessParentId = 'processParentId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type BusinessProcessHierarchyMap_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<BusinessProcessHierarchyMap_Set_Input>;
  /** filter the rows which have to be updated */
  where: BusinessProcessHierarchyMap_Bool_Exp;
};

/** columns and relationships of "map_business_process_motivation_item" */
export type BusinessProcessMotivationItemMap = {
  __typename?: 'BusinessProcessMotivationItemMap';
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  motivation: MotivationElementGeneric;
  motivationId: Scalars['uuid']['output'];
  /** An object relationship */
  process: ProcessGeneric;
  processId: Scalars['uuid']['output'];
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "map_business_process_motivation_item" */
export type BusinessProcessMotivationItemMap_Aggregate = {
  __typename?: 'BusinessProcessMotivationItemMap_aggregate';
  aggregate?: Maybe<BusinessProcessMotivationItemMap_Aggregate_Fields>;
  nodes: Array<BusinessProcessMotivationItemMap>;
};

export type BusinessProcessMotivationItemMap_Aggregate_Bool_Exp = {
  count?: InputMaybe<BusinessProcessMotivationItemMap_Aggregate_Bool_Exp_Count>;
};

export type BusinessProcessMotivationItemMap_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<BusinessProcessMotivationItemMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<BusinessProcessMotivationItemMap_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "map_business_process_motivation_item" */
export type BusinessProcessMotivationItemMap_Aggregate_Fields = {
  __typename?: 'BusinessProcessMotivationItemMap_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<BusinessProcessMotivationItemMap_Max_Fields>;
  min?: Maybe<BusinessProcessMotivationItemMap_Min_Fields>;
};


/** aggregate fields of "map_business_process_motivation_item" */
export type BusinessProcessMotivationItemMap_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<BusinessProcessMotivationItemMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "map_business_process_motivation_item" */
export type BusinessProcessMotivationItemMap_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<BusinessProcessMotivationItemMap_Max_Order_By>;
  min?: InputMaybe<BusinessProcessMotivationItemMap_Min_Order_By>;
};

/** input type for inserting array relation for remote table "map_business_process_motivation_item" */
export type BusinessProcessMotivationItemMap_Arr_Rel_Insert_Input = {
  data: Array<BusinessProcessMotivationItemMap_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<BusinessProcessMotivationItemMap_On_Conflict>;
};

/** Boolean expression to filter rows from the table "map_business_process_motivation_item". All fields are combined with a logical 'AND'. */
export type BusinessProcessMotivationItemMap_Bool_Exp = {
  _and?: InputMaybe<Array<BusinessProcessMotivationItemMap_Bool_Exp>>;
  _not?: InputMaybe<BusinessProcessMotivationItemMap_Bool_Exp>;
  _or?: InputMaybe<Array<BusinessProcessMotivationItemMap_Bool_Exp>>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  motivation?: InputMaybe<MotivationElementGeneric_Bool_Exp>;
  motivationId?: InputMaybe<Uuid_Comparison_Exp>;
  process?: InputMaybe<ProcessGeneric_Bool_Exp>;
  processId?: InputMaybe<Uuid_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "map_business_process_motivation_item" */
export enum BusinessProcessMotivationItemMap_Constraint {
  /** unique or primary key constraint on columns "motivation_id", "process_id" */
  MapBusinessProcessMotivationItemPkey = 'map_business_process_motivation_item_pkey'
}

/** input type for inserting data into table "map_business_process_motivation_item" */
export type BusinessProcessMotivationItemMap_Insert_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  motivation?: InputMaybe<MotivationElementGeneric_Obj_Rel_Insert_Input>;
  motivationId?: InputMaybe<Scalars['uuid']['input']>;
  process?: InputMaybe<ProcessGeneric_Obj_Rel_Insert_Input>;
  processId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type BusinessProcessMotivationItemMap_Max_Fields = {
  __typename?: 'BusinessProcessMotivationItemMap_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  motivationId?: Maybe<Scalars['uuid']['output']>;
  processId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "map_business_process_motivation_item" */
export type BusinessProcessMotivationItemMap_Max_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  motivationId?: InputMaybe<Order_By>;
  processId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type BusinessProcessMotivationItemMap_Min_Fields = {
  __typename?: 'BusinessProcessMotivationItemMap_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  motivationId?: Maybe<Scalars['uuid']['output']>;
  processId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "map_business_process_motivation_item" */
export type BusinessProcessMotivationItemMap_Min_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  motivationId?: InputMaybe<Order_By>;
  processId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "map_business_process_motivation_item" */
export type BusinessProcessMotivationItemMap_Mutation_Response = {
  __typename?: 'BusinessProcessMotivationItemMap_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<BusinessProcessMotivationItemMap>;
};

/** on_conflict condition type for table "map_business_process_motivation_item" */
export type BusinessProcessMotivationItemMap_On_Conflict = {
  constraint: BusinessProcessMotivationItemMap_Constraint;
  update_columns?: Array<BusinessProcessMotivationItemMap_Update_Column>;
  where?: InputMaybe<BusinessProcessMotivationItemMap_Bool_Exp>;
};

/** Ordering options when selecting data from "map_business_process_motivation_item". */
export type BusinessProcessMotivationItemMap_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  motivation?: InputMaybe<MotivationElementGeneric_Order_By>;
  motivationId?: InputMaybe<Order_By>;
  process?: InputMaybe<ProcessGeneric_Order_By>;
  processId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: map_business_process_motivation_item */
export type BusinessProcessMotivationItemMap_Pk_Columns_Input = {
  motivationId: Scalars['uuid']['input'];
  processId: Scalars['uuid']['input'];
};

/** select columns of table "map_business_process_motivation_item" */
export enum BusinessProcessMotivationItemMap_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  MotivationId = 'motivationId',
  /** column name */
  ProcessId = 'processId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "map_business_process_motivation_item" */
export type BusinessProcessMotivationItemMap_Set_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  motivationId?: InputMaybe<Scalars['uuid']['input']>;
  processId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "BusinessProcessMotivationItemMap" */
export type BusinessProcessMotivationItemMap_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: BusinessProcessMotivationItemMap_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type BusinessProcessMotivationItemMap_Stream_Cursor_Value_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  motivationId?: InputMaybe<Scalars['uuid']['input']>;
  processId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "map_business_process_motivation_item" */
export enum BusinessProcessMotivationItemMap_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  MotivationId = 'motivationId',
  /** column name */
  ProcessId = 'processId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type BusinessProcessMotivationItemMap_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<BusinessProcessMotivationItemMap_Set_Input>;
  /** filter the rows which have to be updated */
  where: BusinessProcessMotivationItemMap_Bool_Exp;
};

/** columns and relationships of "products" */
export type BusinessProduct = {
  __typename?: 'BusinessProduct';
  code: Scalars['String']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['uuid']['output'];
  name: Scalars['String']['output'];
  ownerId?: Maybe<Scalars['uuid']['output']>;
  /** An array relationship */
  products: Array<ApplicationComponentProductMap>;
  /** An aggregate relationship */
  products_aggregate: ApplicationComponentProductMap_Aggregate;
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};


/** columns and relationships of "products" */
export type BusinessProductProductsArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentProductMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentProductMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentProductMap_Bool_Exp>;
};


/** columns and relationships of "products" */
export type BusinessProductProducts_AggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentProductMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentProductMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentProductMap_Bool_Exp>;
};

/** aggregated selection of "products" */
export type BusinessProduct_Aggregate = {
  __typename?: 'BusinessProduct_aggregate';
  aggregate?: Maybe<BusinessProduct_Aggregate_Fields>;
  nodes: Array<BusinessProduct>;
};

/** aggregate fields of "products" */
export type BusinessProduct_Aggregate_Fields = {
  __typename?: 'BusinessProduct_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<BusinessProduct_Max_Fields>;
  min?: Maybe<BusinessProduct_Min_Fields>;
};


/** aggregate fields of "products" */
export type BusinessProduct_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<BusinessProduct_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "products". All fields are combined with a logical 'AND'. */
export type BusinessProduct_Bool_Exp = {
  _and?: InputMaybe<Array<BusinessProduct_Bool_Exp>>;
  _not?: InputMaybe<BusinessProduct_Bool_Exp>;
  _or?: InputMaybe<Array<BusinessProduct_Bool_Exp>>;
  code?: InputMaybe<String_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  ownerId?: InputMaybe<Uuid_Comparison_Exp>;
  products?: InputMaybe<ApplicationComponentProductMap_Bool_Exp>;
  products_aggregate?: InputMaybe<ApplicationComponentProductMap_Aggregate_Bool_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "products" */
export enum BusinessProduct_Constraint {
  /** unique or primary key constraint on columns "code" */
  ProductsCodeUnique = 'products_code_unique',
  /** unique or primary key constraint on columns "id" */
  ProductsPkey = 'products_pkey'
}

/** input type for inserting data into table "products" */
export type BusinessProduct_Insert_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['uuid']['input']>;
  products?: InputMaybe<ApplicationComponentProductMap_Arr_Rel_Insert_Input>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type BusinessProduct_Max_Fields = {
  __typename?: 'BusinessProduct_max_fields';
  code?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  ownerId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type BusinessProduct_Min_Fields = {
  __typename?: 'BusinessProduct_min_fields';
  code?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  ownerId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "products" */
export type BusinessProduct_Mutation_Response = {
  __typename?: 'BusinessProduct_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<BusinessProduct>;
};

/** input type for inserting object relation for remote table "products" */
export type BusinessProduct_Obj_Rel_Insert_Input = {
  data: BusinessProduct_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<BusinessProduct_On_Conflict>;
};

/** on_conflict condition type for table "products" */
export type BusinessProduct_On_Conflict = {
  constraint: BusinessProduct_Constraint;
  update_columns?: Array<BusinessProduct_Update_Column>;
  where?: InputMaybe<BusinessProduct_Bool_Exp>;
};

/** Ordering options when selecting data from "products". */
export type BusinessProduct_Order_By = {
  code?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  ownerId?: InputMaybe<Order_By>;
  products_aggregate?: InputMaybe<ApplicationComponentProductMap_Aggregate_Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: products */
export type BusinessProduct_Pk_Columns_Input = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "products" */
export enum BusinessProduct_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  OwnerId = 'ownerId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "products" */
export type BusinessProduct_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "BusinessProduct" */
export type BusinessProduct_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: BusinessProduct_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type BusinessProduct_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "products" */
export enum BusinessProduct_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  OwnerId = 'ownerId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type BusinessProduct_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<BusinessProduct_Set_Input>;
  /** filter the rows which have to be updated */
  where: BusinessProduct_Bool_Exp;
};

/** columns and relationships of "roles" */
export type BusinessRole = {
  __typename?: 'BusinessRole';
  /** An array relationship */
  actors: Array<BusinessActorRoleMap>;
  /** An aggregate relationship */
  actors_aggregate: BusinessActorRoleMap_Aggregate;
  code: Scalars['String']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['uuid']['output'];
  name: Scalars['String']['output'];
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};


/** columns and relationships of "roles" */
export type BusinessRoleActorsArgs = {
  distinct_on?: InputMaybe<Array<BusinessActorRoleMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessActorRoleMap_Order_By>>;
  where?: InputMaybe<BusinessActorRoleMap_Bool_Exp>;
};


/** columns and relationships of "roles" */
export type BusinessRoleActors_AggregateArgs = {
  distinct_on?: InputMaybe<Array<BusinessActorRoleMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessActorRoleMap_Order_By>>;
  where?: InputMaybe<BusinessActorRoleMap_Bool_Exp>;
};

/** aggregated selection of "roles" */
export type BusinessRole_Aggregate = {
  __typename?: 'BusinessRole_aggregate';
  aggregate?: Maybe<BusinessRole_Aggregate_Fields>;
  nodes: Array<BusinessRole>;
};

/** aggregate fields of "roles" */
export type BusinessRole_Aggregate_Fields = {
  __typename?: 'BusinessRole_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<BusinessRole_Max_Fields>;
  min?: Maybe<BusinessRole_Min_Fields>;
};


/** aggregate fields of "roles" */
export type BusinessRole_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<BusinessRole_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "roles". All fields are combined with a logical 'AND'. */
export type BusinessRole_Bool_Exp = {
  _and?: InputMaybe<Array<BusinessRole_Bool_Exp>>;
  _not?: InputMaybe<BusinessRole_Bool_Exp>;
  _or?: InputMaybe<Array<BusinessRole_Bool_Exp>>;
  actors?: InputMaybe<BusinessActorRoleMap_Bool_Exp>;
  actors_aggregate?: InputMaybe<BusinessActorRoleMap_Aggregate_Bool_Exp>;
  code?: InputMaybe<String_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "roles" */
export enum BusinessRole_Constraint {
  /** unique or primary key constraint on columns "code" */
  RolesCodeUnique = 'roles_code_unique',
  /** unique or primary key constraint on columns "id" */
  RolesPkey = 'roles_pkey'
}

/** input type for inserting data into table "roles" */
export type BusinessRole_Insert_Input = {
  actors?: InputMaybe<BusinessActorRoleMap_Arr_Rel_Insert_Input>;
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type BusinessRole_Max_Fields = {
  __typename?: 'BusinessRole_max_fields';
  code?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type BusinessRole_Min_Fields = {
  __typename?: 'BusinessRole_min_fields';
  code?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "roles" */
export type BusinessRole_Mutation_Response = {
  __typename?: 'BusinessRole_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<BusinessRole>;
};

/** input type for inserting object relation for remote table "roles" */
export type BusinessRole_Obj_Rel_Insert_Input = {
  data: BusinessRole_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<BusinessRole_On_Conflict>;
};

/** on_conflict condition type for table "roles" */
export type BusinessRole_On_Conflict = {
  constraint: BusinessRole_Constraint;
  update_columns?: Array<BusinessRole_Update_Column>;
  where?: InputMaybe<BusinessRole_Bool_Exp>;
};

/** Ordering options when selecting data from "roles". */
export type BusinessRole_Order_By = {
  actors_aggregate?: InputMaybe<BusinessActorRoleMap_Aggregate_Order_By>;
  code?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: roles */
export type BusinessRole_Pk_Columns_Input = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "roles" */
export enum BusinessRole_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "roles" */
export type BusinessRole_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "BusinessRole" */
export type BusinessRole_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: BusinessRole_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type BusinessRole_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "roles" */
export enum BusinessRole_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type BusinessRole_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<BusinessRole_Set_Input>;
  /** filter the rows which have to be updated */
  where: BusinessRole_Bool_Exp;
};

/** columns and relationships of "capabilities" */
export type Capability = {
  __typename?: 'Capability';
  /** An array relationship */
  child: Array<CapabilityHierarchyMap>;
  /** An aggregate relationship */
  child_aggregate: CapabilityHierarchyMap_Aggregate;
  code: Scalars['String']['output'];
  /** An array relationship */
  components: Array<CapabilityApplicationComponentMap>;
  /** An aggregate relationship */
  components_aggregate: CapabilityApplicationComponentMap_Aggregate;
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['uuid']['output'];
  name: Scalars['String']['output'];
  /** An object relationship */
  parent?: Maybe<Capability>;
  parentId?: Maybe<Scalars['uuid']['output']>;
  /** An array relationship */
  parentMapCapabilityHierarchy: Array<CapabilityHierarchyMap>;
  /** An aggregate relationship */
  parentMapCapabilityHierarchy_aggregate: CapabilityHierarchyMap_Aggregate;
  /** An array relationship */
  processes: Array<CapabilityBusinessProcessMap>;
  /** An aggregate relationship */
  processes_aggregate: CapabilityBusinessProcessMap_Aggregate;
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};


/** columns and relationships of "capabilities" */
export type CapabilityChildArgs = {
  distinct_on?: InputMaybe<Array<CapabilityHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CapabilityHierarchyMap_Order_By>>;
  where?: InputMaybe<CapabilityHierarchyMap_Bool_Exp>;
};


/** columns and relationships of "capabilities" */
export type CapabilityChild_AggregateArgs = {
  distinct_on?: InputMaybe<Array<CapabilityHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CapabilityHierarchyMap_Order_By>>;
  where?: InputMaybe<CapabilityHierarchyMap_Bool_Exp>;
};


/** columns and relationships of "capabilities" */
export type CapabilityComponentsArgs = {
  distinct_on?: InputMaybe<Array<CapabilityApplicationComponentMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CapabilityApplicationComponentMap_Order_By>>;
  where?: InputMaybe<CapabilityApplicationComponentMap_Bool_Exp>;
};


/** columns and relationships of "capabilities" */
export type CapabilityComponents_AggregateArgs = {
  distinct_on?: InputMaybe<Array<CapabilityApplicationComponentMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CapabilityApplicationComponentMap_Order_By>>;
  where?: InputMaybe<CapabilityApplicationComponentMap_Bool_Exp>;
};


/** columns and relationships of "capabilities" */
export type CapabilityParentMapCapabilityHierarchyArgs = {
  distinct_on?: InputMaybe<Array<CapabilityHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CapabilityHierarchyMap_Order_By>>;
  where?: InputMaybe<CapabilityHierarchyMap_Bool_Exp>;
};


/** columns and relationships of "capabilities" */
export type CapabilityParentMapCapabilityHierarchy_AggregateArgs = {
  distinct_on?: InputMaybe<Array<CapabilityHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CapabilityHierarchyMap_Order_By>>;
  where?: InputMaybe<CapabilityHierarchyMap_Bool_Exp>;
};


/** columns and relationships of "capabilities" */
export type CapabilityProcessesArgs = {
  distinct_on?: InputMaybe<Array<CapabilityBusinessProcessMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CapabilityBusinessProcessMap_Order_By>>;
  where?: InputMaybe<CapabilityBusinessProcessMap_Bool_Exp>;
};


/** columns and relationships of "capabilities" */
export type CapabilityProcesses_AggregateArgs = {
  distinct_on?: InputMaybe<Array<CapabilityBusinessProcessMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CapabilityBusinessProcessMap_Order_By>>;
  where?: InputMaybe<CapabilityBusinessProcessMap_Bool_Exp>;
};

/** columns and relationships of "map_capability_application_component_assessment" */
export type CapabilityApplicationComponentAssessmentMap = {
  __typename?: 'CapabilityApplicationComponentAssessmentMap';
  /** An object relationship */
  assessment: MotivationElementGeneric;
  assessmentId: Scalars['uuid']['output'];
  capabilityId: Scalars['uuid']['output'];
  componentId: Scalars['uuid']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "map_capability_application_component_assessment" */
export type CapabilityApplicationComponentAssessmentMap_Aggregate = {
  __typename?: 'CapabilityApplicationComponentAssessmentMap_aggregate';
  aggregate?: Maybe<CapabilityApplicationComponentAssessmentMap_Aggregate_Fields>;
  nodes: Array<CapabilityApplicationComponentAssessmentMap>;
};

/** aggregate fields of "map_capability_application_component_assessment" */
export type CapabilityApplicationComponentAssessmentMap_Aggregate_Fields = {
  __typename?: 'CapabilityApplicationComponentAssessmentMap_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<CapabilityApplicationComponentAssessmentMap_Max_Fields>;
  min?: Maybe<CapabilityApplicationComponentAssessmentMap_Min_Fields>;
};


/** aggregate fields of "map_capability_application_component_assessment" */
export type CapabilityApplicationComponentAssessmentMap_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<CapabilityApplicationComponentAssessmentMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "map_capability_application_component_assessment". All fields are combined with a logical 'AND'. */
export type CapabilityApplicationComponentAssessmentMap_Bool_Exp = {
  _and?: InputMaybe<Array<CapabilityApplicationComponentAssessmentMap_Bool_Exp>>;
  _not?: InputMaybe<CapabilityApplicationComponentAssessmentMap_Bool_Exp>;
  _or?: InputMaybe<Array<CapabilityApplicationComponentAssessmentMap_Bool_Exp>>;
  assessment?: InputMaybe<MotivationElementGeneric_Bool_Exp>;
  assessmentId?: InputMaybe<Uuid_Comparison_Exp>;
  capabilityId?: InputMaybe<Uuid_Comparison_Exp>;
  componentId?: InputMaybe<Uuid_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "map_capability_application_component_assessment" */
export enum CapabilityApplicationComponentAssessmentMap_Constraint {
  /** unique or primary key constraint on columns "capability_id", "component_id", "assessment_id" */
  MapCapabilityApplicationComponentAssessmentPkey = 'map_capability_application_component_assessment_pkey'
}

/** input type for inserting data into table "map_capability_application_component_assessment" */
export type CapabilityApplicationComponentAssessmentMap_Insert_Input = {
  assessment?: InputMaybe<MotivationElementGeneric_Obj_Rel_Insert_Input>;
  assessmentId?: InputMaybe<Scalars['uuid']['input']>;
  capabilityId?: InputMaybe<Scalars['uuid']['input']>;
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type CapabilityApplicationComponentAssessmentMap_Max_Fields = {
  __typename?: 'CapabilityApplicationComponentAssessmentMap_max_fields';
  assessmentId?: Maybe<Scalars['uuid']['output']>;
  capabilityId?: Maybe<Scalars['uuid']['output']>;
  componentId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type CapabilityApplicationComponentAssessmentMap_Min_Fields = {
  __typename?: 'CapabilityApplicationComponentAssessmentMap_min_fields';
  assessmentId?: Maybe<Scalars['uuid']['output']>;
  capabilityId?: Maybe<Scalars['uuid']['output']>;
  componentId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "map_capability_application_component_assessment" */
export type CapabilityApplicationComponentAssessmentMap_Mutation_Response = {
  __typename?: 'CapabilityApplicationComponentAssessmentMap_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<CapabilityApplicationComponentAssessmentMap>;
};

/** on_conflict condition type for table "map_capability_application_component_assessment" */
export type CapabilityApplicationComponentAssessmentMap_On_Conflict = {
  constraint: CapabilityApplicationComponentAssessmentMap_Constraint;
  update_columns?: Array<CapabilityApplicationComponentAssessmentMap_Update_Column>;
  where?: InputMaybe<CapabilityApplicationComponentAssessmentMap_Bool_Exp>;
};

/** Ordering options when selecting data from "map_capability_application_component_assessment". */
export type CapabilityApplicationComponentAssessmentMap_Order_By = {
  assessment?: InputMaybe<MotivationElementGeneric_Order_By>;
  assessmentId?: InputMaybe<Order_By>;
  capabilityId?: InputMaybe<Order_By>;
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: map_capability_application_component_assessment */
export type CapabilityApplicationComponentAssessmentMap_Pk_Columns_Input = {
  assessmentId: Scalars['uuid']['input'];
  capabilityId: Scalars['uuid']['input'];
  componentId: Scalars['uuid']['input'];
};

/** select columns of table "map_capability_application_component_assessment" */
export enum CapabilityApplicationComponentAssessmentMap_Select_Column {
  /** column name */
  AssessmentId = 'assessmentId',
  /** column name */
  CapabilityId = 'capabilityId',
  /** column name */
  ComponentId = 'componentId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "map_capability_application_component_assessment" */
export type CapabilityApplicationComponentAssessmentMap_Set_Input = {
  assessmentId?: InputMaybe<Scalars['uuid']['input']>;
  capabilityId?: InputMaybe<Scalars['uuid']['input']>;
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "CapabilityApplicationComponentAssessmentMap" */
export type CapabilityApplicationComponentAssessmentMap_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: CapabilityApplicationComponentAssessmentMap_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type CapabilityApplicationComponentAssessmentMap_Stream_Cursor_Value_Input = {
  assessmentId?: InputMaybe<Scalars['uuid']['input']>;
  capabilityId?: InputMaybe<Scalars['uuid']['input']>;
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "map_capability_application_component_assessment" */
export enum CapabilityApplicationComponentAssessmentMap_Update_Column {
  /** column name */
  AssessmentId = 'assessmentId',
  /** column name */
  CapabilityId = 'capabilityId',
  /** column name */
  ComponentId = 'componentId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type CapabilityApplicationComponentAssessmentMap_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CapabilityApplicationComponentAssessmentMap_Set_Input>;
  /** filter the rows which have to be updated */
  where: CapabilityApplicationComponentAssessmentMap_Bool_Exp;
};

/** columns and relationships of "map_capability_application_component" */
export type CapabilityApplicationComponentMap = {
  __typename?: 'CapabilityApplicationComponentMap';
  /** An object relationship */
  capability: Capability;
  capabilityId: Scalars['uuid']['output'];
  /** An object relationship */
  component: ApplicationComponent;
  componentId: Scalars['uuid']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "map_capability_application_component" */
export type CapabilityApplicationComponentMap_Aggregate = {
  __typename?: 'CapabilityApplicationComponentMap_aggregate';
  aggregate?: Maybe<CapabilityApplicationComponentMap_Aggregate_Fields>;
  nodes: Array<CapabilityApplicationComponentMap>;
};

export type CapabilityApplicationComponentMap_Aggregate_Bool_Exp = {
  count?: InputMaybe<CapabilityApplicationComponentMap_Aggregate_Bool_Exp_Count>;
};

export type CapabilityApplicationComponentMap_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<CapabilityApplicationComponentMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<CapabilityApplicationComponentMap_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "map_capability_application_component" */
export type CapabilityApplicationComponentMap_Aggregate_Fields = {
  __typename?: 'CapabilityApplicationComponentMap_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<CapabilityApplicationComponentMap_Max_Fields>;
  min?: Maybe<CapabilityApplicationComponentMap_Min_Fields>;
};


/** aggregate fields of "map_capability_application_component" */
export type CapabilityApplicationComponentMap_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<CapabilityApplicationComponentMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "map_capability_application_component" */
export type CapabilityApplicationComponentMap_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<CapabilityApplicationComponentMap_Max_Order_By>;
  min?: InputMaybe<CapabilityApplicationComponentMap_Min_Order_By>;
};

/** input type for inserting array relation for remote table "map_capability_application_component" */
export type CapabilityApplicationComponentMap_Arr_Rel_Insert_Input = {
  data: Array<CapabilityApplicationComponentMap_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<CapabilityApplicationComponentMap_On_Conflict>;
};

/** Boolean expression to filter rows from the table "map_capability_application_component". All fields are combined with a logical 'AND'. */
export type CapabilityApplicationComponentMap_Bool_Exp = {
  _and?: InputMaybe<Array<CapabilityApplicationComponentMap_Bool_Exp>>;
  _not?: InputMaybe<CapabilityApplicationComponentMap_Bool_Exp>;
  _or?: InputMaybe<Array<CapabilityApplicationComponentMap_Bool_Exp>>;
  capability?: InputMaybe<Capability_Bool_Exp>;
  capabilityId?: InputMaybe<Uuid_Comparison_Exp>;
  component?: InputMaybe<ApplicationComponent_Bool_Exp>;
  componentId?: InputMaybe<Uuid_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "map_capability_application_component" */
export enum CapabilityApplicationComponentMap_Constraint {
  /** unique or primary key constraint on columns "capability_id", "component_id" */
  MapCapabilityApplicationComponentPkey = 'map_capability_application_component_pkey'
}

/** input type for inserting data into table "map_capability_application_component" */
export type CapabilityApplicationComponentMap_Insert_Input = {
  capability?: InputMaybe<Capability_Obj_Rel_Insert_Input>;
  capabilityId?: InputMaybe<Scalars['uuid']['input']>;
  component?: InputMaybe<ApplicationComponent_Obj_Rel_Insert_Input>;
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type CapabilityApplicationComponentMap_Max_Fields = {
  __typename?: 'CapabilityApplicationComponentMap_max_fields';
  capabilityId?: Maybe<Scalars['uuid']['output']>;
  componentId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "map_capability_application_component" */
export type CapabilityApplicationComponentMap_Max_Order_By = {
  capabilityId?: InputMaybe<Order_By>;
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type CapabilityApplicationComponentMap_Min_Fields = {
  __typename?: 'CapabilityApplicationComponentMap_min_fields';
  capabilityId?: Maybe<Scalars['uuid']['output']>;
  componentId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "map_capability_application_component" */
export type CapabilityApplicationComponentMap_Min_Order_By = {
  capabilityId?: InputMaybe<Order_By>;
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "map_capability_application_component" */
export type CapabilityApplicationComponentMap_Mutation_Response = {
  __typename?: 'CapabilityApplicationComponentMap_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<CapabilityApplicationComponentMap>;
};

/** on_conflict condition type for table "map_capability_application_component" */
export type CapabilityApplicationComponentMap_On_Conflict = {
  constraint: CapabilityApplicationComponentMap_Constraint;
  update_columns?: Array<CapabilityApplicationComponentMap_Update_Column>;
  where?: InputMaybe<CapabilityApplicationComponentMap_Bool_Exp>;
};

/** Ordering options when selecting data from "map_capability_application_component". */
export type CapabilityApplicationComponentMap_Order_By = {
  capability?: InputMaybe<Capability_Order_By>;
  capabilityId?: InputMaybe<Order_By>;
  component?: InputMaybe<ApplicationComponent_Order_By>;
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: map_capability_application_component */
export type CapabilityApplicationComponentMap_Pk_Columns_Input = {
  capabilityId: Scalars['uuid']['input'];
  componentId: Scalars['uuid']['input'];
};

/** select columns of table "map_capability_application_component" */
export enum CapabilityApplicationComponentMap_Select_Column {
  /** column name */
  CapabilityId = 'capabilityId',
  /** column name */
  ComponentId = 'componentId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "map_capability_application_component" */
export type CapabilityApplicationComponentMap_Set_Input = {
  capabilityId?: InputMaybe<Scalars['uuid']['input']>;
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "CapabilityApplicationComponentMap" */
export type CapabilityApplicationComponentMap_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: CapabilityApplicationComponentMap_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type CapabilityApplicationComponentMap_Stream_Cursor_Value_Input = {
  capabilityId?: InputMaybe<Scalars['uuid']['input']>;
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "map_capability_application_component" */
export enum CapabilityApplicationComponentMap_Update_Column {
  /** column name */
  CapabilityId = 'capabilityId',
  /** column name */
  ComponentId = 'componentId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type CapabilityApplicationComponentMap_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CapabilityApplicationComponentMap_Set_Input>;
  /** filter the rows which have to be updated */
  where: CapabilityApplicationComponentMap_Bool_Exp;
};

/** columns and relationships of "map_capability_business_process_assessment" */
export type CapabilityBusinessProcessAssessmentMap = {
  __typename?: 'CapabilityBusinessProcessAssessmentMap';
  /** An object relationship */
  assessment: MotivationElementGeneric;
  assessmentId: Scalars['uuid']['output'];
  capabilityId: Scalars['uuid']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  processId: Scalars['uuid']['output'];
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "map_capability_business_process_assessment" */
export type CapabilityBusinessProcessAssessmentMap_Aggregate = {
  __typename?: 'CapabilityBusinessProcessAssessmentMap_aggregate';
  aggregate?: Maybe<CapabilityBusinessProcessAssessmentMap_Aggregate_Fields>;
  nodes: Array<CapabilityBusinessProcessAssessmentMap>;
};

/** aggregate fields of "map_capability_business_process_assessment" */
export type CapabilityBusinessProcessAssessmentMap_Aggregate_Fields = {
  __typename?: 'CapabilityBusinessProcessAssessmentMap_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<CapabilityBusinessProcessAssessmentMap_Max_Fields>;
  min?: Maybe<CapabilityBusinessProcessAssessmentMap_Min_Fields>;
};


/** aggregate fields of "map_capability_business_process_assessment" */
export type CapabilityBusinessProcessAssessmentMap_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<CapabilityBusinessProcessAssessmentMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "map_capability_business_process_assessment". All fields are combined with a logical 'AND'. */
export type CapabilityBusinessProcessAssessmentMap_Bool_Exp = {
  _and?: InputMaybe<Array<CapabilityBusinessProcessAssessmentMap_Bool_Exp>>;
  _not?: InputMaybe<CapabilityBusinessProcessAssessmentMap_Bool_Exp>;
  _or?: InputMaybe<Array<CapabilityBusinessProcessAssessmentMap_Bool_Exp>>;
  assessment?: InputMaybe<MotivationElementGeneric_Bool_Exp>;
  assessmentId?: InputMaybe<Uuid_Comparison_Exp>;
  capabilityId?: InputMaybe<Uuid_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  processId?: InputMaybe<Uuid_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "map_capability_business_process_assessment" */
export enum CapabilityBusinessProcessAssessmentMap_Constraint {
  /** unique or primary key constraint on columns "capability_id", "assessment_id", "process_id" */
  MapCapabilityBusinessProcessAssessmentPkey = 'map_capability_business_process_assessment_pkey'
}

/** input type for inserting data into table "map_capability_business_process_assessment" */
export type CapabilityBusinessProcessAssessmentMap_Insert_Input = {
  assessment?: InputMaybe<MotivationElementGeneric_Obj_Rel_Insert_Input>;
  assessmentId?: InputMaybe<Scalars['uuid']['input']>;
  capabilityId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  processId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type CapabilityBusinessProcessAssessmentMap_Max_Fields = {
  __typename?: 'CapabilityBusinessProcessAssessmentMap_max_fields';
  assessmentId?: Maybe<Scalars['uuid']['output']>;
  capabilityId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  processId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type CapabilityBusinessProcessAssessmentMap_Min_Fields = {
  __typename?: 'CapabilityBusinessProcessAssessmentMap_min_fields';
  assessmentId?: Maybe<Scalars['uuid']['output']>;
  capabilityId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  processId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "map_capability_business_process_assessment" */
export type CapabilityBusinessProcessAssessmentMap_Mutation_Response = {
  __typename?: 'CapabilityBusinessProcessAssessmentMap_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<CapabilityBusinessProcessAssessmentMap>;
};

/** on_conflict condition type for table "map_capability_business_process_assessment" */
export type CapabilityBusinessProcessAssessmentMap_On_Conflict = {
  constraint: CapabilityBusinessProcessAssessmentMap_Constraint;
  update_columns?: Array<CapabilityBusinessProcessAssessmentMap_Update_Column>;
  where?: InputMaybe<CapabilityBusinessProcessAssessmentMap_Bool_Exp>;
};

/** Ordering options when selecting data from "map_capability_business_process_assessment". */
export type CapabilityBusinessProcessAssessmentMap_Order_By = {
  assessment?: InputMaybe<MotivationElementGeneric_Order_By>;
  assessmentId?: InputMaybe<Order_By>;
  capabilityId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  processId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: map_capability_business_process_assessment */
export type CapabilityBusinessProcessAssessmentMap_Pk_Columns_Input = {
  assessmentId: Scalars['uuid']['input'];
  capabilityId: Scalars['uuid']['input'];
  processId: Scalars['uuid']['input'];
};

/** select columns of table "map_capability_business_process_assessment" */
export enum CapabilityBusinessProcessAssessmentMap_Select_Column {
  /** column name */
  AssessmentId = 'assessmentId',
  /** column name */
  CapabilityId = 'capabilityId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  ProcessId = 'processId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "map_capability_business_process_assessment" */
export type CapabilityBusinessProcessAssessmentMap_Set_Input = {
  assessmentId?: InputMaybe<Scalars['uuid']['input']>;
  capabilityId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  processId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "CapabilityBusinessProcessAssessmentMap" */
export type CapabilityBusinessProcessAssessmentMap_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: CapabilityBusinessProcessAssessmentMap_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type CapabilityBusinessProcessAssessmentMap_Stream_Cursor_Value_Input = {
  assessmentId?: InputMaybe<Scalars['uuid']['input']>;
  capabilityId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  processId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "map_capability_business_process_assessment" */
export enum CapabilityBusinessProcessAssessmentMap_Update_Column {
  /** column name */
  AssessmentId = 'assessmentId',
  /** column name */
  CapabilityId = 'capabilityId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  ProcessId = 'processId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type CapabilityBusinessProcessAssessmentMap_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CapabilityBusinessProcessAssessmentMap_Set_Input>;
  /** filter the rows which have to be updated */
  where: CapabilityBusinessProcessAssessmentMap_Bool_Exp;
};

/** columns and relationships of "map_capability_business_process" */
export type CapabilityBusinessProcessMap = {
  __typename?: 'CapabilityBusinessProcessMap';
  /** An object relationship */
  capability: Capability;
  capabilityId: Scalars['uuid']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  process: ProcessGeneric;
  processId: Scalars['uuid']['output'];
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "map_capability_business_process" */
export type CapabilityBusinessProcessMap_Aggregate = {
  __typename?: 'CapabilityBusinessProcessMap_aggregate';
  aggregate?: Maybe<CapabilityBusinessProcessMap_Aggregate_Fields>;
  nodes: Array<CapabilityBusinessProcessMap>;
};

export type CapabilityBusinessProcessMap_Aggregate_Bool_Exp = {
  count?: InputMaybe<CapabilityBusinessProcessMap_Aggregate_Bool_Exp_Count>;
};

export type CapabilityBusinessProcessMap_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<CapabilityBusinessProcessMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<CapabilityBusinessProcessMap_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "map_capability_business_process" */
export type CapabilityBusinessProcessMap_Aggregate_Fields = {
  __typename?: 'CapabilityBusinessProcessMap_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<CapabilityBusinessProcessMap_Max_Fields>;
  min?: Maybe<CapabilityBusinessProcessMap_Min_Fields>;
};


/** aggregate fields of "map_capability_business_process" */
export type CapabilityBusinessProcessMap_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<CapabilityBusinessProcessMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "map_capability_business_process" */
export type CapabilityBusinessProcessMap_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<CapabilityBusinessProcessMap_Max_Order_By>;
  min?: InputMaybe<CapabilityBusinessProcessMap_Min_Order_By>;
};

/** input type for inserting array relation for remote table "map_capability_business_process" */
export type CapabilityBusinessProcessMap_Arr_Rel_Insert_Input = {
  data: Array<CapabilityBusinessProcessMap_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<CapabilityBusinessProcessMap_On_Conflict>;
};

/** Boolean expression to filter rows from the table "map_capability_business_process". All fields are combined with a logical 'AND'. */
export type CapabilityBusinessProcessMap_Bool_Exp = {
  _and?: InputMaybe<Array<CapabilityBusinessProcessMap_Bool_Exp>>;
  _not?: InputMaybe<CapabilityBusinessProcessMap_Bool_Exp>;
  _or?: InputMaybe<Array<CapabilityBusinessProcessMap_Bool_Exp>>;
  capability?: InputMaybe<Capability_Bool_Exp>;
  capabilityId?: InputMaybe<Uuid_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  process?: InputMaybe<ProcessGeneric_Bool_Exp>;
  processId?: InputMaybe<Uuid_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "map_capability_business_process" */
export enum CapabilityBusinessProcessMap_Constraint {
  /** unique or primary key constraint on columns "capability_id", "process_id" */
  MapCapabilityBusinessProcessPkey = 'map_capability_business_process_pkey'
}

/** input type for inserting data into table "map_capability_business_process" */
export type CapabilityBusinessProcessMap_Insert_Input = {
  capability?: InputMaybe<Capability_Obj_Rel_Insert_Input>;
  capabilityId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  process?: InputMaybe<ProcessGeneric_Obj_Rel_Insert_Input>;
  processId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type CapabilityBusinessProcessMap_Max_Fields = {
  __typename?: 'CapabilityBusinessProcessMap_max_fields';
  capabilityId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  processId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "map_capability_business_process" */
export type CapabilityBusinessProcessMap_Max_Order_By = {
  capabilityId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  processId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type CapabilityBusinessProcessMap_Min_Fields = {
  __typename?: 'CapabilityBusinessProcessMap_min_fields';
  capabilityId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  processId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "map_capability_business_process" */
export type CapabilityBusinessProcessMap_Min_Order_By = {
  capabilityId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  processId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "map_capability_business_process" */
export type CapabilityBusinessProcessMap_Mutation_Response = {
  __typename?: 'CapabilityBusinessProcessMap_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<CapabilityBusinessProcessMap>;
};

/** on_conflict condition type for table "map_capability_business_process" */
export type CapabilityBusinessProcessMap_On_Conflict = {
  constraint: CapabilityBusinessProcessMap_Constraint;
  update_columns?: Array<CapabilityBusinessProcessMap_Update_Column>;
  where?: InputMaybe<CapabilityBusinessProcessMap_Bool_Exp>;
};

/** Ordering options when selecting data from "map_capability_business_process". */
export type CapabilityBusinessProcessMap_Order_By = {
  capability?: InputMaybe<Capability_Order_By>;
  capabilityId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  process?: InputMaybe<ProcessGeneric_Order_By>;
  processId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: map_capability_business_process */
export type CapabilityBusinessProcessMap_Pk_Columns_Input = {
  capabilityId: Scalars['uuid']['input'];
  processId: Scalars['uuid']['input'];
};

/** select columns of table "map_capability_business_process" */
export enum CapabilityBusinessProcessMap_Select_Column {
  /** column name */
  CapabilityId = 'capabilityId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  ProcessId = 'processId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "map_capability_business_process" */
export type CapabilityBusinessProcessMap_Set_Input = {
  capabilityId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  processId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "CapabilityBusinessProcessMap" */
export type CapabilityBusinessProcessMap_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: CapabilityBusinessProcessMap_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type CapabilityBusinessProcessMap_Stream_Cursor_Value_Input = {
  capabilityId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  processId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "map_capability_business_process" */
export enum CapabilityBusinessProcessMap_Update_Column {
  /** column name */
  CapabilityId = 'capabilityId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  ProcessId = 'processId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type CapabilityBusinessProcessMap_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CapabilityBusinessProcessMap_Set_Input>;
  /** filter the rows which have to be updated */
  where: CapabilityBusinessProcessMap_Bool_Exp;
};

/** columns and relationships of "map_capability_hierarchy" */
export type CapabilityHierarchyMap = {
  __typename?: 'CapabilityHierarchyMap';
  /** An object relationship */
  child: Capability;
  childId: Scalars['uuid']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  order?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  parent: Capability;
  parentId: Scalars['uuid']['output'];
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "map_capability_hierarchy" */
export type CapabilityHierarchyMap_Aggregate = {
  __typename?: 'CapabilityHierarchyMap_aggregate';
  aggregate?: Maybe<CapabilityHierarchyMap_Aggregate_Fields>;
  nodes: Array<CapabilityHierarchyMap>;
};

export type CapabilityHierarchyMap_Aggregate_Bool_Exp = {
  count?: InputMaybe<CapabilityHierarchyMap_Aggregate_Bool_Exp_Count>;
};

export type CapabilityHierarchyMap_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<CapabilityHierarchyMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<CapabilityHierarchyMap_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "map_capability_hierarchy" */
export type CapabilityHierarchyMap_Aggregate_Fields = {
  __typename?: 'CapabilityHierarchyMap_aggregate_fields';
  avg?: Maybe<CapabilityHierarchyMap_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<CapabilityHierarchyMap_Max_Fields>;
  min?: Maybe<CapabilityHierarchyMap_Min_Fields>;
  stddev?: Maybe<CapabilityHierarchyMap_Stddev_Fields>;
  stddev_pop?: Maybe<CapabilityHierarchyMap_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<CapabilityHierarchyMap_Stddev_Samp_Fields>;
  sum?: Maybe<CapabilityHierarchyMap_Sum_Fields>;
  var_pop?: Maybe<CapabilityHierarchyMap_Var_Pop_Fields>;
  var_samp?: Maybe<CapabilityHierarchyMap_Var_Samp_Fields>;
  variance?: Maybe<CapabilityHierarchyMap_Variance_Fields>;
};


/** aggregate fields of "map_capability_hierarchy" */
export type CapabilityHierarchyMap_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<CapabilityHierarchyMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "map_capability_hierarchy" */
export type CapabilityHierarchyMap_Aggregate_Order_By = {
  avg?: InputMaybe<CapabilityHierarchyMap_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<CapabilityHierarchyMap_Max_Order_By>;
  min?: InputMaybe<CapabilityHierarchyMap_Min_Order_By>;
  stddev?: InputMaybe<CapabilityHierarchyMap_Stddev_Order_By>;
  stddev_pop?: InputMaybe<CapabilityHierarchyMap_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<CapabilityHierarchyMap_Stddev_Samp_Order_By>;
  sum?: InputMaybe<CapabilityHierarchyMap_Sum_Order_By>;
  var_pop?: InputMaybe<CapabilityHierarchyMap_Var_Pop_Order_By>;
  var_samp?: InputMaybe<CapabilityHierarchyMap_Var_Samp_Order_By>;
  variance?: InputMaybe<CapabilityHierarchyMap_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "map_capability_hierarchy" */
export type CapabilityHierarchyMap_Arr_Rel_Insert_Input = {
  data: Array<CapabilityHierarchyMap_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<CapabilityHierarchyMap_On_Conflict>;
};

/** aggregate avg on columns */
export type CapabilityHierarchyMap_Avg_Fields = {
  __typename?: 'CapabilityHierarchyMap_avg_fields';
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "map_capability_hierarchy" */
export type CapabilityHierarchyMap_Avg_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "map_capability_hierarchy". All fields are combined with a logical 'AND'. */
export type CapabilityHierarchyMap_Bool_Exp = {
  _and?: InputMaybe<Array<CapabilityHierarchyMap_Bool_Exp>>;
  _not?: InputMaybe<CapabilityHierarchyMap_Bool_Exp>;
  _or?: InputMaybe<Array<CapabilityHierarchyMap_Bool_Exp>>;
  child?: InputMaybe<Capability_Bool_Exp>;
  childId?: InputMaybe<Uuid_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  order?: InputMaybe<Int_Comparison_Exp>;
  parent?: InputMaybe<Capability_Bool_Exp>;
  parentId?: InputMaybe<Uuid_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "map_capability_hierarchy" */
export enum CapabilityHierarchyMap_Constraint {
  /** unique or primary key constraint on columns "child_id", "parent_id" */
  MapCapabilityHierarchyParentIdChildIdUnique = 'map_capability_hierarchy_parent_id_child_id_unique',
  /** unique or primary key constraint on columns "child_id", "parent_id" */
  MapCapabilityHierarchyPkey = 'map_capability_hierarchy_pkey'
}

/** input type for incrementing numeric columns in table "map_capability_hierarchy" */
export type CapabilityHierarchyMap_Inc_Input = {
  order?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "map_capability_hierarchy" */
export type CapabilityHierarchyMap_Insert_Input = {
  child?: InputMaybe<Capability_Obj_Rel_Insert_Input>;
  childId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  parent?: InputMaybe<Capability_Obj_Rel_Insert_Input>;
  parentId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type CapabilityHierarchyMap_Max_Fields = {
  __typename?: 'CapabilityHierarchyMap_max_fields';
  childId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  order?: Maybe<Scalars['Int']['output']>;
  parentId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "map_capability_hierarchy" */
export type CapabilityHierarchyMap_Max_Order_By = {
  childId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  order?: InputMaybe<Order_By>;
  parentId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type CapabilityHierarchyMap_Min_Fields = {
  __typename?: 'CapabilityHierarchyMap_min_fields';
  childId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  order?: Maybe<Scalars['Int']['output']>;
  parentId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "map_capability_hierarchy" */
export type CapabilityHierarchyMap_Min_Order_By = {
  childId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  order?: InputMaybe<Order_By>;
  parentId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "map_capability_hierarchy" */
export type CapabilityHierarchyMap_Mutation_Response = {
  __typename?: 'CapabilityHierarchyMap_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<CapabilityHierarchyMap>;
};

/** on_conflict condition type for table "map_capability_hierarchy" */
export type CapabilityHierarchyMap_On_Conflict = {
  constraint: CapabilityHierarchyMap_Constraint;
  update_columns?: Array<CapabilityHierarchyMap_Update_Column>;
  where?: InputMaybe<CapabilityHierarchyMap_Bool_Exp>;
};

/** Ordering options when selecting data from "map_capability_hierarchy". */
export type CapabilityHierarchyMap_Order_By = {
  child?: InputMaybe<Capability_Order_By>;
  childId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  order?: InputMaybe<Order_By>;
  parent?: InputMaybe<Capability_Order_By>;
  parentId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: map_capability_hierarchy */
export type CapabilityHierarchyMap_Pk_Columns_Input = {
  childId: Scalars['uuid']['input'];
  parentId: Scalars['uuid']['input'];
};

/** select columns of table "map_capability_hierarchy" */
export enum CapabilityHierarchyMap_Select_Column {
  /** column name */
  ChildId = 'childId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Order = 'order',
  /** column name */
  ParentId = 'parentId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "map_capability_hierarchy" */
export type CapabilityHierarchyMap_Set_Input = {
  childId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  parentId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type CapabilityHierarchyMap_Stddev_Fields = {
  __typename?: 'CapabilityHierarchyMap_stddev_fields';
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "map_capability_hierarchy" */
export type CapabilityHierarchyMap_Stddev_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type CapabilityHierarchyMap_Stddev_Pop_Fields = {
  __typename?: 'CapabilityHierarchyMap_stddev_pop_fields';
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "map_capability_hierarchy" */
export type CapabilityHierarchyMap_Stddev_Pop_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type CapabilityHierarchyMap_Stddev_Samp_Fields = {
  __typename?: 'CapabilityHierarchyMap_stddev_samp_fields';
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "map_capability_hierarchy" */
export type CapabilityHierarchyMap_Stddev_Samp_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "CapabilityHierarchyMap" */
export type CapabilityHierarchyMap_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: CapabilityHierarchyMap_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type CapabilityHierarchyMap_Stream_Cursor_Value_Input = {
  childId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  parentId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type CapabilityHierarchyMap_Sum_Fields = {
  __typename?: 'CapabilityHierarchyMap_sum_fields';
  order?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "map_capability_hierarchy" */
export type CapabilityHierarchyMap_Sum_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** update columns of table "map_capability_hierarchy" */
export enum CapabilityHierarchyMap_Update_Column {
  /** column name */
  ChildId = 'childId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Order = 'order',
  /** column name */
  ParentId = 'parentId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type CapabilityHierarchyMap_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<CapabilityHierarchyMap_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<CapabilityHierarchyMap_Set_Input>;
  /** filter the rows which have to be updated */
  where: CapabilityHierarchyMap_Bool_Exp;
};

/** aggregate var_pop on columns */
export type CapabilityHierarchyMap_Var_Pop_Fields = {
  __typename?: 'CapabilityHierarchyMap_var_pop_fields';
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "map_capability_hierarchy" */
export type CapabilityHierarchyMap_Var_Pop_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type CapabilityHierarchyMap_Var_Samp_Fields = {
  __typename?: 'CapabilityHierarchyMap_var_samp_fields';
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "map_capability_hierarchy" */
export type CapabilityHierarchyMap_Var_Samp_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type CapabilityHierarchyMap_Variance_Fields = {
  __typename?: 'CapabilityHierarchyMap_variance_fields';
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "map_capability_hierarchy" */
export type CapabilityHierarchyMap_Variance_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** aggregated selection of "capabilities" */
export type Capability_Aggregate = {
  __typename?: 'Capability_aggregate';
  aggregate?: Maybe<Capability_Aggregate_Fields>;
  nodes: Array<Capability>;
};

/** aggregate fields of "capabilities" */
export type Capability_Aggregate_Fields = {
  __typename?: 'Capability_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Capability_Max_Fields>;
  min?: Maybe<Capability_Min_Fields>;
};


/** aggregate fields of "capabilities" */
export type Capability_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Capability_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "capabilities". All fields are combined with a logical 'AND'. */
export type Capability_Bool_Exp = {
  _and?: InputMaybe<Array<Capability_Bool_Exp>>;
  _not?: InputMaybe<Capability_Bool_Exp>;
  _or?: InputMaybe<Array<Capability_Bool_Exp>>;
  child?: InputMaybe<CapabilityHierarchyMap_Bool_Exp>;
  child_aggregate?: InputMaybe<CapabilityHierarchyMap_Aggregate_Bool_Exp>;
  code?: InputMaybe<String_Comparison_Exp>;
  components?: InputMaybe<CapabilityApplicationComponentMap_Bool_Exp>;
  components_aggregate?: InputMaybe<CapabilityApplicationComponentMap_Aggregate_Bool_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  parent?: InputMaybe<Capability_Bool_Exp>;
  parentId?: InputMaybe<Uuid_Comparison_Exp>;
  parentMapCapabilityHierarchy?: InputMaybe<CapabilityHierarchyMap_Bool_Exp>;
  parentMapCapabilityHierarchy_aggregate?: InputMaybe<CapabilityHierarchyMap_Aggregate_Bool_Exp>;
  processes?: InputMaybe<CapabilityBusinessProcessMap_Bool_Exp>;
  processes_aggregate?: InputMaybe<CapabilityBusinessProcessMap_Aggregate_Bool_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "capabilities" */
export enum Capability_Constraint {
  /** unique or primary key constraint on columns "code" */
  CapabilitiesCodeUnique = 'capabilities_code_unique',
  /** unique or primary key constraint on columns "id" */
  CapabilitiesPkey = 'capabilities_pkey'
}

/** input type for inserting data into table "capabilities" */
export type Capability_Insert_Input = {
  child?: InputMaybe<CapabilityHierarchyMap_Arr_Rel_Insert_Input>;
  code?: InputMaybe<Scalars['String']['input']>;
  components?: InputMaybe<CapabilityApplicationComponentMap_Arr_Rel_Insert_Input>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  parent?: InputMaybe<Capability_Obj_Rel_Insert_Input>;
  parentId?: InputMaybe<Scalars['uuid']['input']>;
  parentMapCapabilityHierarchy?: InputMaybe<CapabilityHierarchyMap_Arr_Rel_Insert_Input>;
  processes?: InputMaybe<CapabilityBusinessProcessMap_Arr_Rel_Insert_Input>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Capability_Max_Fields = {
  __typename?: 'Capability_max_fields';
  code?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  parentId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type Capability_Min_Fields = {
  __typename?: 'Capability_min_fields';
  code?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  parentId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "capabilities" */
export type Capability_Mutation_Response = {
  __typename?: 'Capability_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Capability>;
};

/** input type for inserting object relation for remote table "capabilities" */
export type Capability_Obj_Rel_Insert_Input = {
  data: Capability_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Capability_On_Conflict>;
};

/** on_conflict condition type for table "capabilities" */
export type Capability_On_Conflict = {
  constraint: Capability_Constraint;
  update_columns?: Array<Capability_Update_Column>;
  where?: InputMaybe<Capability_Bool_Exp>;
};

/** Ordering options when selecting data from "capabilities". */
export type Capability_Order_By = {
  child_aggregate?: InputMaybe<CapabilityHierarchyMap_Aggregate_Order_By>;
  code?: InputMaybe<Order_By>;
  components_aggregate?: InputMaybe<CapabilityApplicationComponentMap_Aggregate_Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  parent?: InputMaybe<Capability_Order_By>;
  parentId?: InputMaybe<Order_By>;
  parentMapCapabilityHierarchy_aggregate?: InputMaybe<CapabilityHierarchyMap_Aggregate_Order_By>;
  processes_aggregate?: InputMaybe<CapabilityBusinessProcessMap_Aggregate_Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: capabilities */
export type Capability_Pk_Columns_Input = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "capabilities" */
export enum Capability_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  ParentId = 'parentId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "capabilities" */
export type Capability_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  parentId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "Capability" */
export type Capability_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Capability_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Capability_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  parentId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "capabilities" */
export enum Capability_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  ParentId = 'parentId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type Capability_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Capability_Set_Input>;
  /** filter the rows which have to be updated */
  where: Capability_Bool_Exp;
};

/** columns and relationships of "data_objects" */
export type DataObject = {
  __typename?: 'DataObject';
  code: Scalars['String']['output'];
  /** An array relationship */
  components: Array<ApplicationComponentDataObjectMap>;
  /** An aggregate relationship */
  components_aggregate: ApplicationComponentDataObjectMap_Aggregate;
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['uuid']['output'];
  name: Scalars['String']['output'];
  ownerId?: Maybe<Scalars['uuid']['output']>;
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
  /** An array relationship */
  useInFunctions: Array<ApplicationFunctionDataObjectMap>;
  /** An aggregate relationship */
  useInFunctions_aggregate: ApplicationFunctionDataObjectMap_Aggregate;
};


/** columns and relationships of "data_objects" */
export type DataObjectComponentsArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentDataObjectMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentDataObjectMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentDataObjectMap_Bool_Exp>;
};


/** columns and relationships of "data_objects" */
export type DataObjectComponents_AggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentDataObjectMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentDataObjectMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentDataObjectMap_Bool_Exp>;
};


/** columns and relationships of "data_objects" */
export type DataObjectUseInFunctionsArgs = {
  distinct_on?: InputMaybe<Array<ApplicationFunctionDataObjectMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationFunctionDataObjectMap_Order_By>>;
  where?: InputMaybe<ApplicationFunctionDataObjectMap_Bool_Exp>;
};


/** columns and relationships of "data_objects" */
export type DataObjectUseInFunctions_AggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationFunctionDataObjectMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationFunctionDataObjectMap_Order_By>>;
  where?: InputMaybe<ApplicationFunctionDataObjectMap_Bool_Exp>;
};

/** aggregated selection of "data_objects" */
export type DataObject_Aggregate = {
  __typename?: 'DataObject_aggregate';
  aggregate?: Maybe<DataObject_Aggregate_Fields>;
  nodes: Array<DataObject>;
};

/** aggregate fields of "data_objects" */
export type DataObject_Aggregate_Fields = {
  __typename?: 'DataObject_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<DataObject_Max_Fields>;
  min?: Maybe<DataObject_Min_Fields>;
};


/** aggregate fields of "data_objects" */
export type DataObject_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<DataObject_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "data_objects". All fields are combined with a logical 'AND'. */
export type DataObject_Bool_Exp = {
  _and?: InputMaybe<Array<DataObject_Bool_Exp>>;
  _not?: InputMaybe<DataObject_Bool_Exp>;
  _or?: InputMaybe<Array<DataObject_Bool_Exp>>;
  code?: InputMaybe<String_Comparison_Exp>;
  components?: InputMaybe<ApplicationComponentDataObjectMap_Bool_Exp>;
  components_aggregate?: InputMaybe<ApplicationComponentDataObjectMap_Aggregate_Bool_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  ownerId?: InputMaybe<Uuid_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
  useInFunctions?: InputMaybe<ApplicationFunctionDataObjectMap_Bool_Exp>;
  useInFunctions_aggregate?: InputMaybe<ApplicationFunctionDataObjectMap_Aggregate_Bool_Exp>;
};

/** unique or primary key constraints on table "data_objects" */
export enum DataObject_Constraint {
  /** unique or primary key constraint on columns "code" */
  DataObjectsCodeUnique = 'data_objects_code_unique',
  /** unique or primary key constraint on columns "id" */
  DataObjectsPkey = 'data_objects_pkey'
}

/** input type for inserting data into table "data_objects" */
export type DataObject_Insert_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  components?: InputMaybe<ApplicationComponentDataObjectMap_Arr_Rel_Insert_Input>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
  useInFunctions?: InputMaybe<ApplicationFunctionDataObjectMap_Arr_Rel_Insert_Input>;
};

/** aggregate max on columns */
export type DataObject_Max_Fields = {
  __typename?: 'DataObject_max_fields';
  code?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  ownerId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type DataObject_Min_Fields = {
  __typename?: 'DataObject_min_fields';
  code?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  ownerId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "data_objects" */
export type DataObject_Mutation_Response = {
  __typename?: 'DataObject_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<DataObject>;
};

/** input type for inserting object relation for remote table "data_objects" */
export type DataObject_Obj_Rel_Insert_Input = {
  data: DataObject_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<DataObject_On_Conflict>;
};

/** on_conflict condition type for table "data_objects" */
export type DataObject_On_Conflict = {
  constraint: DataObject_Constraint;
  update_columns?: Array<DataObject_Update_Column>;
  where?: InputMaybe<DataObject_Bool_Exp>;
};

/** Ordering options when selecting data from "data_objects". */
export type DataObject_Order_By = {
  code?: InputMaybe<Order_By>;
  components_aggregate?: InputMaybe<ApplicationComponentDataObjectMap_Aggregate_Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  ownerId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
  useInFunctions_aggregate?: InputMaybe<ApplicationFunctionDataObjectMap_Aggregate_Order_By>;
};

/** primary key columns input for table: data_objects */
export type DataObject_Pk_Columns_Input = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "data_objects" */
export enum DataObject_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  OwnerId = 'ownerId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "data_objects" */
export type DataObject_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "DataObject" */
export type DataObject_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: DataObject_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type DataObject_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "data_objects" */
export enum DataObject_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  OwnerId = 'ownerId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type DataObject_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<DataObject_Set_Input>;
  /** filter the rows which have to be updated */
  where: DataObject_Bool_Exp;
};

/** columns and relationships of "map_directory_items" */
export type DirectoryItemsMap = {
  __typename?: 'DirectoryItemsMap';
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  source: DirectoryObject;
  sourceId: Scalars['uuid']['output'];
  /** An object relationship */
  target: DirectoryObject;
  targetId: Scalars['uuid']['output'];
  tenantId: Scalars['uuid']['output'];
  type: Scalars['directory_link_type_enum']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "map_directory_items" */
export type DirectoryItemsMap_Aggregate = {
  __typename?: 'DirectoryItemsMap_aggregate';
  aggregate?: Maybe<DirectoryItemsMap_Aggregate_Fields>;
  nodes: Array<DirectoryItemsMap>;
};

export type DirectoryItemsMap_Aggregate_Bool_Exp = {
  count?: InputMaybe<DirectoryItemsMap_Aggregate_Bool_Exp_Count>;
};

export type DirectoryItemsMap_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<DirectoryItemsMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<DirectoryItemsMap_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "map_directory_items" */
export type DirectoryItemsMap_Aggregate_Fields = {
  __typename?: 'DirectoryItemsMap_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<DirectoryItemsMap_Max_Fields>;
  min?: Maybe<DirectoryItemsMap_Min_Fields>;
};


/** aggregate fields of "map_directory_items" */
export type DirectoryItemsMap_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<DirectoryItemsMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "map_directory_items" */
export type DirectoryItemsMap_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<DirectoryItemsMap_Max_Order_By>;
  min?: InputMaybe<DirectoryItemsMap_Min_Order_By>;
};

/** input type for inserting array relation for remote table "map_directory_items" */
export type DirectoryItemsMap_Arr_Rel_Insert_Input = {
  data: Array<DirectoryItemsMap_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<DirectoryItemsMap_On_Conflict>;
};

/** Boolean expression to filter rows from the table "map_directory_items". All fields are combined with a logical 'AND'. */
export type DirectoryItemsMap_Bool_Exp = {
  _and?: InputMaybe<Array<DirectoryItemsMap_Bool_Exp>>;
  _not?: InputMaybe<DirectoryItemsMap_Bool_Exp>;
  _or?: InputMaybe<Array<DirectoryItemsMap_Bool_Exp>>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  source?: InputMaybe<DirectoryObject_Bool_Exp>;
  sourceId?: InputMaybe<Uuid_Comparison_Exp>;
  target?: InputMaybe<DirectoryObject_Bool_Exp>;
  targetId?: InputMaybe<Uuid_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  type?: InputMaybe<Directory_Link_Type_Enum_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "map_directory_items" */
export enum DirectoryItemsMap_Constraint {
  /** unique or primary key constraint on columns "target_id", "source_id" */
  MapDirectoryItemsPkey = 'map_directory_items_pkey',
  /** unique or primary key constraint on columns "target_id", "source_id" */
  MapDirectoryItemsSourceIdTargetIdUnique = 'map_directory_items_source_id_target_id_unique'
}

/** input type for inserting data into table "map_directory_items" */
export type DirectoryItemsMap_Insert_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  source?: InputMaybe<DirectoryObject_Obj_Rel_Insert_Input>;
  sourceId?: InputMaybe<Scalars['uuid']['input']>;
  target?: InputMaybe<DirectoryObject_Obj_Rel_Insert_Input>;
  targetId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  type?: InputMaybe<Scalars['directory_link_type_enum']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type DirectoryItemsMap_Max_Fields = {
  __typename?: 'DirectoryItemsMap_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  sourceId?: Maybe<Scalars['uuid']['output']>;
  targetId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  type?: Maybe<Scalars['directory_link_type_enum']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "map_directory_items" */
export type DirectoryItemsMap_Max_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  sourceId?: InputMaybe<Order_By>;
  targetId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type DirectoryItemsMap_Min_Fields = {
  __typename?: 'DirectoryItemsMap_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  sourceId?: Maybe<Scalars['uuid']['output']>;
  targetId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  type?: Maybe<Scalars['directory_link_type_enum']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "map_directory_items" */
export type DirectoryItemsMap_Min_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  sourceId?: InputMaybe<Order_By>;
  targetId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "map_directory_items" */
export type DirectoryItemsMap_Mutation_Response = {
  __typename?: 'DirectoryItemsMap_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<DirectoryItemsMap>;
};

/** on_conflict condition type for table "map_directory_items" */
export type DirectoryItemsMap_On_Conflict = {
  constraint: DirectoryItemsMap_Constraint;
  update_columns?: Array<DirectoryItemsMap_Update_Column>;
  where?: InputMaybe<DirectoryItemsMap_Bool_Exp>;
};

/** Ordering options when selecting data from "map_directory_items". */
export type DirectoryItemsMap_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  source?: InputMaybe<DirectoryObject_Order_By>;
  sourceId?: InputMaybe<Order_By>;
  target?: InputMaybe<DirectoryObject_Order_By>;
  targetId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  type?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: map_directory_items */
export type DirectoryItemsMap_Pk_Columns_Input = {
  sourceId: Scalars['uuid']['input'];
  targetId: Scalars['uuid']['input'];
};

/** select columns of table "map_directory_items" */
export enum DirectoryItemsMap_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  SourceId = 'sourceId',
  /** column name */
  TargetId = 'targetId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "map_directory_items" */
export type DirectoryItemsMap_Set_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  sourceId?: InputMaybe<Scalars['uuid']['input']>;
  targetId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  type?: InputMaybe<Scalars['directory_link_type_enum']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "DirectoryItemsMap" */
export type DirectoryItemsMap_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: DirectoryItemsMap_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type DirectoryItemsMap_Stream_Cursor_Value_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  sourceId?: InputMaybe<Scalars['uuid']['input']>;
  targetId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  type?: InputMaybe<Scalars['directory_link_type_enum']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "map_directory_items" */
export enum DirectoryItemsMap_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  SourceId = 'sourceId',
  /** column name */
  TargetId = 'targetId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  Type = 'type',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type DirectoryItemsMap_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<DirectoryItemsMap_Set_Input>;
  /** filter the rows which have to be updated */
  where: DirectoryItemsMap_Bool_Exp;
};

/** columns and relationships of "directories" */
export type DirectoryObject = {
  __typename?: 'DirectoryObject';
  /** An array relationship */
  architectureStyle: Array<ApplicationComponent>;
  /** An aggregate relationship */
  architectureStyle_aggregate: ApplicationComponent_Aggregate;
  byDefault: Scalars['Boolean']['output'];
  code: Scalars['String']['output'];
  color?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  components: Array<ApplicationComponentDirectoryMap>;
  /** An aggregate relationship */
  components_aggregate: ApplicationComponentDirectoryMap_Aggregate;
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  /** An array relationship */
  criticalLevel: Array<ApplicationComponent>;
  /** An aggregate relationship */
  criticalLevel_aggregate: ApplicationComponent_Aggregate;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  failoverType: Array<ApplicationComponent>;
  /** An aggregate relationship */
  failoverType_aggregate: ApplicationComponent_Aggregate;
  id: Scalars['uuid']['output'];
  kind: Scalars['directory_kind_enum']['output'];
  /** An array relationship */
  license: Array<SystemSoftware>;
  /** An array relationship */
  licenseComponents: Array<ApplicationComponent>;
  /** An aggregate relationship */
  licenseComponents_aggregate: ApplicationComponent_Aggregate;
  /** An aggregate relationship */
  license_aggregate: SystemSoftware_Aggregate;
  /** An array relationship */
  monitoringLevel: Array<ApplicationComponent>;
  /** An aggregate relationship */
  monitoringLevel_aggregate: ApplicationComponent_Aggregate;
  name: Scalars['String']['output'];
  /** An array relationship */
  protocol: Array<InterfaceGeneric>;
  /** An aggregate relationship */
  protocol_aggregate: InterfaceGeneric_Aggregate;
  /** An array relationship */
  recoveryTime: Array<ApplicationComponent>;
  /** An aggregate relationship */
  recoveryTime_aggregate: ApplicationComponent_Aggregate;
  /** An array relationship */
  redundancyType: Array<ApplicationComponent>;
  /** An aggregate relationship */
  redundancyType_aggregate: ApplicationComponent_Aggregate;
  /** An array relationship */
  scalingType: Array<ApplicationComponent>;
  /** An aggregate relationship */
  scalingType_aggregate: ApplicationComponent_Aggregate;
  /** An array relationship */
  source: Array<DirectoryItemsMap>;
  /** An aggregate relationship */
  source_aggregate: DirectoryItemsMap_Aggregate;
  /** An array relationship */
  state: Array<ApplicationComponent>;
  /** An aggregate relationship */
  state_aggregate: ApplicationComponent_Aggregate;
  /** An array relationship */
  target: Array<DirectoryItemsMap>;
  /** An aggregate relationship */
  target_aggregate: DirectoryItemsMap_Aggregate;
  /** An array relationship */
  type: Array<SystemSoftware>;
  /** An array relationship */
  typeTechnologyNodes: Array<TechnologyNode>;
  /** An aggregate relationship */
  typeTechnologyNodes_aggregate: TechnologyNode_Aggregate;
  /** An aggregate relationship */
  type_aggregate: SystemSoftware_Aggregate;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};


/** columns and relationships of "directories" */
export type DirectoryObjectArchitectureStyleArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponent_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponent_Order_By>>;
  where?: InputMaybe<ApplicationComponent_Bool_Exp>;
};


/** columns and relationships of "directories" */
export type DirectoryObjectArchitectureStyle_AggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponent_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponent_Order_By>>;
  where?: InputMaybe<ApplicationComponent_Bool_Exp>;
};


/** columns and relationships of "directories" */
export type DirectoryObjectComponentsArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentDirectoryMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentDirectoryMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentDirectoryMap_Bool_Exp>;
};


/** columns and relationships of "directories" */
export type DirectoryObjectComponents_AggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentDirectoryMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentDirectoryMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentDirectoryMap_Bool_Exp>;
};


/** columns and relationships of "directories" */
export type DirectoryObjectCriticalLevelArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponent_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponent_Order_By>>;
  where?: InputMaybe<ApplicationComponent_Bool_Exp>;
};


/** columns and relationships of "directories" */
export type DirectoryObjectCriticalLevel_AggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponent_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponent_Order_By>>;
  where?: InputMaybe<ApplicationComponent_Bool_Exp>;
};


/** columns and relationships of "directories" */
export type DirectoryObjectFailoverTypeArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponent_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponent_Order_By>>;
  where?: InputMaybe<ApplicationComponent_Bool_Exp>;
};


/** columns and relationships of "directories" */
export type DirectoryObjectFailoverType_AggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponent_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponent_Order_By>>;
  where?: InputMaybe<ApplicationComponent_Bool_Exp>;
};


/** columns and relationships of "directories" */
export type DirectoryObjectLicenseArgs = {
  distinct_on?: InputMaybe<Array<SystemSoftware_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SystemSoftware_Order_By>>;
  where?: InputMaybe<SystemSoftware_Bool_Exp>;
};


/** columns and relationships of "directories" */
export type DirectoryObjectLicenseComponentsArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponent_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponent_Order_By>>;
  where?: InputMaybe<ApplicationComponent_Bool_Exp>;
};


/** columns and relationships of "directories" */
export type DirectoryObjectLicenseComponents_AggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponent_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponent_Order_By>>;
  where?: InputMaybe<ApplicationComponent_Bool_Exp>;
};


/** columns and relationships of "directories" */
export type DirectoryObjectLicense_AggregateArgs = {
  distinct_on?: InputMaybe<Array<SystemSoftware_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SystemSoftware_Order_By>>;
  where?: InputMaybe<SystemSoftware_Bool_Exp>;
};


/** columns and relationships of "directories" */
export type DirectoryObjectMonitoringLevelArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponent_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponent_Order_By>>;
  where?: InputMaybe<ApplicationComponent_Bool_Exp>;
};


/** columns and relationships of "directories" */
export type DirectoryObjectMonitoringLevel_AggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponent_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponent_Order_By>>;
  where?: InputMaybe<ApplicationComponent_Bool_Exp>;
};


/** columns and relationships of "directories" */
export type DirectoryObjectProtocolArgs = {
  distinct_on?: InputMaybe<Array<InterfaceGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<InterfaceGeneric_Order_By>>;
  where?: InputMaybe<InterfaceGeneric_Bool_Exp>;
};


/** columns and relationships of "directories" */
export type DirectoryObjectProtocol_AggregateArgs = {
  distinct_on?: InputMaybe<Array<InterfaceGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<InterfaceGeneric_Order_By>>;
  where?: InputMaybe<InterfaceGeneric_Bool_Exp>;
};


/** columns and relationships of "directories" */
export type DirectoryObjectRecoveryTimeArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponent_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponent_Order_By>>;
  where?: InputMaybe<ApplicationComponent_Bool_Exp>;
};


/** columns and relationships of "directories" */
export type DirectoryObjectRecoveryTime_AggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponent_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponent_Order_By>>;
  where?: InputMaybe<ApplicationComponent_Bool_Exp>;
};


/** columns and relationships of "directories" */
export type DirectoryObjectRedundancyTypeArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponent_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponent_Order_By>>;
  where?: InputMaybe<ApplicationComponent_Bool_Exp>;
};


/** columns and relationships of "directories" */
export type DirectoryObjectRedundancyType_AggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponent_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponent_Order_By>>;
  where?: InputMaybe<ApplicationComponent_Bool_Exp>;
};


/** columns and relationships of "directories" */
export type DirectoryObjectScalingTypeArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponent_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponent_Order_By>>;
  where?: InputMaybe<ApplicationComponent_Bool_Exp>;
};


/** columns and relationships of "directories" */
export type DirectoryObjectScalingType_AggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponent_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponent_Order_By>>;
  where?: InputMaybe<ApplicationComponent_Bool_Exp>;
};


/** columns and relationships of "directories" */
export type DirectoryObjectSourceArgs = {
  distinct_on?: InputMaybe<Array<DirectoryItemsMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<DirectoryItemsMap_Order_By>>;
  where?: InputMaybe<DirectoryItemsMap_Bool_Exp>;
};


/** columns and relationships of "directories" */
export type DirectoryObjectSource_AggregateArgs = {
  distinct_on?: InputMaybe<Array<DirectoryItemsMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<DirectoryItemsMap_Order_By>>;
  where?: InputMaybe<DirectoryItemsMap_Bool_Exp>;
};


/** columns and relationships of "directories" */
export type DirectoryObjectStateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponent_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponent_Order_By>>;
  where?: InputMaybe<ApplicationComponent_Bool_Exp>;
};


/** columns and relationships of "directories" */
export type DirectoryObjectState_AggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponent_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponent_Order_By>>;
  where?: InputMaybe<ApplicationComponent_Bool_Exp>;
};


/** columns and relationships of "directories" */
export type DirectoryObjectTargetArgs = {
  distinct_on?: InputMaybe<Array<DirectoryItemsMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<DirectoryItemsMap_Order_By>>;
  where?: InputMaybe<DirectoryItemsMap_Bool_Exp>;
};


/** columns and relationships of "directories" */
export type DirectoryObjectTarget_AggregateArgs = {
  distinct_on?: InputMaybe<Array<DirectoryItemsMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<DirectoryItemsMap_Order_By>>;
  where?: InputMaybe<DirectoryItemsMap_Bool_Exp>;
};


/** columns and relationships of "directories" */
export type DirectoryObjectTypeArgs = {
  distinct_on?: InputMaybe<Array<SystemSoftware_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SystemSoftware_Order_By>>;
  where?: InputMaybe<SystemSoftware_Bool_Exp>;
};


/** columns and relationships of "directories" */
export type DirectoryObjectTypeTechnologyNodesArgs = {
  distinct_on?: InputMaybe<Array<TechnologyNode_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TechnologyNode_Order_By>>;
  where?: InputMaybe<TechnologyNode_Bool_Exp>;
};


/** columns and relationships of "directories" */
export type DirectoryObjectTypeTechnologyNodes_AggregateArgs = {
  distinct_on?: InputMaybe<Array<TechnologyNode_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TechnologyNode_Order_By>>;
  where?: InputMaybe<TechnologyNode_Bool_Exp>;
};


/** columns and relationships of "directories" */
export type DirectoryObjectType_AggregateArgs = {
  distinct_on?: InputMaybe<Array<SystemSoftware_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SystemSoftware_Order_By>>;
  where?: InputMaybe<SystemSoftware_Bool_Exp>;
};

/** aggregated selection of "directories" */
export type DirectoryObject_Aggregate = {
  __typename?: 'DirectoryObject_aggregate';
  aggregate?: Maybe<DirectoryObject_Aggregate_Fields>;
  nodes: Array<DirectoryObject>;
};

/** aggregate fields of "directories" */
export type DirectoryObject_Aggregate_Fields = {
  __typename?: 'DirectoryObject_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<DirectoryObject_Max_Fields>;
  min?: Maybe<DirectoryObject_Min_Fields>;
};


/** aggregate fields of "directories" */
export type DirectoryObject_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<DirectoryObject_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "directories". All fields are combined with a logical 'AND'. */
export type DirectoryObject_Bool_Exp = {
  _and?: InputMaybe<Array<DirectoryObject_Bool_Exp>>;
  _not?: InputMaybe<DirectoryObject_Bool_Exp>;
  _or?: InputMaybe<Array<DirectoryObject_Bool_Exp>>;
  architectureStyle?: InputMaybe<ApplicationComponent_Bool_Exp>;
  architectureStyle_aggregate?: InputMaybe<ApplicationComponent_Aggregate_Bool_Exp>;
  byDefault?: InputMaybe<Boolean_Comparison_Exp>;
  code?: InputMaybe<String_Comparison_Exp>;
  color?: InputMaybe<String_Comparison_Exp>;
  components?: InputMaybe<ApplicationComponentDirectoryMap_Bool_Exp>;
  components_aggregate?: InputMaybe<ApplicationComponentDirectoryMap_Aggregate_Bool_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  criticalLevel?: InputMaybe<ApplicationComponent_Bool_Exp>;
  criticalLevel_aggregate?: InputMaybe<ApplicationComponent_Aggregate_Bool_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  failoverType?: InputMaybe<ApplicationComponent_Bool_Exp>;
  failoverType_aggregate?: InputMaybe<ApplicationComponent_Aggregate_Bool_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  kind?: InputMaybe<Directory_Kind_Enum_Comparison_Exp>;
  license?: InputMaybe<SystemSoftware_Bool_Exp>;
  licenseComponents?: InputMaybe<ApplicationComponent_Bool_Exp>;
  licenseComponents_aggregate?: InputMaybe<ApplicationComponent_Aggregate_Bool_Exp>;
  license_aggregate?: InputMaybe<SystemSoftware_Aggregate_Bool_Exp>;
  monitoringLevel?: InputMaybe<ApplicationComponent_Bool_Exp>;
  monitoringLevel_aggregate?: InputMaybe<ApplicationComponent_Aggregate_Bool_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  protocol?: InputMaybe<InterfaceGeneric_Bool_Exp>;
  protocol_aggregate?: InputMaybe<InterfaceGeneric_Aggregate_Bool_Exp>;
  recoveryTime?: InputMaybe<ApplicationComponent_Bool_Exp>;
  recoveryTime_aggregate?: InputMaybe<ApplicationComponent_Aggregate_Bool_Exp>;
  redundancyType?: InputMaybe<ApplicationComponent_Bool_Exp>;
  redundancyType_aggregate?: InputMaybe<ApplicationComponent_Aggregate_Bool_Exp>;
  scalingType?: InputMaybe<ApplicationComponent_Bool_Exp>;
  scalingType_aggregate?: InputMaybe<ApplicationComponent_Aggregate_Bool_Exp>;
  source?: InputMaybe<DirectoryItemsMap_Bool_Exp>;
  source_aggregate?: InputMaybe<DirectoryItemsMap_Aggregate_Bool_Exp>;
  state?: InputMaybe<ApplicationComponent_Bool_Exp>;
  state_aggregate?: InputMaybe<ApplicationComponent_Aggregate_Bool_Exp>;
  target?: InputMaybe<DirectoryItemsMap_Bool_Exp>;
  target_aggregate?: InputMaybe<DirectoryItemsMap_Aggregate_Bool_Exp>;
  type?: InputMaybe<SystemSoftware_Bool_Exp>;
  typeTechnologyNodes?: InputMaybe<TechnologyNode_Bool_Exp>;
  typeTechnologyNodes_aggregate?: InputMaybe<TechnologyNode_Aggregate_Bool_Exp>;
  type_aggregate?: InputMaybe<SystemSoftware_Aggregate_Bool_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "directories" */
export enum DirectoryObject_Constraint {
  /** unique or primary key constraint on columns "code" */
  DirectoriesCodeUnique = 'directories_code_unique',
  /** unique or primary key constraint on columns "id" */
  DirectoriesPkey = 'directories_pkey'
}

/** input type for inserting data into table "directories" */
export type DirectoryObject_Insert_Input = {
  architectureStyle?: InputMaybe<ApplicationComponent_Arr_Rel_Insert_Input>;
  byDefault?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  color?: InputMaybe<Scalars['String']['input']>;
  components?: InputMaybe<ApplicationComponentDirectoryMap_Arr_Rel_Insert_Input>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  criticalLevel?: InputMaybe<ApplicationComponent_Arr_Rel_Insert_Input>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  failoverType?: InputMaybe<ApplicationComponent_Arr_Rel_Insert_Input>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  kind?: InputMaybe<Scalars['directory_kind_enum']['input']>;
  license?: InputMaybe<SystemSoftware_Arr_Rel_Insert_Input>;
  licenseComponents?: InputMaybe<ApplicationComponent_Arr_Rel_Insert_Input>;
  monitoringLevel?: InputMaybe<ApplicationComponent_Arr_Rel_Insert_Input>;
  name?: InputMaybe<Scalars['String']['input']>;
  protocol?: InputMaybe<InterfaceGeneric_Arr_Rel_Insert_Input>;
  recoveryTime?: InputMaybe<ApplicationComponent_Arr_Rel_Insert_Input>;
  redundancyType?: InputMaybe<ApplicationComponent_Arr_Rel_Insert_Input>;
  scalingType?: InputMaybe<ApplicationComponent_Arr_Rel_Insert_Input>;
  source?: InputMaybe<DirectoryItemsMap_Arr_Rel_Insert_Input>;
  state?: InputMaybe<ApplicationComponent_Arr_Rel_Insert_Input>;
  target?: InputMaybe<DirectoryItemsMap_Arr_Rel_Insert_Input>;
  type?: InputMaybe<SystemSoftware_Arr_Rel_Insert_Input>;
  typeTechnologyNodes?: InputMaybe<TechnologyNode_Arr_Rel_Insert_Input>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type DirectoryObject_Max_Fields = {
  __typename?: 'DirectoryObject_max_fields';
  code?: Maybe<Scalars['String']['output']>;
  color?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  kind?: Maybe<Scalars['directory_kind_enum']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type DirectoryObject_Min_Fields = {
  __typename?: 'DirectoryObject_min_fields';
  code?: Maybe<Scalars['String']['output']>;
  color?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  kind?: Maybe<Scalars['directory_kind_enum']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "directories" */
export type DirectoryObject_Mutation_Response = {
  __typename?: 'DirectoryObject_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<DirectoryObject>;
};

/** input type for inserting object relation for remote table "directories" */
export type DirectoryObject_Obj_Rel_Insert_Input = {
  data: DirectoryObject_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<DirectoryObject_On_Conflict>;
};

/** on_conflict condition type for table "directories" */
export type DirectoryObject_On_Conflict = {
  constraint: DirectoryObject_Constraint;
  update_columns?: Array<DirectoryObject_Update_Column>;
  where?: InputMaybe<DirectoryObject_Bool_Exp>;
};

/** Ordering options when selecting data from "directories". */
export type DirectoryObject_Order_By = {
  architectureStyle_aggregate?: InputMaybe<ApplicationComponent_Aggregate_Order_By>;
  byDefault?: InputMaybe<Order_By>;
  code?: InputMaybe<Order_By>;
  color?: InputMaybe<Order_By>;
  components_aggregate?: InputMaybe<ApplicationComponentDirectoryMap_Aggregate_Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  criticalLevel_aggregate?: InputMaybe<ApplicationComponent_Aggregate_Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  failoverType_aggregate?: InputMaybe<ApplicationComponent_Aggregate_Order_By>;
  id?: InputMaybe<Order_By>;
  kind?: InputMaybe<Order_By>;
  licenseComponents_aggregate?: InputMaybe<ApplicationComponent_Aggregate_Order_By>;
  license_aggregate?: InputMaybe<SystemSoftware_Aggregate_Order_By>;
  monitoringLevel_aggregate?: InputMaybe<ApplicationComponent_Aggregate_Order_By>;
  name?: InputMaybe<Order_By>;
  protocol_aggregate?: InputMaybe<InterfaceGeneric_Aggregate_Order_By>;
  recoveryTime_aggregate?: InputMaybe<ApplicationComponent_Aggregate_Order_By>;
  redundancyType_aggregate?: InputMaybe<ApplicationComponent_Aggregate_Order_By>;
  scalingType_aggregate?: InputMaybe<ApplicationComponent_Aggregate_Order_By>;
  source_aggregate?: InputMaybe<DirectoryItemsMap_Aggregate_Order_By>;
  state_aggregate?: InputMaybe<ApplicationComponent_Aggregate_Order_By>;
  target_aggregate?: InputMaybe<DirectoryItemsMap_Aggregate_Order_By>;
  typeTechnologyNodes_aggregate?: InputMaybe<TechnologyNode_Aggregate_Order_By>;
  type_aggregate?: InputMaybe<SystemSoftware_Aggregate_Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: directories */
export type DirectoryObject_Pk_Columns_Input = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "directories" */
export enum DirectoryObject_Select_Column {
  /** column name */
  ByDefault = 'byDefault',
  /** column name */
  Code = 'code',
  /** column name */
  Color = 'color',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Kind = 'kind',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "directories" */
export type DirectoryObject_Set_Input = {
  byDefault?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  color?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  kind?: InputMaybe<Scalars['directory_kind_enum']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "DirectoryObject" */
export type DirectoryObject_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: DirectoryObject_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type DirectoryObject_Stream_Cursor_Value_Input = {
  byDefault?: InputMaybe<Scalars['Boolean']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  color?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  kind?: InputMaybe<Scalars['directory_kind_enum']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "directories" */
export enum DirectoryObject_Update_Column {
  /** column name */
  ByDefault = 'byDefault',
  /** column name */
  Code = 'code',
  /** column name */
  Color = 'color',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Kind = 'kind',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type DirectoryObject_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<DirectoryObject_Set_Input>;
  /** filter the rows which have to be updated */
  where: DirectoryObject_Bool_Exp;
};

/** columns and relationships of "employees" */
export type Employee = {
  __typename?: 'Employee';
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  firstName: Scalars['String']['output'];
  id: Scalars['uuid']['output'];
  lastName: Scalars['String']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
  userId: Scalars['uuid']['output'];
};

/** aggregated selection of "employees" */
export type Employee_Aggregate = {
  __typename?: 'Employee_aggregate';
  aggregate?: Maybe<Employee_Aggregate_Fields>;
  nodes: Array<Employee>;
};

/** aggregate fields of "employees" */
export type Employee_Aggregate_Fields = {
  __typename?: 'Employee_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Employee_Max_Fields>;
  min?: Maybe<Employee_Min_Fields>;
};


/** aggregate fields of "employees" */
export type Employee_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Employee_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "employees". All fields are combined with a logical 'AND'. */
export type Employee_Bool_Exp = {
  _and?: InputMaybe<Array<Employee_Bool_Exp>>;
  _not?: InputMaybe<Employee_Bool_Exp>;
  _or?: InputMaybe<Array<Employee_Bool_Exp>>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  firstName?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  lastName?: InputMaybe<String_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
  userId?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "employees" */
export enum Employee_Constraint {
  /** unique or primary key constraint on columns "id" */
  EmployeesPkey = 'employees_pkey',
  /** unique or primary key constraint on columns "user_id" */
  EmployeesUserIdUnique = 'employees_user_id_unique'
}

/** input type for inserting data into table "employees" */
export type Employee_Insert_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Employee_Max_Fields = {
  __typename?: 'Employee_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  firstName?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastName?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type Employee_Min_Fields = {
  __typename?: 'Employee_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  firstName?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastName?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "employees" */
export type Employee_Mutation_Response = {
  __typename?: 'Employee_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Employee>;
};

/** on_conflict condition type for table "employees" */
export type Employee_On_Conflict = {
  constraint: Employee_Constraint;
  update_columns?: Array<Employee_Update_Column>;
  where?: InputMaybe<Employee_Bool_Exp>;
};

/** Ordering options when selecting data from "employees". */
export type Employee_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  firstName?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  lastName?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
  userId?: InputMaybe<Order_By>;
};

/** primary key columns input for table: employees */
export type Employee_Pk_Columns_Input = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "employees" */
export enum Employee_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  FirstName = 'firstName',
  /** column name */
  Id = 'id',
  /** column name */
  LastName = 'lastName',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "employees" */
export type Employee_Set_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "Employee" */
export type Employee_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Employee_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Employee_Stream_Cursor_Value_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "employees" */
export enum Employee_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  FirstName = 'firstName',
  /** column name */
  Id = 'id',
  /** column name */
  LastName = 'lastName',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy',
  /** column name */
  UserId = 'userId'
}

export type Employee_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Employee_Set_Input>;
  /** filter the rows which have to be updated */
  where: Employee_Bool_Exp;
};

/** columns and relationships of "events" */
export type EventGeneric = {
  __typename?: 'EventGeneric';
  code: Scalars['String']['output'];
  /** An array relationship */
  components: Array<ApplicationComponentEventMap>;
  /** An aggregate relationship */
  components_aggregate: ApplicationComponentEventMap_Aggregate;
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['uuid']['output'];
  layer: Scalars['layer_kind_enum']['output'];
  name: Scalars['String']['output'];
  ownerId?: Maybe<Scalars['uuid']['output']>;
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};


/** columns and relationships of "events" */
export type EventGenericComponentsArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentEventMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentEventMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentEventMap_Bool_Exp>;
};


/** columns and relationships of "events" */
export type EventGenericComponents_AggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentEventMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentEventMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentEventMap_Bool_Exp>;
};

/** aggregated selection of "events" */
export type EventGeneric_Aggregate = {
  __typename?: 'EventGeneric_aggregate';
  aggregate?: Maybe<EventGeneric_Aggregate_Fields>;
  nodes: Array<EventGeneric>;
};

/** aggregate fields of "events" */
export type EventGeneric_Aggregate_Fields = {
  __typename?: 'EventGeneric_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<EventGeneric_Max_Fields>;
  min?: Maybe<EventGeneric_Min_Fields>;
};


/** aggregate fields of "events" */
export type EventGeneric_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<EventGeneric_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "events". All fields are combined with a logical 'AND'. */
export type EventGeneric_Bool_Exp = {
  _and?: InputMaybe<Array<EventGeneric_Bool_Exp>>;
  _not?: InputMaybe<EventGeneric_Bool_Exp>;
  _or?: InputMaybe<Array<EventGeneric_Bool_Exp>>;
  code?: InputMaybe<String_Comparison_Exp>;
  components?: InputMaybe<ApplicationComponentEventMap_Bool_Exp>;
  components_aggregate?: InputMaybe<ApplicationComponentEventMap_Aggregate_Bool_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  layer?: InputMaybe<Layer_Kind_Enum_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  ownerId?: InputMaybe<Uuid_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "events" */
export enum EventGeneric_Constraint {
  /** unique or primary key constraint on columns "code" */
  EventsCodeUnique = 'events_code_unique',
  /** unique or primary key constraint on columns "id" */
  EventsPkey = 'events_pkey'
}

/** input type for inserting data into table "events" */
export type EventGeneric_Insert_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  components?: InputMaybe<ApplicationComponentEventMap_Arr_Rel_Insert_Input>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  layer?: InputMaybe<Scalars['layer_kind_enum']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type EventGeneric_Max_Fields = {
  __typename?: 'EventGeneric_max_fields';
  code?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  layer?: Maybe<Scalars['layer_kind_enum']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  ownerId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type EventGeneric_Min_Fields = {
  __typename?: 'EventGeneric_min_fields';
  code?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  layer?: Maybe<Scalars['layer_kind_enum']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  ownerId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "events" */
export type EventGeneric_Mutation_Response = {
  __typename?: 'EventGeneric_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<EventGeneric>;
};

/** input type for inserting object relation for remote table "events" */
export type EventGeneric_Obj_Rel_Insert_Input = {
  data: EventGeneric_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<EventGeneric_On_Conflict>;
};

/** on_conflict condition type for table "events" */
export type EventGeneric_On_Conflict = {
  constraint: EventGeneric_Constraint;
  update_columns?: Array<EventGeneric_Update_Column>;
  where?: InputMaybe<EventGeneric_Bool_Exp>;
};

/** Ordering options when selecting data from "events". */
export type EventGeneric_Order_By = {
  code?: InputMaybe<Order_By>;
  components_aggregate?: InputMaybe<ApplicationComponentEventMap_Aggregate_Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  layer?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  ownerId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: events */
export type EventGeneric_Pk_Columns_Input = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "events" */
export enum EventGeneric_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Layer = 'layer',
  /** column name */
  Name = 'name',
  /** column name */
  OwnerId = 'ownerId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "events" */
export type EventGeneric_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  layer?: InputMaybe<Scalars['layer_kind_enum']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "EventGeneric" */
export type EventGeneric_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: EventGeneric_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type EventGeneric_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  layer?: InputMaybe<Scalars['layer_kind_enum']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "events" */
export enum EventGeneric_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Layer = 'layer',
  /** column name */
  Name = 'name',
  /** column name */
  OwnerId = 'ownerId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type EventGeneric_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<EventGeneric_Set_Input>;
  /** filter the rows which have to be updated */
  where: EventGeneric_Bool_Exp;
};

/** columns and relationships of "flows" */
export type FlowGeneric = {
  __typename?: 'FlowGeneric';
  code: Scalars['String']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  environment?: Maybe<Scalars['environment_enum']['output']>;
  id: Scalars['uuid']['output'];
  layer: Scalars['layer_kind_enum']['output'];
  name: Scalars['String']['output'];
  requestDataObjectId?: Maybe<Scalars['uuid']['output']>;
  responseDataObjectId?: Maybe<Scalars['uuid']['output']>;
  /** An array relationship */
  solutions: Array<SolutionFlowMap>;
  /** An aggregate relationship */
  solutions_aggregate: SolutionFlowMap_Aggregate;
  /** An object relationship */
  sourceComponent?: Maybe<ApplicationComponent>;
  sourceComponentId?: Maybe<Scalars['uuid']['output']>;
  sourceFunctionId?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  sourceNode?: Maybe<TechnologyNode>;
  sourceNodeId?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  sourcePort?: Maybe<InterfaceGeneric>;
  sourcePortId?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  targetComponent?: Maybe<ApplicationComponent>;
  targetComponentId?: Maybe<Scalars['uuid']['output']>;
  targetFunctionId?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  targetNode?: Maybe<TechnologyNode>;
  targetNodeId?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  targetPort?: Maybe<InterfaceGeneric>;
  targetPortId?: Maybe<Scalars['uuid']['output']>;
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};


/** columns and relationships of "flows" */
export type FlowGenericSolutionsArgs = {
  distinct_on?: InputMaybe<Array<SolutionFlowMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionFlowMap_Order_By>>;
  where?: InputMaybe<SolutionFlowMap_Bool_Exp>;
};


/** columns and relationships of "flows" */
export type FlowGenericSolutions_AggregateArgs = {
  distinct_on?: InputMaybe<Array<SolutionFlowMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionFlowMap_Order_By>>;
  where?: InputMaybe<SolutionFlowMap_Bool_Exp>;
};

/** aggregated selection of "flows" */
export type FlowGeneric_Aggregate = {
  __typename?: 'FlowGeneric_aggregate';
  aggregate?: Maybe<FlowGeneric_Aggregate_Fields>;
  nodes: Array<FlowGeneric>;
};

export type FlowGeneric_Aggregate_Bool_Exp = {
  count?: InputMaybe<FlowGeneric_Aggregate_Bool_Exp_Count>;
};

export type FlowGeneric_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<FlowGeneric_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<FlowGeneric_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "flows" */
export type FlowGeneric_Aggregate_Fields = {
  __typename?: 'FlowGeneric_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<FlowGeneric_Max_Fields>;
  min?: Maybe<FlowGeneric_Min_Fields>;
};


/** aggregate fields of "flows" */
export type FlowGeneric_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<FlowGeneric_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "flows" */
export type FlowGeneric_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<FlowGeneric_Max_Order_By>;
  min?: InputMaybe<FlowGeneric_Min_Order_By>;
};

/** input type for inserting array relation for remote table "flows" */
export type FlowGeneric_Arr_Rel_Insert_Input = {
  data: Array<FlowGeneric_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<FlowGeneric_On_Conflict>;
};

/** Boolean expression to filter rows from the table "flows". All fields are combined with a logical 'AND'. */
export type FlowGeneric_Bool_Exp = {
  _and?: InputMaybe<Array<FlowGeneric_Bool_Exp>>;
  _not?: InputMaybe<FlowGeneric_Bool_Exp>;
  _or?: InputMaybe<Array<FlowGeneric_Bool_Exp>>;
  code?: InputMaybe<String_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  environment?: InputMaybe<Environment_Enum_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  layer?: InputMaybe<Layer_Kind_Enum_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  requestDataObjectId?: InputMaybe<Uuid_Comparison_Exp>;
  responseDataObjectId?: InputMaybe<Uuid_Comparison_Exp>;
  solutions?: InputMaybe<SolutionFlowMap_Bool_Exp>;
  solutions_aggregate?: InputMaybe<SolutionFlowMap_Aggregate_Bool_Exp>;
  sourceComponent?: InputMaybe<ApplicationComponent_Bool_Exp>;
  sourceComponentId?: InputMaybe<Uuid_Comparison_Exp>;
  sourceFunctionId?: InputMaybe<Uuid_Comparison_Exp>;
  sourceNode?: InputMaybe<TechnologyNode_Bool_Exp>;
  sourceNodeId?: InputMaybe<Uuid_Comparison_Exp>;
  sourcePort?: InputMaybe<InterfaceGeneric_Bool_Exp>;
  sourcePortId?: InputMaybe<Uuid_Comparison_Exp>;
  targetComponent?: InputMaybe<ApplicationComponent_Bool_Exp>;
  targetComponentId?: InputMaybe<Uuid_Comparison_Exp>;
  targetFunctionId?: InputMaybe<Uuid_Comparison_Exp>;
  targetNode?: InputMaybe<TechnologyNode_Bool_Exp>;
  targetNodeId?: InputMaybe<Uuid_Comparison_Exp>;
  targetPort?: InputMaybe<InterfaceGeneric_Bool_Exp>;
  targetPortId?: InputMaybe<Uuid_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "flows" */
export enum FlowGeneric_Constraint {
  /** unique or primary key constraint on columns "code" */
  FlowsCodeUnique = 'flows_code_unique',
  /** unique or primary key constraint on columns "id" */
  FlowsPkey = 'flows_pkey'
}

/** input type for inserting data into table "flows" */
export type FlowGeneric_Insert_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  environment?: InputMaybe<Scalars['environment_enum']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  layer?: InputMaybe<Scalars['layer_kind_enum']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  requestDataObjectId?: InputMaybe<Scalars['uuid']['input']>;
  responseDataObjectId?: InputMaybe<Scalars['uuid']['input']>;
  solutions?: InputMaybe<SolutionFlowMap_Arr_Rel_Insert_Input>;
  sourceComponent?: InputMaybe<ApplicationComponent_Obj_Rel_Insert_Input>;
  sourceComponentId?: InputMaybe<Scalars['uuid']['input']>;
  sourceFunctionId?: InputMaybe<Scalars['uuid']['input']>;
  sourceNode?: InputMaybe<TechnologyNode_Obj_Rel_Insert_Input>;
  sourceNodeId?: InputMaybe<Scalars['uuid']['input']>;
  sourcePort?: InputMaybe<InterfaceGeneric_Obj_Rel_Insert_Input>;
  sourcePortId?: InputMaybe<Scalars['uuid']['input']>;
  targetComponent?: InputMaybe<ApplicationComponent_Obj_Rel_Insert_Input>;
  targetComponentId?: InputMaybe<Scalars['uuid']['input']>;
  targetFunctionId?: InputMaybe<Scalars['uuid']['input']>;
  targetNode?: InputMaybe<TechnologyNode_Obj_Rel_Insert_Input>;
  targetNodeId?: InputMaybe<Scalars['uuid']['input']>;
  targetPort?: InputMaybe<InterfaceGeneric_Obj_Rel_Insert_Input>;
  targetPortId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type FlowGeneric_Max_Fields = {
  __typename?: 'FlowGeneric_max_fields';
  code?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  environment?: Maybe<Scalars['environment_enum']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  layer?: Maybe<Scalars['layer_kind_enum']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  requestDataObjectId?: Maybe<Scalars['uuid']['output']>;
  responseDataObjectId?: Maybe<Scalars['uuid']['output']>;
  sourceComponentId?: Maybe<Scalars['uuid']['output']>;
  sourceFunctionId?: Maybe<Scalars['uuid']['output']>;
  sourceNodeId?: Maybe<Scalars['uuid']['output']>;
  sourcePortId?: Maybe<Scalars['uuid']['output']>;
  targetComponentId?: Maybe<Scalars['uuid']['output']>;
  targetFunctionId?: Maybe<Scalars['uuid']['output']>;
  targetNodeId?: Maybe<Scalars['uuid']['output']>;
  targetPortId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "flows" */
export type FlowGeneric_Max_Order_By = {
  code?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  environment?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  layer?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  requestDataObjectId?: InputMaybe<Order_By>;
  responseDataObjectId?: InputMaybe<Order_By>;
  sourceComponentId?: InputMaybe<Order_By>;
  sourceFunctionId?: InputMaybe<Order_By>;
  sourceNodeId?: InputMaybe<Order_By>;
  sourcePortId?: InputMaybe<Order_By>;
  targetComponentId?: InputMaybe<Order_By>;
  targetFunctionId?: InputMaybe<Order_By>;
  targetNodeId?: InputMaybe<Order_By>;
  targetPortId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type FlowGeneric_Min_Fields = {
  __typename?: 'FlowGeneric_min_fields';
  code?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  environment?: Maybe<Scalars['environment_enum']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  layer?: Maybe<Scalars['layer_kind_enum']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  requestDataObjectId?: Maybe<Scalars['uuid']['output']>;
  responseDataObjectId?: Maybe<Scalars['uuid']['output']>;
  sourceComponentId?: Maybe<Scalars['uuid']['output']>;
  sourceFunctionId?: Maybe<Scalars['uuid']['output']>;
  sourceNodeId?: Maybe<Scalars['uuid']['output']>;
  sourcePortId?: Maybe<Scalars['uuid']['output']>;
  targetComponentId?: Maybe<Scalars['uuid']['output']>;
  targetFunctionId?: Maybe<Scalars['uuid']['output']>;
  targetNodeId?: Maybe<Scalars['uuid']['output']>;
  targetPortId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "flows" */
export type FlowGeneric_Min_Order_By = {
  code?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  environment?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  layer?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  requestDataObjectId?: InputMaybe<Order_By>;
  responseDataObjectId?: InputMaybe<Order_By>;
  sourceComponentId?: InputMaybe<Order_By>;
  sourceFunctionId?: InputMaybe<Order_By>;
  sourceNodeId?: InputMaybe<Order_By>;
  sourcePortId?: InputMaybe<Order_By>;
  targetComponentId?: InputMaybe<Order_By>;
  targetFunctionId?: InputMaybe<Order_By>;
  targetNodeId?: InputMaybe<Order_By>;
  targetPortId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "flows" */
export type FlowGeneric_Mutation_Response = {
  __typename?: 'FlowGeneric_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<FlowGeneric>;
};

/** input type for inserting object relation for remote table "flows" */
export type FlowGeneric_Obj_Rel_Insert_Input = {
  data: FlowGeneric_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<FlowGeneric_On_Conflict>;
};

/** on_conflict condition type for table "flows" */
export type FlowGeneric_On_Conflict = {
  constraint: FlowGeneric_Constraint;
  update_columns?: Array<FlowGeneric_Update_Column>;
  where?: InputMaybe<FlowGeneric_Bool_Exp>;
};

/** Ordering options when selecting data from "flows". */
export type FlowGeneric_Order_By = {
  code?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  environment?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  layer?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  requestDataObjectId?: InputMaybe<Order_By>;
  responseDataObjectId?: InputMaybe<Order_By>;
  solutions_aggregate?: InputMaybe<SolutionFlowMap_Aggregate_Order_By>;
  sourceComponent?: InputMaybe<ApplicationComponent_Order_By>;
  sourceComponentId?: InputMaybe<Order_By>;
  sourceFunctionId?: InputMaybe<Order_By>;
  sourceNode?: InputMaybe<TechnologyNode_Order_By>;
  sourceNodeId?: InputMaybe<Order_By>;
  sourcePort?: InputMaybe<InterfaceGeneric_Order_By>;
  sourcePortId?: InputMaybe<Order_By>;
  targetComponent?: InputMaybe<ApplicationComponent_Order_By>;
  targetComponentId?: InputMaybe<Order_By>;
  targetFunctionId?: InputMaybe<Order_By>;
  targetNode?: InputMaybe<TechnologyNode_Order_By>;
  targetNodeId?: InputMaybe<Order_By>;
  targetPort?: InputMaybe<InterfaceGeneric_Order_By>;
  targetPortId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: flows */
export type FlowGeneric_Pk_Columns_Input = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "flows" */
export enum FlowGeneric_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Environment = 'environment',
  /** column name */
  Id = 'id',
  /** column name */
  Layer = 'layer',
  /** column name */
  Name = 'name',
  /** column name */
  RequestDataObjectId = 'requestDataObjectId',
  /** column name */
  ResponseDataObjectId = 'responseDataObjectId',
  /** column name */
  SourceComponentId = 'sourceComponentId',
  /** column name */
  SourceFunctionId = 'sourceFunctionId',
  /** column name */
  SourceNodeId = 'sourceNodeId',
  /** column name */
  SourcePortId = 'sourcePortId',
  /** column name */
  TargetComponentId = 'targetComponentId',
  /** column name */
  TargetFunctionId = 'targetFunctionId',
  /** column name */
  TargetNodeId = 'targetNodeId',
  /** column name */
  TargetPortId = 'targetPortId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "flows" */
export type FlowGeneric_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  environment?: InputMaybe<Scalars['environment_enum']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  layer?: InputMaybe<Scalars['layer_kind_enum']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  requestDataObjectId?: InputMaybe<Scalars['uuid']['input']>;
  responseDataObjectId?: InputMaybe<Scalars['uuid']['input']>;
  sourceComponentId?: InputMaybe<Scalars['uuid']['input']>;
  sourceFunctionId?: InputMaybe<Scalars['uuid']['input']>;
  sourceNodeId?: InputMaybe<Scalars['uuid']['input']>;
  sourcePortId?: InputMaybe<Scalars['uuid']['input']>;
  targetComponentId?: InputMaybe<Scalars['uuid']['input']>;
  targetFunctionId?: InputMaybe<Scalars['uuid']['input']>;
  targetNodeId?: InputMaybe<Scalars['uuid']['input']>;
  targetPortId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "FlowGeneric" */
export type FlowGeneric_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: FlowGeneric_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type FlowGeneric_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  environment?: InputMaybe<Scalars['environment_enum']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  layer?: InputMaybe<Scalars['layer_kind_enum']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  requestDataObjectId?: InputMaybe<Scalars['uuid']['input']>;
  responseDataObjectId?: InputMaybe<Scalars['uuid']['input']>;
  sourceComponentId?: InputMaybe<Scalars['uuid']['input']>;
  sourceFunctionId?: InputMaybe<Scalars['uuid']['input']>;
  sourceNodeId?: InputMaybe<Scalars['uuid']['input']>;
  sourcePortId?: InputMaybe<Scalars['uuid']['input']>;
  targetComponentId?: InputMaybe<Scalars['uuid']['input']>;
  targetFunctionId?: InputMaybe<Scalars['uuid']['input']>;
  targetNodeId?: InputMaybe<Scalars['uuid']['input']>;
  targetPortId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "flows" */
export enum FlowGeneric_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Environment = 'environment',
  /** column name */
  Id = 'id',
  /** column name */
  Layer = 'layer',
  /** column name */
  Name = 'name',
  /** column name */
  RequestDataObjectId = 'requestDataObjectId',
  /** column name */
  ResponseDataObjectId = 'responseDataObjectId',
  /** column name */
  SourceComponentId = 'sourceComponentId',
  /** column name */
  SourceFunctionId = 'sourceFunctionId',
  /** column name */
  SourceNodeId = 'sourceNodeId',
  /** column name */
  SourcePortId = 'sourcePortId',
  /** column name */
  TargetComponentId = 'targetComponentId',
  /** column name */
  TargetFunctionId = 'targetFunctionId',
  /** column name */
  TargetNodeId = 'targetNodeId',
  /** column name */
  TargetPortId = 'targetPortId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type FlowGeneric_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<FlowGeneric_Set_Input>;
  /** filter the rows which have to be updated */
  where: FlowGeneric_Bool_Exp;
};

/** columns and relationships of "functions" */
export type FunctionGeneric = {
  __typename?: 'FunctionGeneric';
  code: Scalars['String']['output'];
  /** An array relationship */
  components: Array<ApplicationComponentFunctionMap>;
  /** An aggregate relationship */
  components_aggregate: ApplicationComponentFunctionMap_Aggregate;
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['uuid']['output'];
  layer: Scalars['layer_kind_enum']['output'];
  name: Scalars['String']['output'];
  ownerId?: Maybe<Scalars['uuid']['output']>;
  /** An array relationship */
  processes: Array<BusinessProcessFunctionMap>;
  /** An aggregate relationship */
  processes_aggregate: BusinessProcessFunctionMap_Aggregate;
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};


/** columns and relationships of "functions" */
export type FunctionGenericComponentsArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentFunctionMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentFunctionMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentFunctionMap_Bool_Exp>;
};


/** columns and relationships of "functions" */
export type FunctionGenericComponents_AggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentFunctionMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentFunctionMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentFunctionMap_Bool_Exp>;
};


/** columns and relationships of "functions" */
export type FunctionGenericProcessesArgs = {
  distinct_on?: InputMaybe<Array<BusinessProcessFunctionMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessProcessFunctionMap_Order_By>>;
  where?: InputMaybe<BusinessProcessFunctionMap_Bool_Exp>;
};


/** columns and relationships of "functions" */
export type FunctionGenericProcesses_AggregateArgs = {
  distinct_on?: InputMaybe<Array<BusinessProcessFunctionMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessProcessFunctionMap_Order_By>>;
  where?: InputMaybe<BusinessProcessFunctionMap_Bool_Exp>;
};

/** aggregated selection of "functions" */
export type FunctionGeneric_Aggregate = {
  __typename?: 'FunctionGeneric_aggregate';
  aggregate?: Maybe<FunctionGeneric_Aggregate_Fields>;
  nodes: Array<FunctionGeneric>;
};

/** aggregate fields of "functions" */
export type FunctionGeneric_Aggregate_Fields = {
  __typename?: 'FunctionGeneric_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<FunctionGeneric_Max_Fields>;
  min?: Maybe<FunctionGeneric_Min_Fields>;
};


/** aggregate fields of "functions" */
export type FunctionGeneric_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<FunctionGeneric_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "functions". All fields are combined with a logical 'AND'. */
export type FunctionGeneric_Bool_Exp = {
  _and?: InputMaybe<Array<FunctionGeneric_Bool_Exp>>;
  _not?: InputMaybe<FunctionGeneric_Bool_Exp>;
  _or?: InputMaybe<Array<FunctionGeneric_Bool_Exp>>;
  code?: InputMaybe<String_Comparison_Exp>;
  components?: InputMaybe<ApplicationComponentFunctionMap_Bool_Exp>;
  components_aggregate?: InputMaybe<ApplicationComponentFunctionMap_Aggregate_Bool_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  layer?: InputMaybe<Layer_Kind_Enum_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  ownerId?: InputMaybe<Uuid_Comparison_Exp>;
  processes?: InputMaybe<BusinessProcessFunctionMap_Bool_Exp>;
  processes_aggregate?: InputMaybe<BusinessProcessFunctionMap_Aggregate_Bool_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "functions" */
export enum FunctionGeneric_Constraint {
  /** unique or primary key constraint on columns "code" */
  FunctionsCodeUnique = 'functions_code_unique',
  /** unique or primary key constraint on columns "id" */
  FunctionsPkey = 'functions_pkey'
}

/** input type for inserting data into table "functions" */
export type FunctionGeneric_Insert_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  components?: InputMaybe<ApplicationComponentFunctionMap_Arr_Rel_Insert_Input>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  layer?: InputMaybe<Scalars['layer_kind_enum']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['uuid']['input']>;
  processes?: InputMaybe<BusinessProcessFunctionMap_Arr_Rel_Insert_Input>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type FunctionGeneric_Max_Fields = {
  __typename?: 'FunctionGeneric_max_fields';
  code?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  layer?: Maybe<Scalars['layer_kind_enum']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  ownerId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type FunctionGeneric_Min_Fields = {
  __typename?: 'FunctionGeneric_min_fields';
  code?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  layer?: Maybe<Scalars['layer_kind_enum']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  ownerId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "functions" */
export type FunctionGeneric_Mutation_Response = {
  __typename?: 'FunctionGeneric_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<FunctionGeneric>;
};

/** input type for inserting object relation for remote table "functions" */
export type FunctionGeneric_Obj_Rel_Insert_Input = {
  data: FunctionGeneric_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<FunctionGeneric_On_Conflict>;
};

/** on_conflict condition type for table "functions" */
export type FunctionGeneric_On_Conflict = {
  constraint: FunctionGeneric_Constraint;
  update_columns?: Array<FunctionGeneric_Update_Column>;
  where?: InputMaybe<FunctionGeneric_Bool_Exp>;
};

/** Ordering options when selecting data from "functions". */
export type FunctionGeneric_Order_By = {
  code?: InputMaybe<Order_By>;
  components_aggregate?: InputMaybe<ApplicationComponentFunctionMap_Aggregate_Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  layer?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  ownerId?: InputMaybe<Order_By>;
  processes_aggregate?: InputMaybe<BusinessProcessFunctionMap_Aggregate_Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: functions */
export type FunctionGeneric_Pk_Columns_Input = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "functions" */
export enum FunctionGeneric_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Layer = 'layer',
  /** column name */
  Name = 'name',
  /** column name */
  OwnerId = 'ownerId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "functions" */
export type FunctionGeneric_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  layer?: InputMaybe<Scalars['layer_kind_enum']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "FunctionEntity" */
export type FunctionGeneric_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: FunctionGeneric_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type FunctionGeneric_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  layer?: InputMaybe<Scalars['layer_kind_enum']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "functions" */
export enum FunctionGeneric_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Layer = 'layer',
  /** column name */
  Name = 'name',
  /** column name */
  OwnerId = 'ownerId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type FunctionGeneric_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<FunctionGeneric_Set_Input>;
  /** filter the rows which have to be updated */
  where: FunctionGeneric_Bool_Exp;
};

/** Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'. */
export type Int_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['Int']['input']>;
  _gt?: InputMaybe<Scalars['Int']['input']>;
  _gte?: InputMaybe<Scalars['Int']['input']>;
  _in?: InputMaybe<Array<Scalars['Int']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['Int']['input']>;
  _lte?: InputMaybe<Scalars['Int']['input']>;
  _neq?: InputMaybe<Scalars['Int']['input']>;
  _nin?: InputMaybe<Array<Scalars['Int']['input']>>;
};

/** columns and relationships of "interfaces" */
export type InterfaceGeneric = {
  __typename?: 'InterfaceGeneric';
  code: Scalars['String']['output'];
  componentId?: Maybe<Scalars['uuid']['output']>;
  /** An array relationship */
  components: Array<ApplicationComponentInterfaceMap>;
  /** An aggregate relationship */
  components_aggregate: ApplicationComponentInterfaceMap_Aggregate;
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  functions: Array<ApplicationFunctionInterfaceMap>;
  /** An aggregate relationship */
  functions_aggregate: ApplicationFunctionInterfaceMap_Aggregate;
  id: Scalars['uuid']['output'];
  layer: Scalars['layer_kind_enum']['output'];
  methods?: Maybe<Array<Scalars['interface_method_enum']['output']>>;
  name: Scalars['String']['output'];
  ownerId?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  protocol?: Maybe<DirectoryObject>;
  protocolId?: Maybe<Scalars['uuid']['output']>;
  /** An array relationship */
  sourcePort: Array<FlowGeneric>;
  /** An aggregate relationship */
  sourcePort_aggregate: FlowGeneric_Aggregate;
  /** An array relationship */
  targetPort: Array<FlowGeneric>;
  /** An aggregate relationship */
  targetPort_aggregate: FlowGeneric_Aggregate;
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};


/** columns and relationships of "interfaces" */
export type InterfaceGenericComponentsArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentInterfaceMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentInterfaceMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentInterfaceMap_Bool_Exp>;
};


/** columns and relationships of "interfaces" */
export type InterfaceGenericComponents_AggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentInterfaceMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentInterfaceMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentInterfaceMap_Bool_Exp>;
};


/** columns and relationships of "interfaces" */
export type InterfaceGenericFunctionsArgs = {
  distinct_on?: InputMaybe<Array<ApplicationFunctionInterfaceMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationFunctionInterfaceMap_Order_By>>;
  where?: InputMaybe<ApplicationFunctionInterfaceMap_Bool_Exp>;
};


/** columns and relationships of "interfaces" */
export type InterfaceGenericFunctions_AggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationFunctionInterfaceMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationFunctionInterfaceMap_Order_By>>;
  where?: InputMaybe<ApplicationFunctionInterfaceMap_Bool_Exp>;
};


/** columns and relationships of "interfaces" */
export type InterfaceGenericSourcePortArgs = {
  distinct_on?: InputMaybe<Array<FlowGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FlowGeneric_Order_By>>;
  where?: InputMaybe<FlowGeneric_Bool_Exp>;
};


/** columns and relationships of "interfaces" */
export type InterfaceGenericSourcePort_AggregateArgs = {
  distinct_on?: InputMaybe<Array<FlowGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FlowGeneric_Order_By>>;
  where?: InputMaybe<FlowGeneric_Bool_Exp>;
};


/** columns and relationships of "interfaces" */
export type InterfaceGenericTargetPortArgs = {
  distinct_on?: InputMaybe<Array<FlowGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FlowGeneric_Order_By>>;
  where?: InputMaybe<FlowGeneric_Bool_Exp>;
};


/** columns and relationships of "interfaces" */
export type InterfaceGenericTargetPort_AggregateArgs = {
  distinct_on?: InputMaybe<Array<FlowGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FlowGeneric_Order_By>>;
  where?: InputMaybe<FlowGeneric_Bool_Exp>;
};

/** aggregated selection of "interfaces" */
export type InterfaceGeneric_Aggregate = {
  __typename?: 'InterfaceGeneric_aggregate';
  aggregate?: Maybe<InterfaceGeneric_Aggregate_Fields>;
  nodes: Array<InterfaceGeneric>;
};

export type InterfaceGeneric_Aggregate_Bool_Exp = {
  count?: InputMaybe<InterfaceGeneric_Aggregate_Bool_Exp_Count>;
};

export type InterfaceGeneric_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<InterfaceGeneric_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<InterfaceGeneric_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "interfaces" */
export type InterfaceGeneric_Aggregate_Fields = {
  __typename?: 'InterfaceGeneric_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<InterfaceGeneric_Max_Fields>;
  min?: Maybe<InterfaceGeneric_Min_Fields>;
};


/** aggregate fields of "interfaces" */
export type InterfaceGeneric_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<InterfaceGeneric_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "interfaces" */
export type InterfaceGeneric_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<InterfaceGeneric_Max_Order_By>;
  min?: InputMaybe<InterfaceGeneric_Min_Order_By>;
};

/** input type for inserting array relation for remote table "interfaces" */
export type InterfaceGeneric_Arr_Rel_Insert_Input = {
  data: Array<InterfaceGeneric_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<InterfaceGeneric_On_Conflict>;
};

/** Boolean expression to filter rows from the table "interfaces". All fields are combined with a logical 'AND'. */
export type InterfaceGeneric_Bool_Exp = {
  _and?: InputMaybe<Array<InterfaceGeneric_Bool_Exp>>;
  _not?: InputMaybe<InterfaceGeneric_Bool_Exp>;
  _or?: InputMaybe<Array<InterfaceGeneric_Bool_Exp>>;
  code?: InputMaybe<String_Comparison_Exp>;
  componentId?: InputMaybe<Uuid_Comparison_Exp>;
  components?: InputMaybe<ApplicationComponentInterfaceMap_Bool_Exp>;
  components_aggregate?: InputMaybe<ApplicationComponentInterfaceMap_Aggregate_Bool_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  functions?: InputMaybe<ApplicationFunctionInterfaceMap_Bool_Exp>;
  functions_aggregate?: InputMaybe<ApplicationFunctionInterfaceMap_Aggregate_Bool_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  layer?: InputMaybe<Layer_Kind_Enum_Comparison_Exp>;
  methods?: InputMaybe<Interface_Method_Enum_Array_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  ownerId?: InputMaybe<Uuid_Comparison_Exp>;
  protocol?: InputMaybe<DirectoryObject_Bool_Exp>;
  protocolId?: InputMaybe<Uuid_Comparison_Exp>;
  sourcePort?: InputMaybe<FlowGeneric_Bool_Exp>;
  sourcePort_aggregate?: InputMaybe<FlowGeneric_Aggregate_Bool_Exp>;
  targetPort?: InputMaybe<FlowGeneric_Bool_Exp>;
  targetPort_aggregate?: InputMaybe<FlowGeneric_Aggregate_Bool_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "interfaces" */
export enum InterfaceGeneric_Constraint {
  /** unique or primary key constraint on columns "code" */
  InterfacesCodeUnique = 'interfaces_code_unique',
  /** unique or primary key constraint on columns "id" */
  InterfacesPkey = 'interfaces_pkey'
}

/** input type for inserting data into table "interfaces" */
export type InterfaceGeneric_Insert_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  components?: InputMaybe<ApplicationComponentInterfaceMap_Arr_Rel_Insert_Input>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  functions?: InputMaybe<ApplicationFunctionInterfaceMap_Arr_Rel_Insert_Input>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  layer?: InputMaybe<Scalars['layer_kind_enum']['input']>;
  methods?: InputMaybe<Array<Scalars['interface_method_enum']['input']>>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['uuid']['input']>;
  protocol?: InputMaybe<DirectoryObject_Obj_Rel_Insert_Input>;
  protocolId?: InputMaybe<Scalars['uuid']['input']>;
  sourcePort?: InputMaybe<FlowGeneric_Arr_Rel_Insert_Input>;
  targetPort?: InputMaybe<FlowGeneric_Arr_Rel_Insert_Input>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type InterfaceGeneric_Max_Fields = {
  __typename?: 'InterfaceGeneric_max_fields';
  code?: Maybe<Scalars['String']['output']>;
  componentId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  layer?: Maybe<Scalars['layer_kind_enum']['output']>;
  methods?: Maybe<Array<Scalars['interface_method_enum']['output']>>;
  name?: Maybe<Scalars['String']['output']>;
  ownerId?: Maybe<Scalars['uuid']['output']>;
  protocolId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "interfaces" */
export type InterfaceGeneric_Max_Order_By = {
  code?: InputMaybe<Order_By>;
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  layer?: InputMaybe<Order_By>;
  methods?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  ownerId?: InputMaybe<Order_By>;
  protocolId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type InterfaceGeneric_Min_Fields = {
  __typename?: 'InterfaceGeneric_min_fields';
  code?: Maybe<Scalars['String']['output']>;
  componentId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  layer?: Maybe<Scalars['layer_kind_enum']['output']>;
  methods?: Maybe<Array<Scalars['interface_method_enum']['output']>>;
  name?: Maybe<Scalars['String']['output']>;
  ownerId?: Maybe<Scalars['uuid']['output']>;
  protocolId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "interfaces" */
export type InterfaceGeneric_Min_Order_By = {
  code?: InputMaybe<Order_By>;
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  layer?: InputMaybe<Order_By>;
  methods?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  ownerId?: InputMaybe<Order_By>;
  protocolId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "interfaces" */
export type InterfaceGeneric_Mutation_Response = {
  __typename?: 'InterfaceGeneric_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<InterfaceGeneric>;
};

/** input type for inserting object relation for remote table "interfaces" */
export type InterfaceGeneric_Obj_Rel_Insert_Input = {
  data: InterfaceGeneric_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<InterfaceGeneric_On_Conflict>;
};

/** on_conflict condition type for table "interfaces" */
export type InterfaceGeneric_On_Conflict = {
  constraint: InterfaceGeneric_Constraint;
  update_columns?: Array<InterfaceGeneric_Update_Column>;
  where?: InputMaybe<InterfaceGeneric_Bool_Exp>;
};

/** Ordering options when selecting data from "interfaces". */
export type InterfaceGeneric_Order_By = {
  code?: InputMaybe<Order_By>;
  componentId?: InputMaybe<Order_By>;
  components_aggregate?: InputMaybe<ApplicationComponentInterfaceMap_Aggregate_Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  functions_aggregate?: InputMaybe<ApplicationFunctionInterfaceMap_Aggregate_Order_By>;
  id?: InputMaybe<Order_By>;
  layer?: InputMaybe<Order_By>;
  methods?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  ownerId?: InputMaybe<Order_By>;
  protocol?: InputMaybe<DirectoryObject_Order_By>;
  protocolId?: InputMaybe<Order_By>;
  sourcePort_aggregate?: InputMaybe<FlowGeneric_Aggregate_Order_By>;
  targetPort_aggregate?: InputMaybe<FlowGeneric_Aggregate_Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: interfaces */
export type InterfaceGeneric_Pk_Columns_Input = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "interfaces" */
export enum InterfaceGeneric_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  ComponentId = 'componentId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Layer = 'layer',
  /** column name */
  Methods = 'methods',
  /** column name */
  Name = 'name',
  /** column name */
  OwnerId = 'ownerId',
  /** column name */
  ProtocolId = 'protocolId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "interfaces" */
export type InterfaceGeneric_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  layer?: InputMaybe<Scalars['layer_kind_enum']['input']>;
  methods?: InputMaybe<Array<Scalars['interface_method_enum']['input']>>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['uuid']['input']>;
  protocolId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "InterfaceGeneric" */
export type InterfaceGeneric_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: InterfaceGeneric_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type InterfaceGeneric_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  layer?: InputMaybe<Scalars['layer_kind_enum']['input']>;
  methods?: InputMaybe<Array<Scalars['interface_method_enum']['input']>>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['uuid']['input']>;
  protocolId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "interfaces" */
export enum InterfaceGeneric_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  ComponentId = 'componentId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Layer = 'layer',
  /** column name */
  Methods = 'methods',
  /** column name */
  Name = 'name',
  /** column name */
  OwnerId = 'ownerId',
  /** column name */
  ProtocolId = 'protocolId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type InterfaceGeneric_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<InterfaceGeneric_Set_Input>;
  /** filter the rows which have to be updated */
  where: InterfaceGeneric_Bool_Exp;
};

/** columns and relationships of "motivations" */
export type MotivationElementGeneric = {
  __typename?: 'MotivationElementGeneric';
  capabilityAssessmentType?: Maybe<Scalars['capability_assessment_type_enum']['output']>;
  /** An array relationship */
  children: Array<MotivationItemHierarchyMap>;
  /** An aggregate relationship */
  children_aggregate: MotivationItemHierarchyMap_Aggregate;
  code: Scalars['String']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['uuid']['output'];
  impact?: Maybe<Scalars['smallint']['output']>;
  kind: Scalars['motivation_kind_enum']['output'];
  mitigationNotes?: Maybe<Scalars['String']['output']>;
  name: Scalars['String']['output'];
  ownerId?: Maybe<Scalars['uuid']['output']>;
  /** An array relationship */
  parents: Array<MotivationItemHierarchyMap>;
  /** An aggregate relationship */
  parents_aggregate: MotivationItemHierarchyMap_Aggregate;
  priority?: Maybe<Scalars['motivation_priority_enum']['output']>;
  probability?: Maybe<Scalars['smallint']['output']>;
  /** An array relationship */
  processes: Array<BusinessProcessMotivationItemMap>;
  /** An aggregate relationship */
  processes_aggregate: BusinessProcessMotivationItemMap_Aggregate;
  riskCategory?: Maybe<Scalars['risk_category_enum']['output']>;
  severity?: Maybe<Scalars['smallint']['output']>;
  /** An array relationship */
  solutionMotivations: Array<SolutionMotivationElementMap>;
  /** An aggregate relationship */
  solutionMotivations_aggregate: SolutionMotivationElementMap_Aggregate;
  state?: Maybe<Scalars['motivation_status_enum']['output']>;
  status?: Maybe<Scalars['risk_status_enum']['output']>;
  tenantId: Scalars['uuid']['output'];
  typeAssessment?: Maybe<Scalars['assessment_type_enum']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};


/** columns and relationships of "motivations" */
export type MotivationElementGenericChildrenArgs = {
  distinct_on?: InputMaybe<Array<MotivationItemHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MotivationItemHierarchyMap_Order_By>>;
  where?: InputMaybe<MotivationItemHierarchyMap_Bool_Exp>;
};


/** columns and relationships of "motivations" */
export type MotivationElementGenericChildren_AggregateArgs = {
  distinct_on?: InputMaybe<Array<MotivationItemHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MotivationItemHierarchyMap_Order_By>>;
  where?: InputMaybe<MotivationItemHierarchyMap_Bool_Exp>;
};


/** columns and relationships of "motivations" */
export type MotivationElementGenericParentsArgs = {
  distinct_on?: InputMaybe<Array<MotivationItemHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MotivationItemHierarchyMap_Order_By>>;
  where?: InputMaybe<MotivationItemHierarchyMap_Bool_Exp>;
};


/** columns and relationships of "motivations" */
export type MotivationElementGenericParents_AggregateArgs = {
  distinct_on?: InputMaybe<Array<MotivationItemHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MotivationItemHierarchyMap_Order_By>>;
  where?: InputMaybe<MotivationItemHierarchyMap_Bool_Exp>;
};


/** columns and relationships of "motivations" */
export type MotivationElementGenericProcessesArgs = {
  distinct_on?: InputMaybe<Array<BusinessProcessMotivationItemMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessProcessMotivationItemMap_Order_By>>;
  where?: InputMaybe<BusinessProcessMotivationItemMap_Bool_Exp>;
};


/** columns and relationships of "motivations" */
export type MotivationElementGenericProcesses_AggregateArgs = {
  distinct_on?: InputMaybe<Array<BusinessProcessMotivationItemMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessProcessMotivationItemMap_Order_By>>;
  where?: InputMaybe<BusinessProcessMotivationItemMap_Bool_Exp>;
};


/** columns and relationships of "motivations" */
export type MotivationElementGenericSolutionMotivationsArgs = {
  distinct_on?: InputMaybe<Array<SolutionMotivationElementMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionMotivationElementMap_Order_By>>;
  where?: InputMaybe<SolutionMotivationElementMap_Bool_Exp>;
};


/** columns and relationships of "motivations" */
export type MotivationElementGenericSolutionMotivations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<SolutionMotivationElementMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionMotivationElementMap_Order_By>>;
  where?: InputMaybe<SolutionMotivationElementMap_Bool_Exp>;
};

/** aggregated selection of "motivations" */
export type MotivationElementGeneric_Aggregate = {
  __typename?: 'MotivationElementGeneric_aggregate';
  aggregate?: Maybe<MotivationElementGeneric_Aggregate_Fields>;
  nodes: Array<MotivationElementGeneric>;
};

/** aggregate fields of "motivations" */
export type MotivationElementGeneric_Aggregate_Fields = {
  __typename?: 'MotivationElementGeneric_aggregate_fields';
  avg?: Maybe<MotivationElementGeneric_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<MotivationElementGeneric_Max_Fields>;
  min?: Maybe<MotivationElementGeneric_Min_Fields>;
  stddev?: Maybe<MotivationElementGeneric_Stddev_Fields>;
  stddev_pop?: Maybe<MotivationElementGeneric_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<MotivationElementGeneric_Stddev_Samp_Fields>;
  sum?: Maybe<MotivationElementGeneric_Sum_Fields>;
  var_pop?: Maybe<MotivationElementGeneric_Var_Pop_Fields>;
  var_samp?: Maybe<MotivationElementGeneric_Var_Samp_Fields>;
  variance?: Maybe<MotivationElementGeneric_Variance_Fields>;
};


/** aggregate fields of "motivations" */
export type MotivationElementGeneric_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<MotivationElementGeneric_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** aggregate avg on columns */
export type MotivationElementGeneric_Avg_Fields = {
  __typename?: 'MotivationElementGeneric_avg_fields';
  impact?: Maybe<Scalars['Float']['output']>;
  probability?: Maybe<Scalars['Float']['output']>;
  severity?: Maybe<Scalars['Float']['output']>;
};

/** Boolean expression to filter rows from the table "motivations". All fields are combined with a logical 'AND'. */
export type MotivationElementGeneric_Bool_Exp = {
  _and?: InputMaybe<Array<MotivationElementGeneric_Bool_Exp>>;
  _not?: InputMaybe<MotivationElementGeneric_Bool_Exp>;
  _or?: InputMaybe<Array<MotivationElementGeneric_Bool_Exp>>;
  capabilityAssessmentType?: InputMaybe<Capability_Assessment_Type_Enum_Comparison_Exp>;
  children?: InputMaybe<MotivationItemHierarchyMap_Bool_Exp>;
  children_aggregate?: InputMaybe<MotivationItemHierarchyMap_Aggregate_Bool_Exp>;
  code?: InputMaybe<String_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  impact?: InputMaybe<Smallint_Comparison_Exp>;
  kind?: InputMaybe<Motivation_Kind_Enum_Comparison_Exp>;
  mitigationNotes?: InputMaybe<String_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  ownerId?: InputMaybe<Uuid_Comparison_Exp>;
  parents?: InputMaybe<MotivationItemHierarchyMap_Bool_Exp>;
  parents_aggregate?: InputMaybe<MotivationItemHierarchyMap_Aggregate_Bool_Exp>;
  priority?: InputMaybe<Motivation_Priority_Enum_Comparison_Exp>;
  probability?: InputMaybe<Smallint_Comparison_Exp>;
  processes?: InputMaybe<BusinessProcessMotivationItemMap_Bool_Exp>;
  processes_aggregate?: InputMaybe<BusinessProcessMotivationItemMap_Aggregate_Bool_Exp>;
  riskCategory?: InputMaybe<Risk_Category_Enum_Comparison_Exp>;
  severity?: InputMaybe<Smallint_Comparison_Exp>;
  solutionMotivations?: InputMaybe<SolutionMotivationElementMap_Bool_Exp>;
  solutionMotivations_aggregate?: InputMaybe<SolutionMotivationElementMap_Aggregate_Bool_Exp>;
  state?: InputMaybe<Motivation_Status_Enum_Comparison_Exp>;
  status?: InputMaybe<Risk_Status_Enum_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  typeAssessment?: InputMaybe<Assessment_Type_Enum_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "motivations" */
export enum MotivationElementGeneric_Constraint {
  /** unique or primary key constraint on columns "code" */
  MotivationsCodeUnique = 'motivations_code_unique',
  /** unique or primary key constraint on columns "id" */
  MotivationsPkey = 'motivations_pkey'
}

/** input type for incrementing numeric columns in table "motivations" */
export type MotivationElementGeneric_Inc_Input = {
  impact?: InputMaybe<Scalars['smallint']['input']>;
  probability?: InputMaybe<Scalars['smallint']['input']>;
  severity?: InputMaybe<Scalars['smallint']['input']>;
};

/** input type for inserting data into table "motivations" */
export type MotivationElementGeneric_Insert_Input = {
  capabilityAssessmentType?: InputMaybe<Scalars['capability_assessment_type_enum']['input']>;
  children?: InputMaybe<MotivationItemHierarchyMap_Arr_Rel_Insert_Input>;
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  impact?: InputMaybe<Scalars['smallint']['input']>;
  kind?: InputMaybe<Scalars['motivation_kind_enum']['input']>;
  mitigationNotes?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['uuid']['input']>;
  parents?: InputMaybe<MotivationItemHierarchyMap_Arr_Rel_Insert_Input>;
  priority?: InputMaybe<Scalars['motivation_priority_enum']['input']>;
  probability?: InputMaybe<Scalars['smallint']['input']>;
  processes?: InputMaybe<BusinessProcessMotivationItemMap_Arr_Rel_Insert_Input>;
  riskCategory?: InputMaybe<Scalars['risk_category_enum']['input']>;
  severity?: InputMaybe<Scalars['smallint']['input']>;
  solutionMotivations?: InputMaybe<SolutionMotivationElementMap_Arr_Rel_Insert_Input>;
  state?: InputMaybe<Scalars['motivation_status_enum']['input']>;
  status?: InputMaybe<Scalars['risk_status_enum']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  typeAssessment?: InputMaybe<Scalars['assessment_type_enum']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type MotivationElementGeneric_Max_Fields = {
  __typename?: 'MotivationElementGeneric_max_fields';
  capabilityAssessmentType?: Maybe<Scalars['capability_assessment_type_enum']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  impact?: Maybe<Scalars['smallint']['output']>;
  kind?: Maybe<Scalars['motivation_kind_enum']['output']>;
  mitigationNotes?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  ownerId?: Maybe<Scalars['uuid']['output']>;
  priority?: Maybe<Scalars['motivation_priority_enum']['output']>;
  probability?: Maybe<Scalars['smallint']['output']>;
  riskCategory?: Maybe<Scalars['risk_category_enum']['output']>;
  severity?: Maybe<Scalars['smallint']['output']>;
  state?: Maybe<Scalars['motivation_status_enum']['output']>;
  status?: Maybe<Scalars['risk_status_enum']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  typeAssessment?: Maybe<Scalars['assessment_type_enum']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type MotivationElementGeneric_Min_Fields = {
  __typename?: 'MotivationElementGeneric_min_fields';
  capabilityAssessmentType?: Maybe<Scalars['capability_assessment_type_enum']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  impact?: Maybe<Scalars['smallint']['output']>;
  kind?: Maybe<Scalars['motivation_kind_enum']['output']>;
  mitigationNotes?: Maybe<Scalars['String']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  ownerId?: Maybe<Scalars['uuid']['output']>;
  priority?: Maybe<Scalars['motivation_priority_enum']['output']>;
  probability?: Maybe<Scalars['smallint']['output']>;
  riskCategory?: Maybe<Scalars['risk_category_enum']['output']>;
  severity?: Maybe<Scalars['smallint']['output']>;
  state?: Maybe<Scalars['motivation_status_enum']['output']>;
  status?: Maybe<Scalars['risk_status_enum']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  typeAssessment?: Maybe<Scalars['assessment_type_enum']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "motivations" */
export type MotivationElementGeneric_Mutation_Response = {
  __typename?: 'MotivationElementGeneric_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<MotivationElementGeneric>;
};

/** input type for inserting object relation for remote table "motivations" */
export type MotivationElementGeneric_Obj_Rel_Insert_Input = {
  data: MotivationElementGeneric_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<MotivationElementGeneric_On_Conflict>;
};

/** on_conflict condition type for table "motivations" */
export type MotivationElementGeneric_On_Conflict = {
  constraint: MotivationElementGeneric_Constraint;
  update_columns?: Array<MotivationElementGeneric_Update_Column>;
  where?: InputMaybe<MotivationElementGeneric_Bool_Exp>;
};

/** Ordering options when selecting data from "motivations". */
export type MotivationElementGeneric_Order_By = {
  capabilityAssessmentType?: InputMaybe<Order_By>;
  children_aggregate?: InputMaybe<MotivationItemHierarchyMap_Aggregate_Order_By>;
  code?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  impact?: InputMaybe<Order_By>;
  kind?: InputMaybe<Order_By>;
  mitigationNotes?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  ownerId?: InputMaybe<Order_By>;
  parents_aggregate?: InputMaybe<MotivationItemHierarchyMap_Aggregate_Order_By>;
  priority?: InputMaybe<Order_By>;
  probability?: InputMaybe<Order_By>;
  processes_aggregate?: InputMaybe<BusinessProcessMotivationItemMap_Aggregate_Order_By>;
  riskCategory?: InputMaybe<Order_By>;
  severity?: InputMaybe<Order_By>;
  solutionMotivations_aggregate?: InputMaybe<SolutionMotivationElementMap_Aggregate_Order_By>;
  state?: InputMaybe<Order_By>;
  status?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  typeAssessment?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: motivations */
export type MotivationElementGeneric_Pk_Columns_Input = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "motivations" */
export enum MotivationElementGeneric_Select_Column {
  /** column name */
  CapabilityAssessmentType = 'capabilityAssessmentType',
  /** column name */
  Code = 'code',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Impact = 'impact',
  /** column name */
  Kind = 'kind',
  /** column name */
  MitigationNotes = 'mitigationNotes',
  /** column name */
  Name = 'name',
  /** column name */
  OwnerId = 'ownerId',
  /** column name */
  Priority = 'priority',
  /** column name */
  Probability = 'probability',
  /** column name */
  RiskCategory = 'riskCategory',
  /** column name */
  Severity = 'severity',
  /** column name */
  State = 'state',
  /** column name */
  Status = 'status',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  TypeAssessment = 'typeAssessment',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "motivations" */
export type MotivationElementGeneric_Set_Input = {
  capabilityAssessmentType?: InputMaybe<Scalars['capability_assessment_type_enum']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  impact?: InputMaybe<Scalars['smallint']['input']>;
  kind?: InputMaybe<Scalars['motivation_kind_enum']['input']>;
  mitigationNotes?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['uuid']['input']>;
  priority?: InputMaybe<Scalars['motivation_priority_enum']['input']>;
  probability?: InputMaybe<Scalars['smallint']['input']>;
  riskCategory?: InputMaybe<Scalars['risk_category_enum']['input']>;
  severity?: InputMaybe<Scalars['smallint']['input']>;
  state?: InputMaybe<Scalars['motivation_status_enum']['input']>;
  status?: InputMaybe<Scalars['risk_status_enum']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  typeAssessment?: InputMaybe<Scalars['assessment_type_enum']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type MotivationElementGeneric_Stddev_Fields = {
  __typename?: 'MotivationElementGeneric_stddev_fields';
  impact?: Maybe<Scalars['Float']['output']>;
  probability?: Maybe<Scalars['Float']['output']>;
  severity?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_pop on columns */
export type MotivationElementGeneric_Stddev_Pop_Fields = {
  __typename?: 'MotivationElementGeneric_stddev_pop_fields';
  impact?: Maybe<Scalars['Float']['output']>;
  probability?: Maybe<Scalars['Float']['output']>;
  severity?: Maybe<Scalars['Float']['output']>;
};

/** aggregate stddev_samp on columns */
export type MotivationElementGeneric_Stddev_Samp_Fields = {
  __typename?: 'MotivationElementGeneric_stddev_samp_fields';
  impact?: Maybe<Scalars['Float']['output']>;
  probability?: Maybe<Scalars['Float']['output']>;
  severity?: Maybe<Scalars['Float']['output']>;
};

/** Streaming cursor of the table "MotivationElementGeneric" */
export type MotivationElementGeneric_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: MotivationElementGeneric_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type MotivationElementGeneric_Stream_Cursor_Value_Input = {
  capabilityAssessmentType?: InputMaybe<Scalars['capability_assessment_type_enum']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  impact?: InputMaybe<Scalars['smallint']['input']>;
  kind?: InputMaybe<Scalars['motivation_kind_enum']['input']>;
  mitigationNotes?: InputMaybe<Scalars['String']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['uuid']['input']>;
  priority?: InputMaybe<Scalars['motivation_priority_enum']['input']>;
  probability?: InputMaybe<Scalars['smallint']['input']>;
  riskCategory?: InputMaybe<Scalars['risk_category_enum']['input']>;
  severity?: InputMaybe<Scalars['smallint']['input']>;
  state?: InputMaybe<Scalars['motivation_status_enum']['input']>;
  status?: InputMaybe<Scalars['risk_status_enum']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  typeAssessment?: InputMaybe<Scalars['assessment_type_enum']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type MotivationElementGeneric_Sum_Fields = {
  __typename?: 'MotivationElementGeneric_sum_fields';
  impact?: Maybe<Scalars['smallint']['output']>;
  probability?: Maybe<Scalars['smallint']['output']>;
  severity?: Maybe<Scalars['smallint']['output']>;
};

/** update columns of table "motivations" */
export enum MotivationElementGeneric_Update_Column {
  /** column name */
  CapabilityAssessmentType = 'capabilityAssessmentType',
  /** column name */
  Code = 'code',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Impact = 'impact',
  /** column name */
  Kind = 'kind',
  /** column name */
  MitigationNotes = 'mitigationNotes',
  /** column name */
  Name = 'name',
  /** column name */
  OwnerId = 'ownerId',
  /** column name */
  Priority = 'priority',
  /** column name */
  Probability = 'probability',
  /** column name */
  RiskCategory = 'riskCategory',
  /** column name */
  Severity = 'severity',
  /** column name */
  State = 'state',
  /** column name */
  Status = 'status',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  TypeAssessment = 'typeAssessment',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type MotivationElementGeneric_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<MotivationElementGeneric_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<MotivationElementGeneric_Set_Input>;
  /** filter the rows which have to be updated */
  where: MotivationElementGeneric_Bool_Exp;
};

/** aggregate var_pop on columns */
export type MotivationElementGeneric_Var_Pop_Fields = {
  __typename?: 'MotivationElementGeneric_var_pop_fields';
  impact?: Maybe<Scalars['Float']['output']>;
  probability?: Maybe<Scalars['Float']['output']>;
  severity?: Maybe<Scalars['Float']['output']>;
};

/** aggregate var_samp on columns */
export type MotivationElementGeneric_Var_Samp_Fields = {
  __typename?: 'MotivationElementGeneric_var_samp_fields';
  impact?: Maybe<Scalars['Float']['output']>;
  probability?: Maybe<Scalars['Float']['output']>;
  severity?: Maybe<Scalars['Float']['output']>;
};

/** aggregate variance on columns */
export type MotivationElementGeneric_Variance_Fields = {
  __typename?: 'MotivationElementGeneric_variance_fields';
  impact?: Maybe<Scalars['Float']['output']>;
  probability?: Maybe<Scalars['Float']['output']>;
  severity?: Maybe<Scalars['Float']['output']>;
};

/** columns and relationships of "map_motivation_item_hierarchy" */
export type MotivationItemHierarchyMap = {
  __typename?: 'MotivationItemHierarchyMap';
  /** An object relationship */
  child: MotivationElementGeneric;
  childId: Scalars['uuid']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  parent: MotivationElementGeneric;
  parentId: Scalars['uuid']['output'];
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "map_motivation_item_hierarchy" */
export type MotivationItemHierarchyMap_Aggregate = {
  __typename?: 'MotivationItemHierarchyMap_aggregate';
  aggregate?: Maybe<MotivationItemHierarchyMap_Aggregate_Fields>;
  nodes: Array<MotivationItemHierarchyMap>;
};

export type MotivationItemHierarchyMap_Aggregate_Bool_Exp = {
  count?: InputMaybe<MotivationItemHierarchyMap_Aggregate_Bool_Exp_Count>;
};

export type MotivationItemHierarchyMap_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<MotivationItemHierarchyMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<MotivationItemHierarchyMap_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "map_motivation_item_hierarchy" */
export type MotivationItemHierarchyMap_Aggregate_Fields = {
  __typename?: 'MotivationItemHierarchyMap_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<MotivationItemHierarchyMap_Max_Fields>;
  min?: Maybe<MotivationItemHierarchyMap_Min_Fields>;
};


/** aggregate fields of "map_motivation_item_hierarchy" */
export type MotivationItemHierarchyMap_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<MotivationItemHierarchyMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "map_motivation_item_hierarchy" */
export type MotivationItemHierarchyMap_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<MotivationItemHierarchyMap_Max_Order_By>;
  min?: InputMaybe<MotivationItemHierarchyMap_Min_Order_By>;
};

/** input type for inserting array relation for remote table "map_motivation_item_hierarchy" */
export type MotivationItemHierarchyMap_Arr_Rel_Insert_Input = {
  data: Array<MotivationItemHierarchyMap_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<MotivationItemHierarchyMap_On_Conflict>;
};

/** Boolean expression to filter rows from the table "map_motivation_item_hierarchy". All fields are combined with a logical 'AND'. */
export type MotivationItemHierarchyMap_Bool_Exp = {
  _and?: InputMaybe<Array<MotivationItemHierarchyMap_Bool_Exp>>;
  _not?: InputMaybe<MotivationItemHierarchyMap_Bool_Exp>;
  _or?: InputMaybe<Array<MotivationItemHierarchyMap_Bool_Exp>>;
  child?: InputMaybe<MotivationElementGeneric_Bool_Exp>;
  childId?: InputMaybe<Uuid_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  parent?: InputMaybe<MotivationElementGeneric_Bool_Exp>;
  parentId?: InputMaybe<Uuid_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "map_motivation_item_hierarchy" */
export enum MotivationItemHierarchyMap_Constraint {
  /** unique or primary key constraint on columns "child_id", "parent_id" */
  MapMotivationItemHierarchyParentIdChildIdUnique = 'map_motivation_item_hierarchy_parent_id_child_id_unique',
  /** unique or primary key constraint on columns "child_id", "parent_id" */
  MapMotivationItemHierarchyPkey = 'map_motivation_item_hierarchy_pkey'
}

/** input type for inserting data into table "map_motivation_item_hierarchy" */
export type MotivationItemHierarchyMap_Insert_Input = {
  child?: InputMaybe<MotivationElementGeneric_Obj_Rel_Insert_Input>;
  childId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  parent?: InputMaybe<MotivationElementGeneric_Obj_Rel_Insert_Input>;
  parentId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type MotivationItemHierarchyMap_Max_Fields = {
  __typename?: 'MotivationItemHierarchyMap_max_fields';
  childId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  parentId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "map_motivation_item_hierarchy" */
export type MotivationItemHierarchyMap_Max_Order_By = {
  childId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  parentId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type MotivationItemHierarchyMap_Min_Fields = {
  __typename?: 'MotivationItemHierarchyMap_min_fields';
  childId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  parentId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "map_motivation_item_hierarchy" */
export type MotivationItemHierarchyMap_Min_Order_By = {
  childId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  parentId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "map_motivation_item_hierarchy" */
export type MotivationItemHierarchyMap_Mutation_Response = {
  __typename?: 'MotivationItemHierarchyMap_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<MotivationItemHierarchyMap>;
};

/** on_conflict condition type for table "map_motivation_item_hierarchy" */
export type MotivationItemHierarchyMap_On_Conflict = {
  constraint: MotivationItemHierarchyMap_Constraint;
  update_columns?: Array<MotivationItemHierarchyMap_Update_Column>;
  where?: InputMaybe<MotivationItemHierarchyMap_Bool_Exp>;
};

/** Ordering options when selecting data from "map_motivation_item_hierarchy". */
export type MotivationItemHierarchyMap_Order_By = {
  child?: InputMaybe<MotivationElementGeneric_Order_By>;
  childId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  parent?: InputMaybe<MotivationElementGeneric_Order_By>;
  parentId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: map_motivation_item_hierarchy */
export type MotivationItemHierarchyMap_Pk_Columns_Input = {
  childId: Scalars['uuid']['input'];
  parentId: Scalars['uuid']['input'];
};

/** select columns of table "map_motivation_item_hierarchy" */
export enum MotivationItemHierarchyMap_Select_Column {
  /** column name */
  ChildId = 'childId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  ParentId = 'parentId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "map_motivation_item_hierarchy" */
export type MotivationItemHierarchyMap_Set_Input = {
  childId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  parentId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "MotivationItemHierarchyMap" */
export type MotivationItemHierarchyMap_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: MotivationItemHierarchyMap_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type MotivationItemHierarchyMap_Stream_Cursor_Value_Input = {
  childId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  parentId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "map_motivation_item_hierarchy" */
export enum MotivationItemHierarchyMap_Update_Column {
  /** column name */
  ChildId = 'childId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  ParentId = 'parentId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type MotivationItemHierarchyMap_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<MotivationItemHierarchyMap_Set_Input>;
  /** filter the rows which have to be updated */
  where: MotivationItemHierarchyMap_Bool_Exp;
};

/** columns and relationships of "locations" */
export type PhysicalLocation = {
  __typename?: 'PhysicalLocation';
  code: Scalars['String']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['uuid']['output'];
  name: Scalars['String']['output'];
  /** An array relationship */
  networks: Array<TechnologyNetwork>;
  /** An aggregate relationship */
  networks_aggregate: TechnologyNetwork_Aggregate;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};


/** columns and relationships of "locations" */
export type PhysicalLocationNetworksArgs = {
  distinct_on?: InputMaybe<Array<TechnologyNetwork_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TechnologyNetwork_Order_By>>;
  where?: InputMaybe<TechnologyNetwork_Bool_Exp>;
};


/** columns and relationships of "locations" */
export type PhysicalLocationNetworks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<TechnologyNetwork_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TechnologyNetwork_Order_By>>;
  where?: InputMaybe<TechnologyNetwork_Bool_Exp>;
};

/** aggregated selection of "locations" */
export type PhysicalLocation_Aggregate = {
  __typename?: 'PhysicalLocation_aggregate';
  aggregate?: Maybe<PhysicalLocation_Aggregate_Fields>;
  nodes: Array<PhysicalLocation>;
};

/** aggregate fields of "locations" */
export type PhysicalLocation_Aggregate_Fields = {
  __typename?: 'PhysicalLocation_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<PhysicalLocation_Max_Fields>;
  min?: Maybe<PhysicalLocation_Min_Fields>;
};


/** aggregate fields of "locations" */
export type PhysicalLocation_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<PhysicalLocation_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "locations". All fields are combined with a logical 'AND'. */
export type PhysicalLocation_Bool_Exp = {
  _and?: InputMaybe<Array<PhysicalLocation_Bool_Exp>>;
  _not?: InputMaybe<PhysicalLocation_Bool_Exp>;
  _or?: InputMaybe<Array<PhysicalLocation_Bool_Exp>>;
  code?: InputMaybe<String_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  networks?: InputMaybe<TechnologyNetwork_Bool_Exp>;
  networks_aggregate?: InputMaybe<TechnologyNetwork_Aggregate_Bool_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "locations" */
export enum PhysicalLocation_Constraint {
  /** unique or primary key constraint on columns "code" */
  LocationsCodeUnique = 'locations_code_unique',
  /** unique or primary key constraint on columns "id" */
  LocationsPkey = 'locations_pkey'
}

/** input type for inserting data into table "locations" */
export type PhysicalLocation_Insert_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  networks?: InputMaybe<TechnologyNetwork_Arr_Rel_Insert_Input>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type PhysicalLocation_Max_Fields = {
  __typename?: 'PhysicalLocation_max_fields';
  code?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type PhysicalLocation_Min_Fields = {
  __typename?: 'PhysicalLocation_min_fields';
  code?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "locations" */
export type PhysicalLocation_Mutation_Response = {
  __typename?: 'PhysicalLocation_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<PhysicalLocation>;
};

/** input type for inserting object relation for remote table "locations" */
export type PhysicalLocation_Obj_Rel_Insert_Input = {
  data: PhysicalLocation_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<PhysicalLocation_On_Conflict>;
};

/** on_conflict condition type for table "locations" */
export type PhysicalLocation_On_Conflict = {
  constraint: PhysicalLocation_Constraint;
  update_columns?: Array<PhysicalLocation_Update_Column>;
  where?: InputMaybe<PhysicalLocation_Bool_Exp>;
};

/** Ordering options when selecting data from "locations". */
export type PhysicalLocation_Order_By = {
  code?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  networks_aggregate?: InputMaybe<TechnologyNetwork_Aggregate_Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: locations */
export type PhysicalLocation_Pk_Columns_Input = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "locations" */
export enum PhysicalLocation_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "locations" */
export type PhysicalLocation_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "PhysicalLocation" */
export type PhysicalLocation_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: PhysicalLocation_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type PhysicalLocation_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "locations" */
export enum PhysicalLocation_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type PhysicalLocation_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<PhysicalLocation_Set_Input>;
  /** filter the rows which have to be updated */
  where: PhysicalLocation_Bool_Exp;
};

/** columns and relationships of "plateaus" */
export type Plateau = {
  __typename?: 'Plateau';
  code: Scalars['String']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['uuid']['output'];
  name: Scalars['String']['output'];
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "plateaus" */
export type Plateau_Aggregate = {
  __typename?: 'Plateau_aggregate';
  aggregate?: Maybe<Plateau_Aggregate_Fields>;
  nodes: Array<Plateau>;
};

/** aggregate fields of "plateaus" */
export type Plateau_Aggregate_Fields = {
  __typename?: 'Plateau_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Plateau_Max_Fields>;
  min?: Maybe<Plateau_Min_Fields>;
};


/** aggregate fields of "plateaus" */
export type Plateau_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Plateau_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "plateaus". All fields are combined with a logical 'AND'. */
export type Plateau_Bool_Exp = {
  _and?: InputMaybe<Array<Plateau_Bool_Exp>>;
  _not?: InputMaybe<Plateau_Bool_Exp>;
  _or?: InputMaybe<Array<Plateau_Bool_Exp>>;
  code?: InputMaybe<String_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "plateaus" */
export enum Plateau_Constraint {
  /** unique or primary key constraint on columns "code" */
  PlateausCodeUnique = 'plateaus_code_unique',
  /** unique or primary key constraint on columns "id" */
  PlateausPkey = 'plateaus_pkey'
}

/** input type for inserting data into table "plateaus" */
export type Plateau_Insert_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Plateau_Max_Fields = {
  __typename?: 'Plateau_max_fields';
  code?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type Plateau_Min_Fields = {
  __typename?: 'Plateau_min_fields';
  code?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "plateaus" */
export type Plateau_Mutation_Response = {
  __typename?: 'Plateau_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Plateau>;
};

/** on_conflict condition type for table "plateaus" */
export type Plateau_On_Conflict = {
  constraint: Plateau_Constraint;
  update_columns?: Array<Plateau_Update_Column>;
  where?: InputMaybe<Plateau_Bool_Exp>;
};

/** Ordering options when selecting data from "plateaus". */
export type Plateau_Order_By = {
  code?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: plateaus */
export type Plateau_Pk_Columns_Input = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "plateaus" */
export enum Plateau_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "plateaus" */
export type Plateau_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "Plateau" */
export type Plateau_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Plateau_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Plateau_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "plateaus" */
export enum Plateau_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type Plateau_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Plateau_Set_Input>;
  /** filter the rows which have to be updated */
  where: Plateau_Bool_Exp;
};

/** columns and relationships of "processes" */
export type ProcessGeneric = {
  __typename?: 'ProcessGeneric';
  /** An array relationship */
  capabilities: Array<CapabilityBusinessProcessMap>;
  /** An aggregate relationship */
  capabilities_aggregate: CapabilityBusinessProcessMap_Aggregate;
  /** An array relationship */
  child: Array<BusinessProcessHierarchyMap>;
  /** An aggregate relationship */
  child_aggregate: BusinessProcessHierarchyMap_Aggregate;
  code: Scalars['String']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  functions: Array<BusinessProcessFunctionMap>;
  /** An aggregate relationship */
  functions_aggregate: BusinessProcessFunctionMap_Aggregate;
  id: Scalars['uuid']['output'];
  layer: Scalars['layer_kind_enum']['output'];
  /** An array relationship */
  motivations: Array<BusinessProcessMotivationItemMap>;
  /** An aggregate relationship */
  motivations_aggregate: BusinessProcessMotivationItemMap_Aggregate;
  name: Scalars['String']['output'];
  /** An array relationship */
  parent: Array<BusinessProcessHierarchyMap>;
  /** An aggregate relationship */
  parent_aggregate: BusinessProcessHierarchyMap_Aggregate;
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};


/** columns and relationships of "processes" */
export type ProcessGenericCapabilitiesArgs = {
  distinct_on?: InputMaybe<Array<CapabilityBusinessProcessMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CapabilityBusinessProcessMap_Order_By>>;
  where?: InputMaybe<CapabilityBusinessProcessMap_Bool_Exp>;
};


/** columns and relationships of "processes" */
export type ProcessGenericCapabilities_AggregateArgs = {
  distinct_on?: InputMaybe<Array<CapabilityBusinessProcessMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CapabilityBusinessProcessMap_Order_By>>;
  where?: InputMaybe<CapabilityBusinessProcessMap_Bool_Exp>;
};


/** columns and relationships of "processes" */
export type ProcessGenericChildArgs = {
  distinct_on?: InputMaybe<Array<BusinessProcessHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessProcessHierarchyMap_Order_By>>;
  where?: InputMaybe<BusinessProcessHierarchyMap_Bool_Exp>;
};


/** columns and relationships of "processes" */
export type ProcessGenericChild_AggregateArgs = {
  distinct_on?: InputMaybe<Array<BusinessProcessHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessProcessHierarchyMap_Order_By>>;
  where?: InputMaybe<BusinessProcessHierarchyMap_Bool_Exp>;
};


/** columns and relationships of "processes" */
export type ProcessGenericFunctionsArgs = {
  distinct_on?: InputMaybe<Array<BusinessProcessFunctionMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessProcessFunctionMap_Order_By>>;
  where?: InputMaybe<BusinessProcessFunctionMap_Bool_Exp>;
};


/** columns and relationships of "processes" */
export type ProcessGenericFunctions_AggregateArgs = {
  distinct_on?: InputMaybe<Array<BusinessProcessFunctionMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessProcessFunctionMap_Order_By>>;
  where?: InputMaybe<BusinessProcessFunctionMap_Bool_Exp>;
};


/** columns and relationships of "processes" */
export type ProcessGenericMotivationsArgs = {
  distinct_on?: InputMaybe<Array<BusinessProcessMotivationItemMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessProcessMotivationItemMap_Order_By>>;
  where?: InputMaybe<BusinessProcessMotivationItemMap_Bool_Exp>;
};


/** columns and relationships of "processes" */
export type ProcessGenericMotivations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<BusinessProcessMotivationItemMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessProcessMotivationItemMap_Order_By>>;
  where?: InputMaybe<BusinessProcessMotivationItemMap_Bool_Exp>;
};


/** columns and relationships of "processes" */
export type ProcessGenericParentArgs = {
  distinct_on?: InputMaybe<Array<BusinessProcessHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessProcessHierarchyMap_Order_By>>;
  where?: InputMaybe<BusinessProcessHierarchyMap_Bool_Exp>;
};


/** columns and relationships of "processes" */
export type ProcessGenericParent_AggregateArgs = {
  distinct_on?: InputMaybe<Array<BusinessProcessHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessProcessHierarchyMap_Order_By>>;
  where?: InputMaybe<BusinessProcessHierarchyMap_Bool_Exp>;
};

/** aggregated selection of "processes" */
export type ProcessGeneric_Aggregate = {
  __typename?: 'ProcessGeneric_aggregate';
  aggregate?: Maybe<ProcessGeneric_Aggregate_Fields>;
  nodes: Array<ProcessGeneric>;
};

/** aggregate fields of "processes" */
export type ProcessGeneric_Aggregate_Fields = {
  __typename?: 'ProcessGeneric_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<ProcessGeneric_Max_Fields>;
  min?: Maybe<ProcessGeneric_Min_Fields>;
};


/** aggregate fields of "processes" */
export type ProcessGeneric_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<ProcessGeneric_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "processes". All fields are combined with a logical 'AND'. */
export type ProcessGeneric_Bool_Exp = {
  _and?: InputMaybe<Array<ProcessGeneric_Bool_Exp>>;
  _not?: InputMaybe<ProcessGeneric_Bool_Exp>;
  _or?: InputMaybe<Array<ProcessGeneric_Bool_Exp>>;
  capabilities?: InputMaybe<CapabilityBusinessProcessMap_Bool_Exp>;
  capabilities_aggregate?: InputMaybe<CapabilityBusinessProcessMap_Aggregate_Bool_Exp>;
  child?: InputMaybe<BusinessProcessHierarchyMap_Bool_Exp>;
  child_aggregate?: InputMaybe<BusinessProcessHierarchyMap_Aggregate_Bool_Exp>;
  code?: InputMaybe<String_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  functions?: InputMaybe<BusinessProcessFunctionMap_Bool_Exp>;
  functions_aggregate?: InputMaybe<BusinessProcessFunctionMap_Aggregate_Bool_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  layer?: InputMaybe<Layer_Kind_Enum_Comparison_Exp>;
  motivations?: InputMaybe<BusinessProcessMotivationItemMap_Bool_Exp>;
  motivations_aggregate?: InputMaybe<BusinessProcessMotivationItemMap_Aggregate_Bool_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  parent?: InputMaybe<BusinessProcessHierarchyMap_Bool_Exp>;
  parent_aggregate?: InputMaybe<BusinessProcessHierarchyMap_Aggregate_Bool_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "processes" */
export enum ProcessGeneric_Constraint {
  /** unique or primary key constraint on columns "code" */
  ProcessesCodeUnique = 'processes_code_unique',
  /** unique or primary key constraint on columns "id" */
  ProcessesPkey = 'processes_pkey'
}

/** input type for inserting data into table "processes" */
export type ProcessGeneric_Insert_Input = {
  capabilities?: InputMaybe<CapabilityBusinessProcessMap_Arr_Rel_Insert_Input>;
  child?: InputMaybe<BusinessProcessHierarchyMap_Arr_Rel_Insert_Input>;
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  functions?: InputMaybe<BusinessProcessFunctionMap_Arr_Rel_Insert_Input>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  layer?: InputMaybe<Scalars['layer_kind_enum']['input']>;
  motivations?: InputMaybe<BusinessProcessMotivationItemMap_Arr_Rel_Insert_Input>;
  name?: InputMaybe<Scalars['String']['input']>;
  parent?: InputMaybe<BusinessProcessHierarchyMap_Arr_Rel_Insert_Input>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type ProcessGeneric_Max_Fields = {
  __typename?: 'ProcessGeneric_max_fields';
  code?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  layer?: Maybe<Scalars['layer_kind_enum']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type ProcessGeneric_Min_Fields = {
  __typename?: 'ProcessGeneric_min_fields';
  code?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  layer?: Maybe<Scalars['layer_kind_enum']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "processes" */
export type ProcessGeneric_Mutation_Response = {
  __typename?: 'ProcessGeneric_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<ProcessGeneric>;
};

/** input type for inserting object relation for remote table "processes" */
export type ProcessGeneric_Obj_Rel_Insert_Input = {
  data: ProcessGeneric_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<ProcessGeneric_On_Conflict>;
};

/** on_conflict condition type for table "processes" */
export type ProcessGeneric_On_Conflict = {
  constraint: ProcessGeneric_Constraint;
  update_columns?: Array<ProcessGeneric_Update_Column>;
  where?: InputMaybe<ProcessGeneric_Bool_Exp>;
};

/** Ordering options when selecting data from "processes". */
export type ProcessGeneric_Order_By = {
  capabilities_aggregate?: InputMaybe<CapabilityBusinessProcessMap_Aggregate_Order_By>;
  child_aggregate?: InputMaybe<BusinessProcessHierarchyMap_Aggregate_Order_By>;
  code?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  functions_aggregate?: InputMaybe<BusinessProcessFunctionMap_Aggregate_Order_By>;
  id?: InputMaybe<Order_By>;
  layer?: InputMaybe<Order_By>;
  motivations_aggregate?: InputMaybe<BusinessProcessMotivationItemMap_Aggregate_Order_By>;
  name?: InputMaybe<Order_By>;
  parent_aggregate?: InputMaybe<BusinessProcessHierarchyMap_Aggregate_Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: processes */
export type ProcessGeneric_Pk_Columns_Input = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "processes" */
export enum ProcessGeneric_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Layer = 'layer',
  /** column name */
  Name = 'name',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "processes" */
export type ProcessGeneric_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  layer?: InputMaybe<Scalars['layer_kind_enum']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "ProcessEntity" */
export type ProcessGeneric_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: ProcessGeneric_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type ProcessGeneric_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  layer?: InputMaybe<Scalars['layer_kind_enum']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "processes" */
export enum ProcessGeneric_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Layer = 'layer',
  /** column name */
  Name = 'name',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type ProcessGeneric_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ProcessGeneric_Set_Input>;
  /** filter the rows which have to be updated */
  where: ProcessGeneric_Bool_Exp;
};

/** columns and relationships of "services" */
export type ServiceGeneric = {
  __typename?: 'ServiceGeneric';
  code: Scalars['String']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['uuid']['output'];
  layer: Scalars['layer_kind_enum']['output'];
  name: Scalars['String']['output'];
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "services" */
export type ServiceGeneric_Aggregate = {
  __typename?: 'ServiceGeneric_aggregate';
  aggregate?: Maybe<ServiceGeneric_Aggregate_Fields>;
  nodes: Array<ServiceGeneric>;
};

/** aggregate fields of "services" */
export type ServiceGeneric_Aggregate_Fields = {
  __typename?: 'ServiceGeneric_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<ServiceGeneric_Max_Fields>;
  min?: Maybe<ServiceGeneric_Min_Fields>;
};


/** aggregate fields of "services" */
export type ServiceGeneric_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<ServiceGeneric_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "services". All fields are combined with a logical 'AND'. */
export type ServiceGeneric_Bool_Exp = {
  _and?: InputMaybe<Array<ServiceGeneric_Bool_Exp>>;
  _not?: InputMaybe<ServiceGeneric_Bool_Exp>;
  _or?: InputMaybe<Array<ServiceGeneric_Bool_Exp>>;
  code?: InputMaybe<String_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  layer?: InputMaybe<Layer_Kind_Enum_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "services" */
export enum ServiceGeneric_Constraint {
  /** unique or primary key constraint on columns "code" */
  ServicesCodeUnique = 'services_code_unique',
  /** unique or primary key constraint on columns "id" */
  ServicesPkey = 'services_pkey'
}

/** input type for inserting data into table "services" */
export type ServiceGeneric_Insert_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  layer?: InputMaybe<Scalars['layer_kind_enum']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type ServiceGeneric_Max_Fields = {
  __typename?: 'ServiceGeneric_max_fields';
  code?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  layer?: Maybe<Scalars['layer_kind_enum']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type ServiceGeneric_Min_Fields = {
  __typename?: 'ServiceGeneric_min_fields';
  code?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  layer?: Maybe<Scalars['layer_kind_enum']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "services" */
export type ServiceGeneric_Mutation_Response = {
  __typename?: 'ServiceGeneric_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<ServiceGeneric>;
};

/** on_conflict condition type for table "services" */
export type ServiceGeneric_On_Conflict = {
  constraint: ServiceGeneric_Constraint;
  update_columns?: Array<ServiceGeneric_Update_Column>;
  where?: InputMaybe<ServiceGeneric_Bool_Exp>;
};

/** Ordering options when selecting data from "services". */
export type ServiceGeneric_Order_By = {
  code?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  layer?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: services */
export type ServiceGeneric_Pk_Columns_Input = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "services" */
export enum ServiceGeneric_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Layer = 'layer',
  /** column name */
  Name = 'name',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "services" */
export type ServiceGeneric_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  layer?: InputMaybe<Scalars['layer_kind_enum']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "ServiceEntity" */
export type ServiceGeneric_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: ServiceGeneric_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type ServiceGeneric_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  layer?: InputMaybe<Scalars['layer_kind_enum']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "services" */
export enum ServiceGeneric_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Layer = 'layer',
  /** column name */
  Name = 'name',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type ServiceGeneric_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<ServiceGeneric_Set_Input>;
  /** filter the rows which have to be updated */
  where: ServiceGeneric_Bool_Exp;
};

/** columns and relationships of "solutions" */
export type Solution = {
  __typename?: 'Solution';
  acceptedAt?: Maybe<Scalars['timestamptz']['output']>;
  acceptedBy?: Maybe<Scalars['uuid']['output']>;
  alternatives: Scalars['String']['output'];
  code: Scalars['String']['output'];
  /** An array relationship */
  components: Array<SolutionApplicationComponentMap>;
  /** An aggregate relationship */
  components_aggregate: SolutionApplicationComponentMap_Aggregate;
  consequences: Scalars['String']['output'];
  context: Scalars['String']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  /** An array relationship */
  dataObjects: Array<SolutionDataObjectMap>;
  /** An aggregate relationship */
  dataObjects_aggregate: SolutionDataObjectMap_Aggregate;
  decision: Scalars['String']['output'];
  decisionStatus: Scalars['solution_life_cycle_enum']['output'];
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  flows: Array<SolutionFlowMap>;
  /** An aggregate relationship */
  flows_aggregate: SolutionFlowMap_Aggregate;
  /** An array relationship */
  functions: Array<SolutionApplicationFunctionMap>;
  /** An aggregate relationship */
  functions_aggregate: SolutionApplicationFunctionMap_Aggregate;
  id: Scalars['uuid']['output'];
  implementationStatus: Scalars['solution_implementation_status_enum']['output'];
  /** An array relationship */
  motivations: Array<SolutionMotivationElementMap>;
  /** An aggregate relationship */
  motivations_aggregate: SolutionMotivationElementMap_Aggregate;
  name: Scalars['String']['output'];
  /** An array relationship */
  solutionMapSolutionTechnologyNode: Array<SolutionTechnologyNodeMap>;
  /** An aggregate relationship */
  solutionMapSolutionTechnologyNode_aggregate: SolutionTechnologyNodeMap_Aggregate;
  /** An array relationship */
  stakeholders: Array<SolutionStakeholderMap>;
  /** An aggregate relationship */
  stakeholders_aggregate: SolutionStakeholderMap_Aggregate;
  stateId: Scalars['uuid']['output'];
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};


/** columns and relationships of "solutions" */
export type SolutionComponentsArgs = {
  distinct_on?: InputMaybe<Array<SolutionApplicationComponentMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionApplicationComponentMap_Order_By>>;
  where?: InputMaybe<SolutionApplicationComponentMap_Bool_Exp>;
};


/** columns and relationships of "solutions" */
export type SolutionComponents_AggregateArgs = {
  distinct_on?: InputMaybe<Array<SolutionApplicationComponentMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionApplicationComponentMap_Order_By>>;
  where?: InputMaybe<SolutionApplicationComponentMap_Bool_Exp>;
};


/** columns and relationships of "solutions" */
export type SolutionDataObjectsArgs = {
  distinct_on?: InputMaybe<Array<SolutionDataObjectMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionDataObjectMap_Order_By>>;
  where?: InputMaybe<SolutionDataObjectMap_Bool_Exp>;
};


/** columns and relationships of "solutions" */
export type SolutionDataObjects_AggregateArgs = {
  distinct_on?: InputMaybe<Array<SolutionDataObjectMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionDataObjectMap_Order_By>>;
  where?: InputMaybe<SolutionDataObjectMap_Bool_Exp>;
};


/** columns and relationships of "solutions" */
export type SolutionFlowsArgs = {
  distinct_on?: InputMaybe<Array<SolutionFlowMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionFlowMap_Order_By>>;
  where?: InputMaybe<SolutionFlowMap_Bool_Exp>;
};


/** columns and relationships of "solutions" */
export type SolutionFlows_AggregateArgs = {
  distinct_on?: InputMaybe<Array<SolutionFlowMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionFlowMap_Order_By>>;
  where?: InputMaybe<SolutionFlowMap_Bool_Exp>;
};


/** columns and relationships of "solutions" */
export type SolutionFunctionsArgs = {
  distinct_on?: InputMaybe<Array<SolutionApplicationFunctionMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionApplicationFunctionMap_Order_By>>;
  where?: InputMaybe<SolutionApplicationFunctionMap_Bool_Exp>;
};


/** columns and relationships of "solutions" */
export type SolutionFunctions_AggregateArgs = {
  distinct_on?: InputMaybe<Array<SolutionApplicationFunctionMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionApplicationFunctionMap_Order_By>>;
  where?: InputMaybe<SolutionApplicationFunctionMap_Bool_Exp>;
};


/** columns and relationships of "solutions" */
export type SolutionMotivationsArgs = {
  distinct_on?: InputMaybe<Array<SolutionMotivationElementMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionMotivationElementMap_Order_By>>;
  where?: InputMaybe<SolutionMotivationElementMap_Bool_Exp>;
};


/** columns and relationships of "solutions" */
export type SolutionMotivations_AggregateArgs = {
  distinct_on?: InputMaybe<Array<SolutionMotivationElementMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionMotivationElementMap_Order_By>>;
  where?: InputMaybe<SolutionMotivationElementMap_Bool_Exp>;
};


/** columns and relationships of "solutions" */
export type SolutionSolutionMapSolutionTechnologyNodeArgs = {
  distinct_on?: InputMaybe<Array<SolutionTechnologyNodeMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionTechnologyNodeMap_Order_By>>;
  where?: InputMaybe<SolutionTechnologyNodeMap_Bool_Exp>;
};


/** columns and relationships of "solutions" */
export type SolutionSolutionMapSolutionTechnologyNode_AggregateArgs = {
  distinct_on?: InputMaybe<Array<SolutionTechnologyNodeMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionTechnologyNodeMap_Order_By>>;
  where?: InputMaybe<SolutionTechnologyNodeMap_Bool_Exp>;
};


/** columns and relationships of "solutions" */
export type SolutionStakeholdersArgs = {
  distinct_on?: InputMaybe<Array<SolutionStakeholderMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionStakeholderMap_Order_By>>;
  where?: InputMaybe<SolutionStakeholderMap_Bool_Exp>;
};


/** columns and relationships of "solutions" */
export type SolutionStakeholders_AggregateArgs = {
  distinct_on?: InputMaybe<Array<SolutionStakeholderMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionStakeholderMap_Order_By>>;
  where?: InputMaybe<SolutionStakeholderMap_Bool_Exp>;
};

/** columns and relationships of "map_solution_application_component" */
export type SolutionApplicationComponentMap = {
  __typename?: 'SolutionApplicationComponentMap';
  /** An object relationship */
  component: ApplicationComponent;
  componentId: Scalars['uuid']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  /** An array relationship */
  motivationsInSolution: Array<SolutionMotivationComponentMap>;
  /** An aggregate relationship */
  motivationsInSolution_aggregate: SolutionMotivationComponentMap_Aggregate;
  /** An object relationship */
  solution: Solution;
  solutionId: Scalars['uuid']['output'];
  state: Scalars['solution_item_impact_type_enum']['output'];
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};


/** columns and relationships of "map_solution_application_component" */
export type SolutionApplicationComponentMapMotivationsInSolutionArgs = {
  distinct_on?: InputMaybe<Array<SolutionMotivationComponentMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionMotivationComponentMap_Order_By>>;
  where?: InputMaybe<SolutionMotivationComponentMap_Bool_Exp>;
};


/** columns and relationships of "map_solution_application_component" */
export type SolutionApplicationComponentMapMotivationsInSolution_AggregateArgs = {
  distinct_on?: InputMaybe<Array<SolutionMotivationComponentMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionMotivationComponentMap_Order_By>>;
  where?: InputMaybe<SolutionMotivationComponentMap_Bool_Exp>;
};

/** aggregated selection of "map_solution_application_component" */
export type SolutionApplicationComponentMap_Aggregate = {
  __typename?: 'SolutionApplicationComponentMap_aggregate';
  aggregate?: Maybe<SolutionApplicationComponentMap_Aggregate_Fields>;
  nodes: Array<SolutionApplicationComponentMap>;
};

export type SolutionApplicationComponentMap_Aggregate_Bool_Exp = {
  count?: InputMaybe<SolutionApplicationComponentMap_Aggregate_Bool_Exp_Count>;
};

export type SolutionApplicationComponentMap_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<SolutionApplicationComponentMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<SolutionApplicationComponentMap_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "map_solution_application_component" */
export type SolutionApplicationComponentMap_Aggregate_Fields = {
  __typename?: 'SolutionApplicationComponentMap_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<SolutionApplicationComponentMap_Max_Fields>;
  min?: Maybe<SolutionApplicationComponentMap_Min_Fields>;
};


/** aggregate fields of "map_solution_application_component" */
export type SolutionApplicationComponentMap_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<SolutionApplicationComponentMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "map_solution_application_component" */
export type SolutionApplicationComponentMap_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<SolutionApplicationComponentMap_Max_Order_By>;
  min?: InputMaybe<SolutionApplicationComponentMap_Min_Order_By>;
};

/** input type for inserting array relation for remote table "map_solution_application_component" */
export type SolutionApplicationComponentMap_Arr_Rel_Insert_Input = {
  data: Array<SolutionApplicationComponentMap_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<SolutionApplicationComponentMap_On_Conflict>;
};

/** Boolean expression to filter rows from the table "map_solution_application_component". All fields are combined with a logical 'AND'. */
export type SolutionApplicationComponentMap_Bool_Exp = {
  _and?: InputMaybe<Array<SolutionApplicationComponentMap_Bool_Exp>>;
  _not?: InputMaybe<SolutionApplicationComponentMap_Bool_Exp>;
  _or?: InputMaybe<Array<SolutionApplicationComponentMap_Bool_Exp>>;
  component?: InputMaybe<ApplicationComponent_Bool_Exp>;
  componentId?: InputMaybe<Uuid_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  motivationsInSolution?: InputMaybe<SolutionMotivationComponentMap_Bool_Exp>;
  motivationsInSolution_aggregate?: InputMaybe<SolutionMotivationComponentMap_Aggregate_Bool_Exp>;
  solution?: InputMaybe<Solution_Bool_Exp>;
  solutionId?: InputMaybe<Uuid_Comparison_Exp>;
  state?: InputMaybe<Solution_Item_Impact_Type_Enum_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "map_solution_application_component" */
export enum SolutionApplicationComponentMap_Constraint {
  /** unique or primary key constraint on columns "component_id", "solution_id" */
  MapSolutionApplicationComponentComponentIdS_23157Unique = 'map_solution_application_component_component_id_s_23157_unique',
  /** unique or primary key constraint on columns "component_id", "solution_id" */
  MapSolutionApplicationComponentPkey = 'map_solution_application_component_pkey'
}

/** input type for inserting data into table "map_solution_application_component" */
export type SolutionApplicationComponentMap_Insert_Input = {
  component?: InputMaybe<ApplicationComponent_Obj_Rel_Insert_Input>;
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  motivationsInSolution?: InputMaybe<SolutionMotivationComponentMap_Arr_Rel_Insert_Input>;
  solution?: InputMaybe<Solution_Obj_Rel_Insert_Input>;
  solutionId?: InputMaybe<Scalars['uuid']['input']>;
  state?: InputMaybe<Scalars['solution_item_impact_type_enum']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type SolutionApplicationComponentMap_Max_Fields = {
  __typename?: 'SolutionApplicationComponentMap_max_fields';
  componentId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  solutionId?: Maybe<Scalars['uuid']['output']>;
  state?: Maybe<Scalars['solution_item_impact_type_enum']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "map_solution_application_component" */
export type SolutionApplicationComponentMap_Max_Order_By = {
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  solutionId?: InputMaybe<Order_By>;
  state?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type SolutionApplicationComponentMap_Min_Fields = {
  __typename?: 'SolutionApplicationComponentMap_min_fields';
  componentId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  solutionId?: Maybe<Scalars['uuid']['output']>;
  state?: Maybe<Scalars['solution_item_impact_type_enum']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "map_solution_application_component" */
export type SolutionApplicationComponentMap_Min_Order_By = {
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  solutionId?: InputMaybe<Order_By>;
  state?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "map_solution_application_component" */
export type SolutionApplicationComponentMap_Mutation_Response = {
  __typename?: 'SolutionApplicationComponentMap_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<SolutionApplicationComponentMap>;
};

/** on_conflict condition type for table "map_solution_application_component" */
export type SolutionApplicationComponentMap_On_Conflict = {
  constraint: SolutionApplicationComponentMap_Constraint;
  update_columns?: Array<SolutionApplicationComponentMap_Update_Column>;
  where?: InputMaybe<SolutionApplicationComponentMap_Bool_Exp>;
};

/** Ordering options when selecting data from "map_solution_application_component". */
export type SolutionApplicationComponentMap_Order_By = {
  component?: InputMaybe<ApplicationComponent_Order_By>;
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  motivationsInSolution_aggregate?: InputMaybe<SolutionMotivationComponentMap_Aggregate_Order_By>;
  solution?: InputMaybe<Solution_Order_By>;
  solutionId?: InputMaybe<Order_By>;
  state?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: map_solution_application_component */
export type SolutionApplicationComponentMap_Pk_Columns_Input = {
  componentId: Scalars['uuid']['input'];
  solutionId: Scalars['uuid']['input'];
};

/** select columns of table "map_solution_application_component" */
export enum SolutionApplicationComponentMap_Select_Column {
  /** column name */
  ComponentId = 'componentId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  SolutionId = 'solutionId',
  /** column name */
  State = 'state',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "map_solution_application_component" */
export type SolutionApplicationComponentMap_Set_Input = {
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  solutionId?: InputMaybe<Scalars['uuid']['input']>;
  state?: InputMaybe<Scalars['solution_item_impact_type_enum']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "SolutionApplicationComponentMap" */
export type SolutionApplicationComponentMap_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: SolutionApplicationComponentMap_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type SolutionApplicationComponentMap_Stream_Cursor_Value_Input = {
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  solutionId?: InputMaybe<Scalars['uuid']['input']>;
  state?: InputMaybe<Scalars['solution_item_impact_type_enum']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "map_solution_application_component" */
export enum SolutionApplicationComponentMap_Update_Column {
  /** column name */
  ComponentId = 'componentId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  SolutionId = 'solutionId',
  /** column name */
  State = 'state',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type SolutionApplicationComponentMap_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<SolutionApplicationComponentMap_Set_Input>;
  /** filter the rows which have to be updated */
  where: SolutionApplicationComponentMap_Bool_Exp;
};

/** columns and relationships of "map_solution_application_function" */
export type SolutionApplicationFunctionMap = {
  __typename?: 'SolutionApplicationFunctionMap';
  componentId: Scalars['uuid']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  functionId: Scalars['uuid']['output'];
  /** An object relationship */
  solution: Solution;
  solutionId: Scalars['uuid']['output'];
  state: Scalars['solution_item_impact_type_enum']['output'];
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "map_solution_application_function" */
export type SolutionApplicationFunctionMap_Aggregate = {
  __typename?: 'SolutionApplicationFunctionMap_aggregate';
  aggregate?: Maybe<SolutionApplicationFunctionMap_Aggregate_Fields>;
  nodes: Array<SolutionApplicationFunctionMap>;
};

export type SolutionApplicationFunctionMap_Aggregate_Bool_Exp = {
  count?: InputMaybe<SolutionApplicationFunctionMap_Aggregate_Bool_Exp_Count>;
};

export type SolutionApplicationFunctionMap_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<SolutionApplicationFunctionMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<SolutionApplicationFunctionMap_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "map_solution_application_function" */
export type SolutionApplicationFunctionMap_Aggregate_Fields = {
  __typename?: 'SolutionApplicationFunctionMap_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<SolutionApplicationFunctionMap_Max_Fields>;
  min?: Maybe<SolutionApplicationFunctionMap_Min_Fields>;
};


/** aggregate fields of "map_solution_application_function" */
export type SolutionApplicationFunctionMap_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<SolutionApplicationFunctionMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "map_solution_application_function" */
export type SolutionApplicationFunctionMap_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<SolutionApplicationFunctionMap_Max_Order_By>;
  min?: InputMaybe<SolutionApplicationFunctionMap_Min_Order_By>;
};

/** input type for inserting array relation for remote table "map_solution_application_function" */
export type SolutionApplicationFunctionMap_Arr_Rel_Insert_Input = {
  data: Array<SolutionApplicationFunctionMap_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<SolutionApplicationFunctionMap_On_Conflict>;
};

/** Boolean expression to filter rows from the table "map_solution_application_function". All fields are combined with a logical 'AND'. */
export type SolutionApplicationFunctionMap_Bool_Exp = {
  _and?: InputMaybe<Array<SolutionApplicationFunctionMap_Bool_Exp>>;
  _not?: InputMaybe<SolutionApplicationFunctionMap_Bool_Exp>;
  _or?: InputMaybe<Array<SolutionApplicationFunctionMap_Bool_Exp>>;
  componentId?: InputMaybe<Uuid_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  functionId?: InputMaybe<Uuid_Comparison_Exp>;
  solution?: InputMaybe<Solution_Bool_Exp>;
  solutionId?: InputMaybe<Uuid_Comparison_Exp>;
  state?: InputMaybe<Solution_Item_Impact_Type_Enum_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "map_solution_application_function" */
export enum SolutionApplicationFunctionMap_Constraint {
  /** unique or primary key constraint on columns "component_id", "function_id", "solution_id" */
  MapSolutionApplicationFunctionPkey = 'map_solution_application_function_pkey'
}

/** input type for inserting data into table "map_solution_application_function" */
export type SolutionApplicationFunctionMap_Insert_Input = {
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  functionId?: InputMaybe<Scalars['uuid']['input']>;
  solution?: InputMaybe<Solution_Obj_Rel_Insert_Input>;
  solutionId?: InputMaybe<Scalars['uuid']['input']>;
  state?: InputMaybe<Scalars['solution_item_impact_type_enum']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type SolutionApplicationFunctionMap_Max_Fields = {
  __typename?: 'SolutionApplicationFunctionMap_max_fields';
  componentId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  functionId?: Maybe<Scalars['uuid']['output']>;
  solutionId?: Maybe<Scalars['uuid']['output']>;
  state?: Maybe<Scalars['solution_item_impact_type_enum']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "map_solution_application_function" */
export type SolutionApplicationFunctionMap_Max_Order_By = {
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  functionId?: InputMaybe<Order_By>;
  solutionId?: InputMaybe<Order_By>;
  state?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type SolutionApplicationFunctionMap_Min_Fields = {
  __typename?: 'SolutionApplicationFunctionMap_min_fields';
  componentId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  functionId?: Maybe<Scalars['uuid']['output']>;
  solutionId?: Maybe<Scalars['uuid']['output']>;
  state?: Maybe<Scalars['solution_item_impact_type_enum']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "map_solution_application_function" */
export type SolutionApplicationFunctionMap_Min_Order_By = {
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  functionId?: InputMaybe<Order_By>;
  solutionId?: InputMaybe<Order_By>;
  state?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "map_solution_application_function" */
export type SolutionApplicationFunctionMap_Mutation_Response = {
  __typename?: 'SolutionApplicationFunctionMap_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<SolutionApplicationFunctionMap>;
};

/** on_conflict condition type for table "map_solution_application_function" */
export type SolutionApplicationFunctionMap_On_Conflict = {
  constraint: SolutionApplicationFunctionMap_Constraint;
  update_columns?: Array<SolutionApplicationFunctionMap_Update_Column>;
  where?: InputMaybe<SolutionApplicationFunctionMap_Bool_Exp>;
};

/** Ordering options when selecting data from "map_solution_application_function". */
export type SolutionApplicationFunctionMap_Order_By = {
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  functionId?: InputMaybe<Order_By>;
  solution?: InputMaybe<Solution_Order_By>;
  solutionId?: InputMaybe<Order_By>;
  state?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: map_solution_application_function */
export type SolutionApplicationFunctionMap_Pk_Columns_Input = {
  componentId: Scalars['uuid']['input'];
  functionId: Scalars['uuid']['input'];
  solutionId: Scalars['uuid']['input'];
};

/** select columns of table "map_solution_application_function" */
export enum SolutionApplicationFunctionMap_Select_Column {
  /** column name */
  ComponentId = 'componentId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  FunctionId = 'functionId',
  /** column name */
  SolutionId = 'solutionId',
  /** column name */
  State = 'state',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "map_solution_application_function" */
export type SolutionApplicationFunctionMap_Set_Input = {
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  functionId?: InputMaybe<Scalars['uuid']['input']>;
  solutionId?: InputMaybe<Scalars['uuid']['input']>;
  state?: InputMaybe<Scalars['solution_item_impact_type_enum']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "SolutionApplicationFunctionMap" */
export type SolutionApplicationFunctionMap_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: SolutionApplicationFunctionMap_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type SolutionApplicationFunctionMap_Stream_Cursor_Value_Input = {
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  functionId?: InputMaybe<Scalars['uuid']['input']>;
  solutionId?: InputMaybe<Scalars['uuid']['input']>;
  state?: InputMaybe<Scalars['solution_item_impact_type_enum']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "map_solution_application_function" */
export enum SolutionApplicationFunctionMap_Update_Column {
  /** column name */
  ComponentId = 'componentId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  FunctionId = 'functionId',
  /** column name */
  SolutionId = 'solutionId',
  /** column name */
  State = 'state',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type SolutionApplicationFunctionMap_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<SolutionApplicationFunctionMap_Set_Input>;
  /** filter the rows which have to be updated */
  where: SolutionApplicationFunctionMap_Bool_Exp;
};

/** columns and relationships of "map_solution_data_object" */
export type SolutionDataObjectMap = {
  __typename?: 'SolutionDataObjectMap';
  componentId: Scalars['uuid']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  dataObjectId: Scalars['uuid']['output'];
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  solution: Solution;
  solutionId: Scalars['uuid']['output'];
  state: Scalars['solution_item_impact_type_enum']['output'];
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "map_solution_data_object" */
export type SolutionDataObjectMap_Aggregate = {
  __typename?: 'SolutionDataObjectMap_aggregate';
  aggregate?: Maybe<SolutionDataObjectMap_Aggregate_Fields>;
  nodes: Array<SolutionDataObjectMap>;
};

export type SolutionDataObjectMap_Aggregate_Bool_Exp = {
  count?: InputMaybe<SolutionDataObjectMap_Aggregate_Bool_Exp_Count>;
};

export type SolutionDataObjectMap_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<SolutionDataObjectMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<SolutionDataObjectMap_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "map_solution_data_object" */
export type SolutionDataObjectMap_Aggregate_Fields = {
  __typename?: 'SolutionDataObjectMap_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<SolutionDataObjectMap_Max_Fields>;
  min?: Maybe<SolutionDataObjectMap_Min_Fields>;
};


/** aggregate fields of "map_solution_data_object" */
export type SolutionDataObjectMap_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<SolutionDataObjectMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "map_solution_data_object" */
export type SolutionDataObjectMap_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<SolutionDataObjectMap_Max_Order_By>;
  min?: InputMaybe<SolutionDataObjectMap_Min_Order_By>;
};

/** input type for inserting array relation for remote table "map_solution_data_object" */
export type SolutionDataObjectMap_Arr_Rel_Insert_Input = {
  data: Array<SolutionDataObjectMap_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<SolutionDataObjectMap_On_Conflict>;
};

/** Boolean expression to filter rows from the table "map_solution_data_object". All fields are combined with a logical 'AND'. */
export type SolutionDataObjectMap_Bool_Exp = {
  _and?: InputMaybe<Array<SolutionDataObjectMap_Bool_Exp>>;
  _not?: InputMaybe<SolutionDataObjectMap_Bool_Exp>;
  _or?: InputMaybe<Array<SolutionDataObjectMap_Bool_Exp>>;
  componentId?: InputMaybe<Uuid_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  dataObjectId?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  solution?: InputMaybe<Solution_Bool_Exp>;
  solutionId?: InputMaybe<Uuid_Comparison_Exp>;
  state?: InputMaybe<Solution_Item_Impact_Type_Enum_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "map_solution_data_object" */
export enum SolutionDataObjectMap_Constraint {
  /** unique or primary key constraint on columns "data_object_id", "component_id", "solution_id" */
  MapSolutionDataObjectPkey = 'map_solution_data_object_pkey'
}

/** input type for inserting data into table "map_solution_data_object" */
export type SolutionDataObjectMap_Insert_Input = {
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  dataObjectId?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  solution?: InputMaybe<Solution_Obj_Rel_Insert_Input>;
  solutionId?: InputMaybe<Scalars['uuid']['input']>;
  state?: InputMaybe<Scalars['solution_item_impact_type_enum']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type SolutionDataObjectMap_Max_Fields = {
  __typename?: 'SolutionDataObjectMap_max_fields';
  componentId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  dataObjectId?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  solutionId?: Maybe<Scalars['uuid']['output']>;
  state?: Maybe<Scalars['solution_item_impact_type_enum']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "map_solution_data_object" */
export type SolutionDataObjectMap_Max_Order_By = {
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  dataObjectId?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  solutionId?: InputMaybe<Order_By>;
  state?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type SolutionDataObjectMap_Min_Fields = {
  __typename?: 'SolutionDataObjectMap_min_fields';
  componentId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  dataObjectId?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  solutionId?: Maybe<Scalars['uuid']['output']>;
  state?: Maybe<Scalars['solution_item_impact_type_enum']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "map_solution_data_object" */
export type SolutionDataObjectMap_Min_Order_By = {
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  dataObjectId?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  solutionId?: InputMaybe<Order_By>;
  state?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "map_solution_data_object" */
export type SolutionDataObjectMap_Mutation_Response = {
  __typename?: 'SolutionDataObjectMap_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<SolutionDataObjectMap>;
};

/** on_conflict condition type for table "map_solution_data_object" */
export type SolutionDataObjectMap_On_Conflict = {
  constraint: SolutionDataObjectMap_Constraint;
  update_columns?: Array<SolutionDataObjectMap_Update_Column>;
  where?: InputMaybe<SolutionDataObjectMap_Bool_Exp>;
};

/** Ordering options when selecting data from "map_solution_data_object". */
export type SolutionDataObjectMap_Order_By = {
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  dataObjectId?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  solution?: InputMaybe<Solution_Order_By>;
  solutionId?: InputMaybe<Order_By>;
  state?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: map_solution_data_object */
export type SolutionDataObjectMap_Pk_Columns_Input = {
  componentId: Scalars['uuid']['input'];
  dataObjectId: Scalars['uuid']['input'];
  solutionId: Scalars['uuid']['input'];
};

/** select columns of table "map_solution_data_object" */
export enum SolutionDataObjectMap_Select_Column {
  /** column name */
  ComponentId = 'componentId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DataObjectId = 'dataObjectId',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  SolutionId = 'solutionId',
  /** column name */
  State = 'state',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "map_solution_data_object" */
export type SolutionDataObjectMap_Set_Input = {
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  dataObjectId?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  solutionId?: InputMaybe<Scalars['uuid']['input']>;
  state?: InputMaybe<Scalars['solution_item_impact_type_enum']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "SolutionDataObjectMap" */
export type SolutionDataObjectMap_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: SolutionDataObjectMap_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type SolutionDataObjectMap_Stream_Cursor_Value_Input = {
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  dataObjectId?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  solutionId?: InputMaybe<Scalars['uuid']['input']>;
  state?: InputMaybe<Scalars['solution_item_impact_type_enum']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "map_solution_data_object" */
export enum SolutionDataObjectMap_Update_Column {
  /** column name */
  ComponentId = 'componentId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DataObjectId = 'dataObjectId',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  SolutionId = 'solutionId',
  /** column name */
  State = 'state',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type SolutionDataObjectMap_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<SolutionDataObjectMap_Set_Input>;
  /** filter the rows which have to be updated */
  where: SolutionDataObjectMap_Bool_Exp;
};

/** columns and relationships of "map_solution_flow" */
export type SolutionFlowMap = {
  __typename?: 'SolutionFlowMap';
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  flow: FlowGeneric;
  flowId: Scalars['uuid']['output'];
  label?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  solution: Solution;
  solutionId: Scalars['uuid']['output'];
  state: Scalars['solution_item_impact_type_enum']['output'];
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "map_solution_flow" */
export type SolutionFlowMap_Aggregate = {
  __typename?: 'SolutionFlowMap_aggregate';
  aggregate?: Maybe<SolutionFlowMap_Aggregate_Fields>;
  nodes: Array<SolutionFlowMap>;
};

export type SolutionFlowMap_Aggregate_Bool_Exp = {
  count?: InputMaybe<SolutionFlowMap_Aggregate_Bool_Exp_Count>;
};

export type SolutionFlowMap_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<SolutionFlowMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<SolutionFlowMap_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "map_solution_flow" */
export type SolutionFlowMap_Aggregate_Fields = {
  __typename?: 'SolutionFlowMap_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<SolutionFlowMap_Max_Fields>;
  min?: Maybe<SolutionFlowMap_Min_Fields>;
};


/** aggregate fields of "map_solution_flow" */
export type SolutionFlowMap_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<SolutionFlowMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "map_solution_flow" */
export type SolutionFlowMap_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<SolutionFlowMap_Max_Order_By>;
  min?: InputMaybe<SolutionFlowMap_Min_Order_By>;
};

/** input type for inserting array relation for remote table "map_solution_flow" */
export type SolutionFlowMap_Arr_Rel_Insert_Input = {
  data: Array<SolutionFlowMap_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<SolutionFlowMap_On_Conflict>;
};

/** Boolean expression to filter rows from the table "map_solution_flow". All fields are combined with a logical 'AND'. */
export type SolutionFlowMap_Bool_Exp = {
  _and?: InputMaybe<Array<SolutionFlowMap_Bool_Exp>>;
  _not?: InputMaybe<SolutionFlowMap_Bool_Exp>;
  _or?: InputMaybe<Array<SolutionFlowMap_Bool_Exp>>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  flow?: InputMaybe<FlowGeneric_Bool_Exp>;
  flowId?: InputMaybe<Uuid_Comparison_Exp>;
  label?: InputMaybe<String_Comparison_Exp>;
  solution?: InputMaybe<Solution_Bool_Exp>;
  solutionId?: InputMaybe<Uuid_Comparison_Exp>;
  state?: InputMaybe<Solution_Item_Impact_Type_Enum_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "map_solution_flow" */
export enum SolutionFlowMap_Constraint {
  /** unique or primary key constraint on columns "flow_id", "solution_id" */
  MapSolutionFlowPkey = 'map_solution_flow_pkey'
}

/** input type for inserting data into table "map_solution_flow" */
export type SolutionFlowMap_Insert_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  flow?: InputMaybe<FlowGeneric_Obj_Rel_Insert_Input>;
  flowId?: InputMaybe<Scalars['uuid']['input']>;
  label?: InputMaybe<Scalars['String']['input']>;
  solution?: InputMaybe<Solution_Obj_Rel_Insert_Input>;
  solutionId?: InputMaybe<Scalars['uuid']['input']>;
  state?: InputMaybe<Scalars['solution_item_impact_type_enum']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type SolutionFlowMap_Max_Fields = {
  __typename?: 'SolutionFlowMap_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  flowId?: Maybe<Scalars['uuid']['output']>;
  label?: Maybe<Scalars['String']['output']>;
  solutionId?: Maybe<Scalars['uuid']['output']>;
  state?: Maybe<Scalars['solution_item_impact_type_enum']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "map_solution_flow" */
export type SolutionFlowMap_Max_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  flowId?: InputMaybe<Order_By>;
  label?: InputMaybe<Order_By>;
  solutionId?: InputMaybe<Order_By>;
  state?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type SolutionFlowMap_Min_Fields = {
  __typename?: 'SolutionFlowMap_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  flowId?: Maybe<Scalars['uuid']['output']>;
  label?: Maybe<Scalars['String']['output']>;
  solutionId?: Maybe<Scalars['uuid']['output']>;
  state?: Maybe<Scalars['solution_item_impact_type_enum']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "map_solution_flow" */
export type SolutionFlowMap_Min_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  flowId?: InputMaybe<Order_By>;
  label?: InputMaybe<Order_By>;
  solutionId?: InputMaybe<Order_By>;
  state?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "map_solution_flow" */
export type SolutionFlowMap_Mutation_Response = {
  __typename?: 'SolutionFlowMap_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<SolutionFlowMap>;
};

/** on_conflict condition type for table "map_solution_flow" */
export type SolutionFlowMap_On_Conflict = {
  constraint: SolutionFlowMap_Constraint;
  update_columns?: Array<SolutionFlowMap_Update_Column>;
  where?: InputMaybe<SolutionFlowMap_Bool_Exp>;
};

/** Ordering options when selecting data from "map_solution_flow". */
export type SolutionFlowMap_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  flow?: InputMaybe<FlowGeneric_Order_By>;
  flowId?: InputMaybe<Order_By>;
  label?: InputMaybe<Order_By>;
  solution?: InputMaybe<Solution_Order_By>;
  solutionId?: InputMaybe<Order_By>;
  state?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: map_solution_flow */
export type SolutionFlowMap_Pk_Columns_Input = {
  flowId: Scalars['uuid']['input'];
  solutionId: Scalars['uuid']['input'];
};

/** select columns of table "map_solution_flow" */
export enum SolutionFlowMap_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  FlowId = 'flowId',
  /** column name */
  Label = 'label',
  /** column name */
  SolutionId = 'solutionId',
  /** column name */
  State = 'state',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "map_solution_flow" */
export type SolutionFlowMap_Set_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  flowId?: InputMaybe<Scalars['uuid']['input']>;
  label?: InputMaybe<Scalars['String']['input']>;
  solutionId?: InputMaybe<Scalars['uuid']['input']>;
  state?: InputMaybe<Scalars['solution_item_impact_type_enum']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "SolutionFlowMap" */
export type SolutionFlowMap_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: SolutionFlowMap_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type SolutionFlowMap_Stream_Cursor_Value_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  flowId?: InputMaybe<Scalars['uuid']['input']>;
  label?: InputMaybe<Scalars['String']['input']>;
  solutionId?: InputMaybe<Scalars['uuid']['input']>;
  state?: InputMaybe<Scalars['solution_item_impact_type_enum']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "map_solution_flow" */
export enum SolutionFlowMap_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  FlowId = 'flowId',
  /** column name */
  Label = 'label',
  /** column name */
  SolutionId = 'solutionId',
  /** column name */
  State = 'state',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type SolutionFlowMap_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<SolutionFlowMap_Set_Input>;
  /** filter the rows which have to be updated */
  where: SolutionFlowMap_Bool_Exp;
};

/** columns and relationships of "map_solution_motivation_component" */
export type SolutionMotivationComponentMap = {
  __typename?: 'SolutionMotivationComponentMap';
  componentId: Scalars['uuid']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  motivationId: Scalars['uuid']['output'];
  solutionId: Scalars['uuid']['output'];
  state: Scalars['solution_item_impact_type_enum']['output'];
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "map_solution_motivation_component" */
export type SolutionMotivationComponentMap_Aggregate = {
  __typename?: 'SolutionMotivationComponentMap_aggregate';
  aggregate?: Maybe<SolutionMotivationComponentMap_Aggregate_Fields>;
  nodes: Array<SolutionMotivationComponentMap>;
};

export type SolutionMotivationComponentMap_Aggregate_Bool_Exp = {
  count?: InputMaybe<SolutionMotivationComponentMap_Aggregate_Bool_Exp_Count>;
};

export type SolutionMotivationComponentMap_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<SolutionMotivationComponentMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<SolutionMotivationComponentMap_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "map_solution_motivation_component" */
export type SolutionMotivationComponentMap_Aggregate_Fields = {
  __typename?: 'SolutionMotivationComponentMap_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<SolutionMotivationComponentMap_Max_Fields>;
  min?: Maybe<SolutionMotivationComponentMap_Min_Fields>;
};


/** aggregate fields of "map_solution_motivation_component" */
export type SolutionMotivationComponentMap_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<SolutionMotivationComponentMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "map_solution_motivation_component" */
export type SolutionMotivationComponentMap_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<SolutionMotivationComponentMap_Max_Order_By>;
  min?: InputMaybe<SolutionMotivationComponentMap_Min_Order_By>;
};

/** input type for inserting array relation for remote table "map_solution_motivation_component" */
export type SolutionMotivationComponentMap_Arr_Rel_Insert_Input = {
  data: Array<SolutionMotivationComponentMap_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<SolutionMotivationComponentMap_On_Conflict>;
};

/** Boolean expression to filter rows from the table "map_solution_motivation_component". All fields are combined with a logical 'AND'. */
export type SolutionMotivationComponentMap_Bool_Exp = {
  _and?: InputMaybe<Array<SolutionMotivationComponentMap_Bool_Exp>>;
  _not?: InputMaybe<SolutionMotivationComponentMap_Bool_Exp>;
  _or?: InputMaybe<Array<SolutionMotivationComponentMap_Bool_Exp>>;
  componentId?: InputMaybe<Uuid_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  motivationId?: InputMaybe<Uuid_Comparison_Exp>;
  solutionId?: InputMaybe<Uuid_Comparison_Exp>;
  state?: InputMaybe<Solution_Item_Impact_Type_Enum_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "map_solution_motivation_component" */
export enum SolutionMotivationComponentMap_Constraint {
  /** unique or primary key constraint on columns "motivation_id", "component_id", "solution_id" */
  MapSolutionMotivationComponentPkey = 'map_solution_motivation_component_pkey'
}

/** input type for inserting data into table "map_solution_motivation_component" */
export type SolutionMotivationComponentMap_Insert_Input = {
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  motivationId?: InputMaybe<Scalars['uuid']['input']>;
  solutionId?: InputMaybe<Scalars['uuid']['input']>;
  state?: InputMaybe<Scalars['solution_item_impact_type_enum']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type SolutionMotivationComponentMap_Max_Fields = {
  __typename?: 'SolutionMotivationComponentMap_max_fields';
  componentId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  motivationId?: Maybe<Scalars['uuid']['output']>;
  solutionId?: Maybe<Scalars['uuid']['output']>;
  state?: Maybe<Scalars['solution_item_impact_type_enum']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "map_solution_motivation_component" */
export type SolutionMotivationComponentMap_Max_Order_By = {
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  motivationId?: InputMaybe<Order_By>;
  solutionId?: InputMaybe<Order_By>;
  state?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type SolutionMotivationComponentMap_Min_Fields = {
  __typename?: 'SolutionMotivationComponentMap_min_fields';
  componentId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  motivationId?: Maybe<Scalars['uuid']['output']>;
  solutionId?: Maybe<Scalars['uuid']['output']>;
  state?: Maybe<Scalars['solution_item_impact_type_enum']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "map_solution_motivation_component" */
export type SolutionMotivationComponentMap_Min_Order_By = {
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  motivationId?: InputMaybe<Order_By>;
  solutionId?: InputMaybe<Order_By>;
  state?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "map_solution_motivation_component" */
export type SolutionMotivationComponentMap_Mutation_Response = {
  __typename?: 'SolutionMotivationComponentMap_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<SolutionMotivationComponentMap>;
};

/** on_conflict condition type for table "map_solution_motivation_component" */
export type SolutionMotivationComponentMap_On_Conflict = {
  constraint: SolutionMotivationComponentMap_Constraint;
  update_columns?: Array<SolutionMotivationComponentMap_Update_Column>;
  where?: InputMaybe<SolutionMotivationComponentMap_Bool_Exp>;
};

/** Ordering options when selecting data from "map_solution_motivation_component". */
export type SolutionMotivationComponentMap_Order_By = {
  componentId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  motivationId?: InputMaybe<Order_By>;
  solutionId?: InputMaybe<Order_By>;
  state?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: map_solution_motivation_component */
export type SolutionMotivationComponentMap_Pk_Columns_Input = {
  componentId: Scalars['uuid']['input'];
  motivationId: Scalars['uuid']['input'];
  solutionId: Scalars['uuid']['input'];
};

/** select columns of table "map_solution_motivation_component" */
export enum SolutionMotivationComponentMap_Select_Column {
  /** column name */
  ComponentId = 'componentId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  MotivationId = 'motivationId',
  /** column name */
  SolutionId = 'solutionId',
  /** column name */
  State = 'state',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "map_solution_motivation_component" */
export type SolutionMotivationComponentMap_Set_Input = {
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  motivationId?: InputMaybe<Scalars['uuid']['input']>;
  solutionId?: InputMaybe<Scalars['uuid']['input']>;
  state?: InputMaybe<Scalars['solution_item_impact_type_enum']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "SolutionMotivationComponentMap" */
export type SolutionMotivationComponentMap_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: SolutionMotivationComponentMap_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type SolutionMotivationComponentMap_Stream_Cursor_Value_Input = {
  componentId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  motivationId?: InputMaybe<Scalars['uuid']['input']>;
  solutionId?: InputMaybe<Scalars['uuid']['input']>;
  state?: InputMaybe<Scalars['solution_item_impact_type_enum']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "map_solution_motivation_component" */
export enum SolutionMotivationComponentMap_Update_Column {
  /** column name */
  ComponentId = 'componentId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  MotivationId = 'motivationId',
  /** column name */
  SolutionId = 'solutionId',
  /** column name */
  State = 'state',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type SolutionMotivationComponentMap_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<SolutionMotivationComponentMap_Set_Input>;
  /** filter the rows which have to be updated */
  where: SolutionMotivationComponentMap_Bool_Exp;
};

/** columns and relationships of "map_solution_motivation" */
export type SolutionMotivationElementMap = {
  __typename?: 'SolutionMotivationElementMap';
  /** An array relationship */
  componentsInSolution: Array<SolutionMotivationComponentMap>;
  /** An aggregate relationship */
  componentsInSolution_aggregate: SolutionMotivationComponentMap_Aggregate;
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  motivation: MotivationElementGeneric;
  motivationId: Scalars['uuid']['output'];
  /** An object relationship */
  solution: Solution;
  solutionId: Scalars['uuid']['output'];
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};


/** columns and relationships of "map_solution_motivation" */
export type SolutionMotivationElementMapComponentsInSolutionArgs = {
  distinct_on?: InputMaybe<Array<SolutionMotivationComponentMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionMotivationComponentMap_Order_By>>;
  where?: InputMaybe<SolutionMotivationComponentMap_Bool_Exp>;
};


/** columns and relationships of "map_solution_motivation" */
export type SolutionMotivationElementMapComponentsInSolution_AggregateArgs = {
  distinct_on?: InputMaybe<Array<SolutionMotivationComponentMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionMotivationComponentMap_Order_By>>;
  where?: InputMaybe<SolutionMotivationComponentMap_Bool_Exp>;
};

/** aggregated selection of "map_solution_motivation" */
export type SolutionMotivationElementMap_Aggregate = {
  __typename?: 'SolutionMotivationElementMap_aggregate';
  aggregate?: Maybe<SolutionMotivationElementMap_Aggregate_Fields>;
  nodes: Array<SolutionMotivationElementMap>;
};

export type SolutionMotivationElementMap_Aggregate_Bool_Exp = {
  count?: InputMaybe<SolutionMotivationElementMap_Aggregate_Bool_Exp_Count>;
};

export type SolutionMotivationElementMap_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<SolutionMotivationElementMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<SolutionMotivationElementMap_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "map_solution_motivation" */
export type SolutionMotivationElementMap_Aggregate_Fields = {
  __typename?: 'SolutionMotivationElementMap_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<SolutionMotivationElementMap_Max_Fields>;
  min?: Maybe<SolutionMotivationElementMap_Min_Fields>;
};


/** aggregate fields of "map_solution_motivation" */
export type SolutionMotivationElementMap_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<SolutionMotivationElementMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "map_solution_motivation" */
export type SolutionMotivationElementMap_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<SolutionMotivationElementMap_Max_Order_By>;
  min?: InputMaybe<SolutionMotivationElementMap_Min_Order_By>;
};

/** input type for inserting array relation for remote table "map_solution_motivation" */
export type SolutionMotivationElementMap_Arr_Rel_Insert_Input = {
  data: Array<SolutionMotivationElementMap_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<SolutionMotivationElementMap_On_Conflict>;
};

/** Boolean expression to filter rows from the table "map_solution_motivation". All fields are combined with a logical 'AND'. */
export type SolutionMotivationElementMap_Bool_Exp = {
  _and?: InputMaybe<Array<SolutionMotivationElementMap_Bool_Exp>>;
  _not?: InputMaybe<SolutionMotivationElementMap_Bool_Exp>;
  _or?: InputMaybe<Array<SolutionMotivationElementMap_Bool_Exp>>;
  componentsInSolution?: InputMaybe<SolutionMotivationComponentMap_Bool_Exp>;
  componentsInSolution_aggregate?: InputMaybe<SolutionMotivationComponentMap_Aggregate_Bool_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  motivation?: InputMaybe<MotivationElementGeneric_Bool_Exp>;
  motivationId?: InputMaybe<Uuid_Comparison_Exp>;
  solution?: InputMaybe<Solution_Bool_Exp>;
  solutionId?: InputMaybe<Uuid_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "map_solution_motivation" */
export enum SolutionMotivationElementMap_Constraint {
  /** unique or primary key constraint on columns "motivation_id", "solution_id" */
  MapSolutionMotivationMotivationIdSolutionIdUnique = 'map_solution_motivation_motivation_id_solution_id_unique',
  /** unique or primary key constraint on columns "motivation_id", "solution_id" */
  MapSolutionMotivationPkey = 'map_solution_motivation_pkey'
}

/** input type for inserting data into table "map_solution_motivation" */
export type SolutionMotivationElementMap_Insert_Input = {
  componentsInSolution?: InputMaybe<SolutionMotivationComponentMap_Arr_Rel_Insert_Input>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  motivation?: InputMaybe<MotivationElementGeneric_Obj_Rel_Insert_Input>;
  motivationId?: InputMaybe<Scalars['uuid']['input']>;
  solution?: InputMaybe<Solution_Obj_Rel_Insert_Input>;
  solutionId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type SolutionMotivationElementMap_Max_Fields = {
  __typename?: 'SolutionMotivationElementMap_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  motivationId?: Maybe<Scalars['uuid']['output']>;
  solutionId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "map_solution_motivation" */
export type SolutionMotivationElementMap_Max_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  motivationId?: InputMaybe<Order_By>;
  solutionId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type SolutionMotivationElementMap_Min_Fields = {
  __typename?: 'SolutionMotivationElementMap_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  motivationId?: Maybe<Scalars['uuid']['output']>;
  solutionId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "map_solution_motivation" */
export type SolutionMotivationElementMap_Min_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  motivationId?: InputMaybe<Order_By>;
  solutionId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "map_solution_motivation" */
export type SolutionMotivationElementMap_Mutation_Response = {
  __typename?: 'SolutionMotivationElementMap_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<SolutionMotivationElementMap>;
};

/** on_conflict condition type for table "map_solution_motivation" */
export type SolutionMotivationElementMap_On_Conflict = {
  constraint: SolutionMotivationElementMap_Constraint;
  update_columns?: Array<SolutionMotivationElementMap_Update_Column>;
  where?: InputMaybe<SolutionMotivationElementMap_Bool_Exp>;
};

/** Ordering options when selecting data from "map_solution_motivation". */
export type SolutionMotivationElementMap_Order_By = {
  componentsInSolution_aggregate?: InputMaybe<SolutionMotivationComponentMap_Aggregate_Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  motivation?: InputMaybe<MotivationElementGeneric_Order_By>;
  motivationId?: InputMaybe<Order_By>;
  solution?: InputMaybe<Solution_Order_By>;
  solutionId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: map_solution_motivation */
export type SolutionMotivationElementMap_Pk_Columns_Input = {
  motivationId: Scalars['uuid']['input'];
  solutionId: Scalars['uuid']['input'];
};

/** select columns of table "map_solution_motivation" */
export enum SolutionMotivationElementMap_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  MotivationId = 'motivationId',
  /** column name */
  SolutionId = 'solutionId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "map_solution_motivation" */
export type SolutionMotivationElementMap_Set_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  motivationId?: InputMaybe<Scalars['uuid']['input']>;
  solutionId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "SolutionMotivationElementMap" */
export type SolutionMotivationElementMap_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: SolutionMotivationElementMap_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type SolutionMotivationElementMap_Stream_Cursor_Value_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  motivationId?: InputMaybe<Scalars['uuid']['input']>;
  solutionId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "map_solution_motivation" */
export enum SolutionMotivationElementMap_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  MotivationId = 'motivationId',
  /** column name */
  SolutionId = 'solutionId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type SolutionMotivationElementMap_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<SolutionMotivationElementMap_Set_Input>;
  /** filter the rows which have to be updated */
  where: SolutionMotivationElementMap_Bool_Exp;
};

/** columns and relationships of "map_solution_stakeholder" */
export type SolutionStakeholderMap = {
  __typename?: 'SolutionStakeholderMap';
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  role: Scalars['stakeholder_role_enum']['output'];
  /** An object relationship */
  solution: Solution;
  solutionId: Scalars['uuid']['output'];
  /** An object relationship */
  stakeholder: Stakeholder;
  stakeholderId: Scalars['uuid']['output'];
  state: Scalars['solution_item_impact_type_enum']['output'];
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "map_solution_stakeholder" */
export type SolutionStakeholderMap_Aggregate = {
  __typename?: 'SolutionStakeholderMap_aggregate';
  aggregate?: Maybe<SolutionStakeholderMap_Aggregate_Fields>;
  nodes: Array<SolutionStakeholderMap>;
};

export type SolutionStakeholderMap_Aggregate_Bool_Exp = {
  count?: InputMaybe<SolutionStakeholderMap_Aggregate_Bool_Exp_Count>;
};

export type SolutionStakeholderMap_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<SolutionStakeholderMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<SolutionStakeholderMap_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "map_solution_stakeholder" */
export type SolutionStakeholderMap_Aggregate_Fields = {
  __typename?: 'SolutionStakeholderMap_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<SolutionStakeholderMap_Max_Fields>;
  min?: Maybe<SolutionStakeholderMap_Min_Fields>;
};


/** aggregate fields of "map_solution_stakeholder" */
export type SolutionStakeholderMap_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<SolutionStakeholderMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "map_solution_stakeholder" */
export type SolutionStakeholderMap_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<SolutionStakeholderMap_Max_Order_By>;
  min?: InputMaybe<SolutionStakeholderMap_Min_Order_By>;
};

/** input type for inserting array relation for remote table "map_solution_stakeholder" */
export type SolutionStakeholderMap_Arr_Rel_Insert_Input = {
  data: Array<SolutionStakeholderMap_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<SolutionStakeholderMap_On_Conflict>;
};

/** Boolean expression to filter rows from the table "map_solution_stakeholder". All fields are combined with a logical 'AND'. */
export type SolutionStakeholderMap_Bool_Exp = {
  _and?: InputMaybe<Array<SolutionStakeholderMap_Bool_Exp>>;
  _not?: InputMaybe<SolutionStakeholderMap_Bool_Exp>;
  _or?: InputMaybe<Array<SolutionStakeholderMap_Bool_Exp>>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  role?: InputMaybe<Stakeholder_Role_Enum_Comparison_Exp>;
  solution?: InputMaybe<Solution_Bool_Exp>;
  solutionId?: InputMaybe<Uuid_Comparison_Exp>;
  stakeholder?: InputMaybe<Stakeholder_Bool_Exp>;
  stakeholderId?: InputMaybe<Uuid_Comparison_Exp>;
  state?: InputMaybe<Solution_Item_Impact_Type_Enum_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "map_solution_stakeholder" */
export enum SolutionStakeholderMap_Constraint {
  /** unique or primary key constraint on columns "stakeholder_id", "solution_id" */
  MapSolutionStakeholderPkey = 'map_solution_stakeholder_pkey',
  /** unique or primary key constraint on columns "stakeholder_id", "solution_id" */
  MapSolutionStakeholderStakeholderIdSolutionIdUnique = 'map_solution_stakeholder_stakeholder_id_solution_id_unique'
}

/** input type for inserting data into table "map_solution_stakeholder" */
export type SolutionStakeholderMap_Insert_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<Scalars['stakeholder_role_enum']['input']>;
  solution?: InputMaybe<Solution_Obj_Rel_Insert_Input>;
  solutionId?: InputMaybe<Scalars['uuid']['input']>;
  stakeholder?: InputMaybe<Stakeholder_Obj_Rel_Insert_Input>;
  stakeholderId?: InputMaybe<Scalars['uuid']['input']>;
  state?: InputMaybe<Scalars['solution_item_impact_type_enum']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type SolutionStakeholderMap_Max_Fields = {
  __typename?: 'SolutionStakeholderMap_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  role?: Maybe<Scalars['stakeholder_role_enum']['output']>;
  solutionId?: Maybe<Scalars['uuid']['output']>;
  stakeholderId?: Maybe<Scalars['uuid']['output']>;
  state?: Maybe<Scalars['solution_item_impact_type_enum']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "map_solution_stakeholder" */
export type SolutionStakeholderMap_Max_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  role?: InputMaybe<Order_By>;
  solutionId?: InputMaybe<Order_By>;
  stakeholderId?: InputMaybe<Order_By>;
  state?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type SolutionStakeholderMap_Min_Fields = {
  __typename?: 'SolutionStakeholderMap_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  role?: Maybe<Scalars['stakeholder_role_enum']['output']>;
  solutionId?: Maybe<Scalars['uuid']['output']>;
  stakeholderId?: Maybe<Scalars['uuid']['output']>;
  state?: Maybe<Scalars['solution_item_impact_type_enum']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "map_solution_stakeholder" */
export type SolutionStakeholderMap_Min_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  role?: InputMaybe<Order_By>;
  solutionId?: InputMaybe<Order_By>;
  stakeholderId?: InputMaybe<Order_By>;
  state?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "map_solution_stakeholder" */
export type SolutionStakeholderMap_Mutation_Response = {
  __typename?: 'SolutionStakeholderMap_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<SolutionStakeholderMap>;
};

/** on_conflict condition type for table "map_solution_stakeholder" */
export type SolutionStakeholderMap_On_Conflict = {
  constraint: SolutionStakeholderMap_Constraint;
  update_columns?: Array<SolutionStakeholderMap_Update_Column>;
  where?: InputMaybe<SolutionStakeholderMap_Bool_Exp>;
};

/** Ordering options when selecting data from "map_solution_stakeholder". */
export type SolutionStakeholderMap_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  role?: InputMaybe<Order_By>;
  solution?: InputMaybe<Solution_Order_By>;
  solutionId?: InputMaybe<Order_By>;
  stakeholder?: InputMaybe<Stakeholder_Order_By>;
  stakeholderId?: InputMaybe<Order_By>;
  state?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: map_solution_stakeholder */
export type SolutionStakeholderMap_Pk_Columns_Input = {
  solutionId: Scalars['uuid']['input'];
  stakeholderId: Scalars['uuid']['input'];
};

/** select columns of table "map_solution_stakeholder" */
export enum SolutionStakeholderMap_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Role = 'role',
  /** column name */
  SolutionId = 'solutionId',
  /** column name */
  StakeholderId = 'stakeholderId',
  /** column name */
  State = 'state',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "map_solution_stakeholder" */
export type SolutionStakeholderMap_Set_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<Scalars['stakeholder_role_enum']['input']>;
  solutionId?: InputMaybe<Scalars['uuid']['input']>;
  stakeholderId?: InputMaybe<Scalars['uuid']['input']>;
  state?: InputMaybe<Scalars['solution_item_impact_type_enum']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "SolutionStakeholderMap" */
export type SolutionStakeholderMap_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: SolutionStakeholderMap_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type SolutionStakeholderMap_Stream_Cursor_Value_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  role?: InputMaybe<Scalars['stakeholder_role_enum']['input']>;
  solutionId?: InputMaybe<Scalars['uuid']['input']>;
  stakeholderId?: InputMaybe<Scalars['uuid']['input']>;
  state?: InputMaybe<Scalars['solution_item_impact_type_enum']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "map_solution_stakeholder" */
export enum SolutionStakeholderMap_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Role = 'role',
  /** column name */
  SolutionId = 'solutionId',
  /** column name */
  StakeholderId = 'stakeholderId',
  /** column name */
  State = 'state',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type SolutionStakeholderMap_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<SolutionStakeholderMap_Set_Input>;
  /** filter the rows which have to be updated */
  where: SolutionStakeholderMap_Bool_Exp;
};

/** columns and relationships of "map_solution_technology_node" */
export type SolutionTechnologyNodeMap = {
  __typename?: 'SolutionTechnologyNodeMap';
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  /** An object relationship */
  node: TechnologyNode;
  nodeId: Scalars['uuid']['output'];
  /** An object relationship */
  solution: Solution;
  solutionId: Scalars['uuid']['output'];
  state: Scalars['solution_item_impact_type_enum']['output'];
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "map_solution_technology_node" */
export type SolutionTechnologyNodeMap_Aggregate = {
  __typename?: 'SolutionTechnologyNodeMap_aggregate';
  aggregate?: Maybe<SolutionTechnologyNodeMap_Aggregate_Fields>;
  nodes: Array<SolutionTechnologyNodeMap>;
};

export type SolutionTechnologyNodeMap_Aggregate_Bool_Exp = {
  count?: InputMaybe<SolutionTechnologyNodeMap_Aggregate_Bool_Exp_Count>;
};

export type SolutionTechnologyNodeMap_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<SolutionTechnologyNodeMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<SolutionTechnologyNodeMap_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "map_solution_technology_node" */
export type SolutionTechnologyNodeMap_Aggregate_Fields = {
  __typename?: 'SolutionTechnologyNodeMap_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<SolutionTechnologyNodeMap_Max_Fields>;
  min?: Maybe<SolutionTechnologyNodeMap_Min_Fields>;
};


/** aggregate fields of "map_solution_technology_node" */
export type SolutionTechnologyNodeMap_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<SolutionTechnologyNodeMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "map_solution_technology_node" */
export type SolutionTechnologyNodeMap_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<SolutionTechnologyNodeMap_Max_Order_By>;
  min?: InputMaybe<SolutionTechnologyNodeMap_Min_Order_By>;
};

/** input type for inserting array relation for remote table "map_solution_technology_node" */
export type SolutionTechnologyNodeMap_Arr_Rel_Insert_Input = {
  data: Array<SolutionTechnologyNodeMap_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<SolutionTechnologyNodeMap_On_Conflict>;
};

/** Boolean expression to filter rows from the table "map_solution_technology_node". All fields are combined with a logical 'AND'. */
export type SolutionTechnologyNodeMap_Bool_Exp = {
  _and?: InputMaybe<Array<SolutionTechnologyNodeMap_Bool_Exp>>;
  _not?: InputMaybe<SolutionTechnologyNodeMap_Bool_Exp>;
  _or?: InputMaybe<Array<SolutionTechnologyNodeMap_Bool_Exp>>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  node?: InputMaybe<TechnologyNode_Bool_Exp>;
  nodeId?: InputMaybe<Uuid_Comparison_Exp>;
  solution?: InputMaybe<Solution_Bool_Exp>;
  solutionId?: InputMaybe<Uuid_Comparison_Exp>;
  state?: InputMaybe<Solution_Item_Impact_Type_Enum_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "map_solution_technology_node" */
export enum SolutionTechnologyNodeMap_Constraint {
  /** unique or primary key constraint on columns "node_id", "solution_id" */
  MapSolutionTechnologyNodeNodeIdSolutionIdUnique = 'map_solution_technology_node_node_id_solution_id_unique',
  /** unique or primary key constraint on columns "node_id", "solution_id" */
  MapSolutionTechnologyNodePkey = 'map_solution_technology_node_pkey'
}

/** input type for inserting data into table "map_solution_technology_node" */
export type SolutionTechnologyNodeMap_Insert_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  node?: InputMaybe<TechnologyNode_Obj_Rel_Insert_Input>;
  nodeId?: InputMaybe<Scalars['uuid']['input']>;
  solution?: InputMaybe<Solution_Obj_Rel_Insert_Input>;
  solutionId?: InputMaybe<Scalars['uuid']['input']>;
  state?: InputMaybe<Scalars['solution_item_impact_type_enum']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type SolutionTechnologyNodeMap_Max_Fields = {
  __typename?: 'SolutionTechnologyNodeMap_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  nodeId?: Maybe<Scalars['uuid']['output']>;
  solutionId?: Maybe<Scalars['uuid']['output']>;
  state?: Maybe<Scalars['solution_item_impact_type_enum']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "map_solution_technology_node" */
export type SolutionTechnologyNodeMap_Max_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  nodeId?: InputMaybe<Order_By>;
  solutionId?: InputMaybe<Order_By>;
  state?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type SolutionTechnologyNodeMap_Min_Fields = {
  __typename?: 'SolutionTechnologyNodeMap_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  nodeId?: Maybe<Scalars['uuid']['output']>;
  solutionId?: Maybe<Scalars['uuid']['output']>;
  state?: Maybe<Scalars['solution_item_impact_type_enum']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "map_solution_technology_node" */
export type SolutionTechnologyNodeMap_Min_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  nodeId?: InputMaybe<Order_By>;
  solutionId?: InputMaybe<Order_By>;
  state?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "map_solution_technology_node" */
export type SolutionTechnologyNodeMap_Mutation_Response = {
  __typename?: 'SolutionTechnologyNodeMap_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<SolutionTechnologyNodeMap>;
};

/** on_conflict condition type for table "map_solution_technology_node" */
export type SolutionTechnologyNodeMap_On_Conflict = {
  constraint: SolutionTechnologyNodeMap_Constraint;
  update_columns?: Array<SolutionTechnologyNodeMap_Update_Column>;
  where?: InputMaybe<SolutionTechnologyNodeMap_Bool_Exp>;
};

/** Ordering options when selecting data from "map_solution_technology_node". */
export type SolutionTechnologyNodeMap_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  node?: InputMaybe<TechnologyNode_Order_By>;
  nodeId?: InputMaybe<Order_By>;
  solution?: InputMaybe<Solution_Order_By>;
  solutionId?: InputMaybe<Order_By>;
  state?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: map_solution_technology_node */
export type SolutionTechnologyNodeMap_Pk_Columns_Input = {
  nodeId: Scalars['uuid']['input'];
  solutionId: Scalars['uuid']['input'];
};

/** select columns of table "map_solution_technology_node" */
export enum SolutionTechnologyNodeMap_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  NodeId = 'nodeId',
  /** column name */
  SolutionId = 'solutionId',
  /** column name */
  State = 'state',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "map_solution_technology_node" */
export type SolutionTechnologyNodeMap_Set_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  nodeId?: InputMaybe<Scalars['uuid']['input']>;
  solutionId?: InputMaybe<Scalars['uuid']['input']>;
  state?: InputMaybe<Scalars['solution_item_impact_type_enum']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "SolutionTechnologyNodeMap" */
export type SolutionTechnologyNodeMap_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: SolutionTechnologyNodeMap_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type SolutionTechnologyNodeMap_Stream_Cursor_Value_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  nodeId?: InputMaybe<Scalars['uuid']['input']>;
  solutionId?: InputMaybe<Scalars['uuid']['input']>;
  state?: InputMaybe<Scalars['solution_item_impact_type_enum']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "map_solution_technology_node" */
export enum SolutionTechnologyNodeMap_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  NodeId = 'nodeId',
  /** column name */
  SolutionId = 'solutionId',
  /** column name */
  State = 'state',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type SolutionTechnologyNodeMap_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<SolutionTechnologyNodeMap_Set_Input>;
  /** filter the rows which have to be updated */
  where: SolutionTechnologyNodeMap_Bool_Exp;
};

/** aggregated selection of "solutions" */
export type Solution_Aggregate = {
  __typename?: 'Solution_aggregate';
  aggregate?: Maybe<Solution_Aggregate_Fields>;
  nodes: Array<Solution>;
};

/** aggregate fields of "solutions" */
export type Solution_Aggregate_Fields = {
  __typename?: 'Solution_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Solution_Max_Fields>;
  min?: Maybe<Solution_Min_Fields>;
};


/** aggregate fields of "solutions" */
export type Solution_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Solution_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "solutions". All fields are combined with a logical 'AND'. */
export type Solution_Bool_Exp = {
  _and?: InputMaybe<Array<Solution_Bool_Exp>>;
  _not?: InputMaybe<Solution_Bool_Exp>;
  _or?: InputMaybe<Array<Solution_Bool_Exp>>;
  acceptedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  acceptedBy?: InputMaybe<Uuid_Comparison_Exp>;
  alternatives?: InputMaybe<String_Comparison_Exp>;
  code?: InputMaybe<String_Comparison_Exp>;
  components?: InputMaybe<SolutionApplicationComponentMap_Bool_Exp>;
  components_aggregate?: InputMaybe<SolutionApplicationComponentMap_Aggregate_Bool_Exp>;
  consequences?: InputMaybe<String_Comparison_Exp>;
  context?: InputMaybe<String_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  dataObjects?: InputMaybe<SolutionDataObjectMap_Bool_Exp>;
  dataObjects_aggregate?: InputMaybe<SolutionDataObjectMap_Aggregate_Bool_Exp>;
  decision?: InputMaybe<String_Comparison_Exp>;
  decisionStatus?: InputMaybe<Solution_Life_Cycle_Enum_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  flows?: InputMaybe<SolutionFlowMap_Bool_Exp>;
  flows_aggregate?: InputMaybe<SolutionFlowMap_Aggregate_Bool_Exp>;
  functions?: InputMaybe<SolutionApplicationFunctionMap_Bool_Exp>;
  functions_aggregate?: InputMaybe<SolutionApplicationFunctionMap_Aggregate_Bool_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  implementationStatus?: InputMaybe<Solution_Implementation_Status_Enum_Comparison_Exp>;
  motivations?: InputMaybe<SolutionMotivationElementMap_Bool_Exp>;
  motivations_aggregate?: InputMaybe<SolutionMotivationElementMap_Aggregate_Bool_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  solutionMapSolutionTechnologyNode?: InputMaybe<SolutionTechnologyNodeMap_Bool_Exp>;
  solutionMapSolutionTechnologyNode_aggregate?: InputMaybe<SolutionTechnologyNodeMap_Aggregate_Bool_Exp>;
  stakeholders?: InputMaybe<SolutionStakeholderMap_Bool_Exp>;
  stakeholders_aggregate?: InputMaybe<SolutionStakeholderMap_Aggregate_Bool_Exp>;
  stateId?: InputMaybe<Uuid_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "solutions" */
export enum Solution_Constraint {
  /** unique or primary key constraint on columns "code" */
  SolutionsCodeUnique = 'solutions_code_unique',
  /** unique or primary key constraint on columns "id" */
  SolutionsPkey = 'solutions_pkey'
}

/** input type for inserting data into table "solutions" */
export type Solution_Insert_Input = {
  acceptedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  acceptedBy?: InputMaybe<Scalars['uuid']['input']>;
  alternatives?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  components?: InputMaybe<SolutionApplicationComponentMap_Arr_Rel_Insert_Input>;
  consequences?: InputMaybe<Scalars['String']['input']>;
  context?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  dataObjects?: InputMaybe<SolutionDataObjectMap_Arr_Rel_Insert_Input>;
  decision?: InputMaybe<Scalars['String']['input']>;
  decisionStatus?: InputMaybe<Scalars['solution_life_cycle_enum']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  flows?: InputMaybe<SolutionFlowMap_Arr_Rel_Insert_Input>;
  functions?: InputMaybe<SolutionApplicationFunctionMap_Arr_Rel_Insert_Input>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  implementationStatus?: InputMaybe<Scalars['solution_implementation_status_enum']['input']>;
  motivations?: InputMaybe<SolutionMotivationElementMap_Arr_Rel_Insert_Input>;
  name?: InputMaybe<Scalars['String']['input']>;
  solutionMapSolutionTechnologyNode?: InputMaybe<SolutionTechnologyNodeMap_Arr_Rel_Insert_Input>;
  stakeholders?: InputMaybe<SolutionStakeholderMap_Arr_Rel_Insert_Input>;
  stateId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Solution_Max_Fields = {
  __typename?: 'Solution_max_fields';
  acceptedAt?: Maybe<Scalars['timestamptz']['output']>;
  acceptedBy?: Maybe<Scalars['uuid']['output']>;
  alternatives?: Maybe<Scalars['String']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  consequences?: Maybe<Scalars['String']['output']>;
  context?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  decision?: Maybe<Scalars['String']['output']>;
  decisionStatus?: Maybe<Scalars['solution_life_cycle_enum']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  implementationStatus?: Maybe<Scalars['solution_implementation_status_enum']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  stateId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type Solution_Min_Fields = {
  __typename?: 'Solution_min_fields';
  acceptedAt?: Maybe<Scalars['timestamptz']['output']>;
  acceptedBy?: Maybe<Scalars['uuid']['output']>;
  alternatives?: Maybe<Scalars['String']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  consequences?: Maybe<Scalars['String']['output']>;
  context?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  decision?: Maybe<Scalars['String']['output']>;
  decisionStatus?: Maybe<Scalars['solution_life_cycle_enum']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  implementationStatus?: Maybe<Scalars['solution_implementation_status_enum']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  stateId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "solutions" */
export type Solution_Mutation_Response = {
  __typename?: 'Solution_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Solution>;
};

/** input type for inserting object relation for remote table "solutions" */
export type Solution_Obj_Rel_Insert_Input = {
  data: Solution_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Solution_On_Conflict>;
};

/** on_conflict condition type for table "solutions" */
export type Solution_On_Conflict = {
  constraint: Solution_Constraint;
  update_columns?: Array<Solution_Update_Column>;
  where?: InputMaybe<Solution_Bool_Exp>;
};

/** Ordering options when selecting data from "solutions". */
export type Solution_Order_By = {
  acceptedAt?: InputMaybe<Order_By>;
  acceptedBy?: InputMaybe<Order_By>;
  alternatives?: InputMaybe<Order_By>;
  code?: InputMaybe<Order_By>;
  components_aggregate?: InputMaybe<SolutionApplicationComponentMap_Aggregate_Order_By>;
  consequences?: InputMaybe<Order_By>;
  context?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  dataObjects_aggregate?: InputMaybe<SolutionDataObjectMap_Aggregate_Order_By>;
  decision?: InputMaybe<Order_By>;
  decisionStatus?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  flows_aggregate?: InputMaybe<SolutionFlowMap_Aggregate_Order_By>;
  functions_aggregate?: InputMaybe<SolutionApplicationFunctionMap_Aggregate_Order_By>;
  id?: InputMaybe<Order_By>;
  implementationStatus?: InputMaybe<Order_By>;
  motivations_aggregate?: InputMaybe<SolutionMotivationElementMap_Aggregate_Order_By>;
  name?: InputMaybe<Order_By>;
  solutionMapSolutionTechnologyNode_aggregate?: InputMaybe<SolutionTechnologyNodeMap_Aggregate_Order_By>;
  stakeholders_aggregate?: InputMaybe<SolutionStakeholderMap_Aggregate_Order_By>;
  stateId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: solutions */
export type Solution_Pk_Columns_Input = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "solutions" */
export enum Solution_Select_Column {
  /** column name */
  AcceptedAt = 'acceptedAt',
  /** column name */
  AcceptedBy = 'acceptedBy',
  /** column name */
  Alternatives = 'alternatives',
  /** column name */
  Code = 'code',
  /** column name */
  Consequences = 'consequences',
  /** column name */
  Context = 'context',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  Decision = 'decision',
  /** column name */
  DecisionStatus = 'decisionStatus',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  ImplementationStatus = 'implementationStatus',
  /** column name */
  Name = 'name',
  /** column name */
  StateId = 'stateId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "solutions" */
export type Solution_Set_Input = {
  acceptedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  acceptedBy?: InputMaybe<Scalars['uuid']['input']>;
  alternatives?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  consequences?: InputMaybe<Scalars['String']['input']>;
  context?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  decision?: InputMaybe<Scalars['String']['input']>;
  decisionStatus?: InputMaybe<Scalars['solution_life_cycle_enum']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  implementationStatus?: InputMaybe<Scalars['solution_implementation_status_enum']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  stateId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "Solution" */
export type Solution_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Solution_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Solution_Stream_Cursor_Value_Input = {
  acceptedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  acceptedBy?: InputMaybe<Scalars['uuid']['input']>;
  alternatives?: InputMaybe<Scalars['String']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  consequences?: InputMaybe<Scalars['String']['input']>;
  context?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  decision?: InputMaybe<Scalars['String']['input']>;
  decisionStatus?: InputMaybe<Scalars['solution_life_cycle_enum']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  implementationStatus?: InputMaybe<Scalars['solution_implementation_status_enum']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  stateId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "solutions" */
export enum Solution_Update_Column {
  /** column name */
  AcceptedAt = 'acceptedAt',
  /** column name */
  AcceptedBy = 'acceptedBy',
  /** column name */
  Alternatives = 'alternatives',
  /** column name */
  Code = 'code',
  /** column name */
  Consequences = 'consequences',
  /** column name */
  Context = 'context',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  Decision = 'decision',
  /** column name */
  DecisionStatus = 'decisionStatus',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  ImplementationStatus = 'implementationStatus',
  /** column name */
  Name = 'name',
  /** column name */
  StateId = 'stateId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type Solution_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Solution_Set_Input>;
  /** filter the rows which have to be updated */
  where: Solution_Bool_Exp;
};

/** columns and relationships of "stakeholders" */
export type Stakeholder = {
  __typename?: 'Stakeholder';
  code: Scalars['String']['output'];
  /** An array relationship */
  components: Array<ApplicationComponentStakeholderMap>;
  /** An aggregate relationship */
  components_aggregate: ApplicationComponentStakeholderMap_Aggregate;
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['uuid']['output'];
  name: Scalars['String']['output'];
  ownerId?: Maybe<Scalars['uuid']['output']>;
  /** An array relationship */
  solutions: Array<SolutionStakeholderMap>;
  /** An aggregate relationship */
  solutions_aggregate: SolutionStakeholderMap_Aggregate;
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};


/** columns and relationships of "stakeholders" */
export type StakeholderComponentsArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentStakeholderMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentStakeholderMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentStakeholderMap_Bool_Exp>;
};


/** columns and relationships of "stakeholders" */
export type StakeholderComponents_AggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentStakeholderMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentStakeholderMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentStakeholderMap_Bool_Exp>;
};


/** columns and relationships of "stakeholders" */
export type StakeholderSolutionsArgs = {
  distinct_on?: InputMaybe<Array<SolutionStakeholderMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionStakeholderMap_Order_By>>;
  where?: InputMaybe<SolutionStakeholderMap_Bool_Exp>;
};


/** columns and relationships of "stakeholders" */
export type StakeholderSolutions_AggregateArgs = {
  distinct_on?: InputMaybe<Array<SolutionStakeholderMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionStakeholderMap_Order_By>>;
  where?: InputMaybe<SolutionStakeholderMap_Bool_Exp>;
};

/** aggregated selection of "stakeholders" */
export type Stakeholder_Aggregate = {
  __typename?: 'Stakeholder_aggregate';
  aggregate?: Maybe<Stakeholder_Aggregate_Fields>;
  nodes: Array<Stakeholder>;
};

/** aggregate fields of "stakeholders" */
export type Stakeholder_Aggregate_Fields = {
  __typename?: 'Stakeholder_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Stakeholder_Max_Fields>;
  min?: Maybe<Stakeholder_Min_Fields>;
};


/** aggregate fields of "stakeholders" */
export type Stakeholder_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Stakeholder_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "stakeholders". All fields are combined with a logical 'AND'. */
export type Stakeholder_Bool_Exp = {
  _and?: InputMaybe<Array<Stakeholder_Bool_Exp>>;
  _not?: InputMaybe<Stakeholder_Bool_Exp>;
  _or?: InputMaybe<Array<Stakeholder_Bool_Exp>>;
  code?: InputMaybe<String_Comparison_Exp>;
  components?: InputMaybe<ApplicationComponentStakeholderMap_Bool_Exp>;
  components_aggregate?: InputMaybe<ApplicationComponentStakeholderMap_Aggregate_Bool_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  ownerId?: InputMaybe<Uuid_Comparison_Exp>;
  solutions?: InputMaybe<SolutionStakeholderMap_Bool_Exp>;
  solutions_aggregate?: InputMaybe<SolutionStakeholderMap_Aggregate_Bool_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "stakeholders" */
export enum Stakeholder_Constraint {
  /** unique or primary key constraint on columns "code" */
  StakeholdersCodeUnique = 'stakeholders_code_unique',
  /** unique or primary key constraint on columns "id" */
  StakeholdersPkey = 'stakeholders_pkey'
}

/** input type for inserting data into table "stakeholders" */
export type Stakeholder_Insert_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  components?: InputMaybe<ApplicationComponentStakeholderMap_Arr_Rel_Insert_Input>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['uuid']['input']>;
  solutions?: InputMaybe<SolutionStakeholderMap_Arr_Rel_Insert_Input>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Stakeholder_Max_Fields = {
  __typename?: 'Stakeholder_max_fields';
  code?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  ownerId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type Stakeholder_Min_Fields = {
  __typename?: 'Stakeholder_min_fields';
  code?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  ownerId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "stakeholders" */
export type Stakeholder_Mutation_Response = {
  __typename?: 'Stakeholder_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Stakeholder>;
};

/** input type for inserting object relation for remote table "stakeholders" */
export type Stakeholder_Obj_Rel_Insert_Input = {
  data: Stakeholder_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Stakeholder_On_Conflict>;
};

/** on_conflict condition type for table "stakeholders" */
export type Stakeholder_On_Conflict = {
  constraint: Stakeholder_Constraint;
  update_columns?: Array<Stakeholder_Update_Column>;
  where?: InputMaybe<Stakeholder_Bool_Exp>;
};

/** Ordering options when selecting data from "stakeholders". */
export type Stakeholder_Order_By = {
  code?: InputMaybe<Order_By>;
  components_aggregate?: InputMaybe<ApplicationComponentStakeholderMap_Aggregate_Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  ownerId?: InputMaybe<Order_By>;
  solutions_aggregate?: InputMaybe<SolutionStakeholderMap_Aggregate_Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: stakeholders */
export type Stakeholder_Pk_Columns_Input = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "stakeholders" */
export enum Stakeholder_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  OwnerId = 'ownerId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "stakeholders" */
export type Stakeholder_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "Stakeholder" */
export type Stakeholder_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Stakeholder_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Stakeholder_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "stakeholders" */
export enum Stakeholder_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  OwnerId = 'ownerId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type Stakeholder_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Stakeholder_Set_Input>;
  /** filter the rows which have to be updated */
  where: Stakeholder_Bool_Exp;
};

/** Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'. */
export type String_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['String']['input']>;
  _gt?: InputMaybe<Scalars['String']['input']>;
  _gte?: InputMaybe<Scalars['String']['input']>;
  /** does the column match the given case-insensitive pattern */
  _ilike?: InputMaybe<Scalars['String']['input']>;
  _in?: InputMaybe<Array<Scalars['String']['input']>>;
  /** does the column match the given POSIX regular expression, case insensitive */
  _iregex?: InputMaybe<Scalars['String']['input']>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  /** does the column match the given pattern */
  _like?: InputMaybe<Scalars['String']['input']>;
  _lt?: InputMaybe<Scalars['String']['input']>;
  _lte?: InputMaybe<Scalars['String']['input']>;
  _neq?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given case-insensitive pattern */
  _nilike?: InputMaybe<Scalars['String']['input']>;
  _nin?: InputMaybe<Array<Scalars['String']['input']>>;
  /** does the column NOT match the given POSIX regular expression, case insensitive */
  _niregex?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given pattern */
  _nlike?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given POSIX regular expression, case sensitive */
  _nregex?: InputMaybe<Scalars['String']['input']>;
  /** does the column NOT match the given SQL regular expression */
  _nsimilar?: InputMaybe<Scalars['String']['input']>;
  /** does the column match the given POSIX regular expression, case sensitive */
  _regex?: InputMaybe<Scalars['String']['input']>;
  /** does the column match the given SQL regular expression */
  _similar?: InputMaybe<Scalars['String']['input']>;
};

/** columns and relationships of "system_software" */
export type SystemSoftware = {
  __typename?: 'SystemSoftware';
  code: Scalars['String']['output'];
  /** An array relationship */
  components: Array<ApplicationComponentSystemSoftwareMap>;
  /** An aggregate relationship */
  components_aggregate: ApplicationComponentSystemSoftwareMap_Aggregate;
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['uuid']['output'];
  kind: Scalars['system_software_kind_enum']['output'];
  /** An object relationship */
  licenseType?: Maybe<DirectoryObject>;
  licenseTypeId?: Maybe<Scalars['uuid']['output']>;
  name: Scalars['String']['output'];
  /** An array relationship */
  nodes: Array<TechnologyNodeSystemSoftwareMap>;
  /** An aggregate relationship */
  nodes_aggregate: TechnologyNodeSystemSoftwareMap_Aggregate;
  /** An array relationship */
  operatingSystem: Array<TechnologyNode>;
  /** An aggregate relationship */
  operatingSystem_aggregate: TechnologyNode_Aggregate;
  ownerId?: Maybe<Scalars['uuid']['output']>;
  tenantId: Scalars['uuid']['output'];
  /** An object relationship */
  type?: Maybe<DirectoryObject>;
  typeId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
  version?: Maybe<Scalars['String']['output']>;
};


/** columns and relationships of "system_software" */
export type SystemSoftwareComponentsArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentSystemSoftwareMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentSystemSoftwareMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentSystemSoftwareMap_Bool_Exp>;
};


/** columns and relationships of "system_software" */
export type SystemSoftwareComponents_AggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentSystemSoftwareMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentSystemSoftwareMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentSystemSoftwareMap_Bool_Exp>;
};


/** columns and relationships of "system_software" */
export type SystemSoftwareNodesArgs = {
  distinct_on?: InputMaybe<Array<TechnologyNodeSystemSoftwareMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TechnologyNodeSystemSoftwareMap_Order_By>>;
  where?: InputMaybe<TechnologyNodeSystemSoftwareMap_Bool_Exp>;
};


/** columns and relationships of "system_software" */
export type SystemSoftwareNodes_AggregateArgs = {
  distinct_on?: InputMaybe<Array<TechnologyNodeSystemSoftwareMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TechnologyNodeSystemSoftwareMap_Order_By>>;
  where?: InputMaybe<TechnologyNodeSystemSoftwareMap_Bool_Exp>;
};


/** columns and relationships of "system_software" */
export type SystemSoftwareOperatingSystemArgs = {
  distinct_on?: InputMaybe<Array<TechnologyNode_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TechnologyNode_Order_By>>;
  where?: InputMaybe<TechnologyNode_Bool_Exp>;
};


/** columns and relationships of "system_software" */
export type SystemSoftwareOperatingSystem_AggregateArgs = {
  distinct_on?: InputMaybe<Array<TechnologyNode_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TechnologyNode_Order_By>>;
  where?: InputMaybe<TechnologyNode_Bool_Exp>;
};

/** aggregated selection of "system_software" */
export type SystemSoftware_Aggregate = {
  __typename?: 'SystemSoftware_aggregate';
  aggregate?: Maybe<SystemSoftware_Aggregate_Fields>;
  nodes: Array<SystemSoftware>;
};

export type SystemSoftware_Aggregate_Bool_Exp = {
  count?: InputMaybe<SystemSoftware_Aggregate_Bool_Exp_Count>;
};

export type SystemSoftware_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<SystemSoftware_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<SystemSoftware_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "system_software" */
export type SystemSoftware_Aggregate_Fields = {
  __typename?: 'SystemSoftware_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<SystemSoftware_Max_Fields>;
  min?: Maybe<SystemSoftware_Min_Fields>;
};


/** aggregate fields of "system_software" */
export type SystemSoftware_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<SystemSoftware_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "system_software" */
export type SystemSoftware_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<SystemSoftware_Max_Order_By>;
  min?: InputMaybe<SystemSoftware_Min_Order_By>;
};

/** input type for inserting array relation for remote table "system_software" */
export type SystemSoftware_Arr_Rel_Insert_Input = {
  data: Array<SystemSoftware_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<SystemSoftware_On_Conflict>;
};

/** Boolean expression to filter rows from the table "system_software". All fields are combined with a logical 'AND'. */
export type SystemSoftware_Bool_Exp = {
  _and?: InputMaybe<Array<SystemSoftware_Bool_Exp>>;
  _not?: InputMaybe<SystemSoftware_Bool_Exp>;
  _or?: InputMaybe<Array<SystemSoftware_Bool_Exp>>;
  code?: InputMaybe<String_Comparison_Exp>;
  components?: InputMaybe<ApplicationComponentSystemSoftwareMap_Bool_Exp>;
  components_aggregate?: InputMaybe<ApplicationComponentSystemSoftwareMap_Aggregate_Bool_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  kind?: InputMaybe<System_Software_Kind_Enum_Comparison_Exp>;
  licenseType?: InputMaybe<DirectoryObject_Bool_Exp>;
  licenseTypeId?: InputMaybe<Uuid_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  nodes?: InputMaybe<TechnologyNodeSystemSoftwareMap_Bool_Exp>;
  nodes_aggregate?: InputMaybe<TechnologyNodeSystemSoftwareMap_Aggregate_Bool_Exp>;
  operatingSystem?: InputMaybe<TechnologyNode_Bool_Exp>;
  operatingSystem_aggregate?: InputMaybe<TechnologyNode_Aggregate_Bool_Exp>;
  ownerId?: InputMaybe<Uuid_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  type?: InputMaybe<DirectoryObject_Bool_Exp>;
  typeId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
  version?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "system_software" */
export enum SystemSoftware_Constraint {
  /** unique or primary key constraint on columns "code" */
  SystemSoftwareCodeUnique = 'system_software_code_unique',
  /** unique or primary key constraint on columns "id" */
  SystemSoftwarePkey = 'system_software_pkey'
}

/** input type for inserting data into table "system_software" */
export type SystemSoftware_Insert_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  components?: InputMaybe<ApplicationComponentSystemSoftwareMap_Arr_Rel_Insert_Input>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  kind?: InputMaybe<Scalars['system_software_kind_enum']['input']>;
  licenseType?: InputMaybe<DirectoryObject_Obj_Rel_Insert_Input>;
  licenseTypeId?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nodes?: InputMaybe<TechnologyNodeSystemSoftwareMap_Arr_Rel_Insert_Input>;
  operatingSystem?: InputMaybe<TechnologyNode_Arr_Rel_Insert_Input>;
  ownerId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  type?: InputMaybe<DirectoryObject_Obj_Rel_Insert_Input>;
  typeId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
  version?: InputMaybe<Scalars['String']['input']>;
};

/** aggregate max on columns */
export type SystemSoftware_Max_Fields = {
  __typename?: 'SystemSoftware_max_fields';
  code?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  kind?: Maybe<Scalars['system_software_kind_enum']['output']>;
  licenseTypeId?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  ownerId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  typeId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
  version?: Maybe<Scalars['String']['output']>;
};

/** order by max() on columns of table "system_software" */
export type SystemSoftware_Max_Order_By = {
  code?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  kind?: InputMaybe<Order_By>;
  licenseTypeId?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  ownerId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  typeId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
  version?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type SystemSoftware_Min_Fields = {
  __typename?: 'SystemSoftware_min_fields';
  code?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  kind?: Maybe<Scalars['system_software_kind_enum']['output']>;
  licenseTypeId?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  ownerId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  typeId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
  version?: Maybe<Scalars['String']['output']>;
};

/** order by min() on columns of table "system_software" */
export type SystemSoftware_Min_Order_By = {
  code?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  kind?: InputMaybe<Order_By>;
  licenseTypeId?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  ownerId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  typeId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
  version?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "system_software" */
export type SystemSoftware_Mutation_Response = {
  __typename?: 'SystemSoftware_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<SystemSoftware>;
};

/** input type for inserting object relation for remote table "system_software" */
export type SystemSoftware_Obj_Rel_Insert_Input = {
  data: SystemSoftware_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<SystemSoftware_On_Conflict>;
};

/** on_conflict condition type for table "system_software" */
export type SystemSoftware_On_Conflict = {
  constraint: SystemSoftware_Constraint;
  update_columns?: Array<SystemSoftware_Update_Column>;
  where?: InputMaybe<SystemSoftware_Bool_Exp>;
};

/** Ordering options when selecting data from "system_software". */
export type SystemSoftware_Order_By = {
  code?: InputMaybe<Order_By>;
  components_aggregate?: InputMaybe<ApplicationComponentSystemSoftwareMap_Aggregate_Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  kind?: InputMaybe<Order_By>;
  licenseType?: InputMaybe<DirectoryObject_Order_By>;
  licenseTypeId?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  nodes_aggregate?: InputMaybe<TechnologyNodeSystemSoftwareMap_Aggregate_Order_By>;
  operatingSystem_aggregate?: InputMaybe<TechnologyNode_Aggregate_Order_By>;
  ownerId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  type?: InputMaybe<DirectoryObject_Order_By>;
  typeId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
  version?: InputMaybe<Order_By>;
};

/** primary key columns input for table: system_software */
export type SystemSoftware_Pk_Columns_Input = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "system_software" */
export enum SystemSoftware_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Kind = 'kind',
  /** column name */
  LicenseTypeId = 'licenseTypeId',
  /** column name */
  Name = 'name',
  /** column name */
  OwnerId = 'ownerId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  TypeId = 'typeId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy',
  /** column name */
  Version = 'version'
}

/** input type for updating data in table "system_software" */
export type SystemSoftware_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  kind?: InputMaybe<Scalars['system_software_kind_enum']['input']>;
  licenseTypeId?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  typeId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
  version?: InputMaybe<Scalars['String']['input']>;
};

/** Streaming cursor of the table "SystemSoftware" */
export type SystemSoftware_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: SystemSoftware_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type SystemSoftware_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  kind?: InputMaybe<Scalars['system_software_kind_enum']['input']>;
  licenseTypeId?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  typeId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
  version?: InputMaybe<Scalars['String']['input']>;
};

/** update columns of table "system_software" */
export enum SystemSoftware_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Kind = 'kind',
  /** column name */
  LicenseTypeId = 'licenseTypeId',
  /** column name */
  Name = 'name',
  /** column name */
  OwnerId = 'ownerId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  TypeId = 'typeId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy',
  /** column name */
  Version = 'version'
}

export type SystemSoftware_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<SystemSoftware_Set_Input>;
  /** filter the rows which have to be updated */
  where: SystemSoftware_Bool_Exp;
};

/** columns and relationships of "technology_networks" */
export type TechnologyNetwork = {
  __typename?: 'TechnologyNetwork';
  /** An array relationship */
  child: Array<TechnologyNetworkHierarchyMap>;
  /** An aggregate relationship */
  child_aggregate: TechnologyNetworkHierarchyMap_Aggregate;
  code: Scalars['String']['output'];
  /** An array relationship */
  components: Array<ApplicationComponentTechnologyLogicalNetworkMap>;
  /** An aggregate relationship */
  components_aggregate: ApplicationComponentTechnologyLogicalNetworkMap_Aggregate;
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  environment?: Maybe<Scalars['environment_enum']['output']>;
  id: Scalars['uuid']['output'];
  level: Scalars['network_abstraction_level_enum']['output'];
  /** An object relationship */
  location?: Maybe<PhysicalLocation>;
  locationId?: Maybe<Scalars['uuid']['output']>;
  name: Scalars['String']['output'];
  /** An array relationship */
  nodes: Array<TechnologyNode>;
  /** An aggregate relationship */
  nodes_aggregate: TechnologyNode_Aggregate;
  /** An array relationship */
  parent: Array<TechnologyNetworkHierarchyMap>;
  /** An aggregate relationship */
  parent_aggregate: TechnologyNetworkHierarchyMap_Aggregate;
  scope?: Maybe<Scalars['network_scope_enum']['output']>;
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};


/** columns and relationships of "technology_networks" */
export type TechnologyNetworkChildArgs = {
  distinct_on?: InputMaybe<Array<TechnologyNetworkHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TechnologyNetworkHierarchyMap_Order_By>>;
  where?: InputMaybe<TechnologyNetworkHierarchyMap_Bool_Exp>;
};


/** columns and relationships of "technology_networks" */
export type TechnologyNetworkChild_AggregateArgs = {
  distinct_on?: InputMaybe<Array<TechnologyNetworkHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TechnologyNetworkHierarchyMap_Order_By>>;
  where?: InputMaybe<TechnologyNetworkHierarchyMap_Bool_Exp>;
};


/** columns and relationships of "technology_networks" */
export type TechnologyNetworkComponentsArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentTechnologyLogicalNetworkMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentTechnologyLogicalNetworkMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentTechnologyLogicalNetworkMap_Bool_Exp>;
};


/** columns and relationships of "technology_networks" */
export type TechnologyNetworkComponents_AggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentTechnologyLogicalNetworkMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentTechnologyLogicalNetworkMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentTechnologyLogicalNetworkMap_Bool_Exp>;
};


/** columns and relationships of "technology_networks" */
export type TechnologyNetworkNodesArgs = {
  distinct_on?: InputMaybe<Array<TechnologyNode_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TechnologyNode_Order_By>>;
  where?: InputMaybe<TechnologyNode_Bool_Exp>;
};


/** columns and relationships of "technology_networks" */
export type TechnologyNetworkNodes_AggregateArgs = {
  distinct_on?: InputMaybe<Array<TechnologyNode_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TechnologyNode_Order_By>>;
  where?: InputMaybe<TechnologyNode_Bool_Exp>;
};


/** columns and relationships of "technology_networks" */
export type TechnologyNetworkParentArgs = {
  distinct_on?: InputMaybe<Array<TechnologyNetworkHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TechnologyNetworkHierarchyMap_Order_By>>;
  where?: InputMaybe<TechnologyNetworkHierarchyMap_Bool_Exp>;
};


/** columns and relationships of "technology_networks" */
export type TechnologyNetworkParent_AggregateArgs = {
  distinct_on?: InputMaybe<Array<TechnologyNetworkHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TechnologyNetworkHierarchyMap_Order_By>>;
  where?: InputMaybe<TechnologyNetworkHierarchyMap_Bool_Exp>;
};

/** columns and relationships of "map_technology_network_hierarchy" */
export type TechnologyNetworkHierarchyMap = {
  __typename?: 'TechnologyNetworkHierarchyMap';
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  networkChild: TechnologyNetwork;
  networkChildId: Scalars['uuid']['output'];
  /** An object relationship */
  networkParent: TechnologyNetwork;
  networkParentId: Scalars['uuid']['output'];
  order?: Maybe<Scalars['Int']['output']>;
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "map_technology_network_hierarchy" */
export type TechnologyNetworkHierarchyMap_Aggregate = {
  __typename?: 'TechnologyNetworkHierarchyMap_aggregate';
  aggregate?: Maybe<TechnologyNetworkHierarchyMap_Aggregate_Fields>;
  nodes: Array<TechnologyNetworkHierarchyMap>;
};

export type TechnologyNetworkHierarchyMap_Aggregate_Bool_Exp = {
  count?: InputMaybe<TechnologyNetworkHierarchyMap_Aggregate_Bool_Exp_Count>;
};

export type TechnologyNetworkHierarchyMap_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<TechnologyNetworkHierarchyMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<TechnologyNetworkHierarchyMap_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "map_technology_network_hierarchy" */
export type TechnologyNetworkHierarchyMap_Aggregate_Fields = {
  __typename?: 'TechnologyNetworkHierarchyMap_aggregate_fields';
  avg?: Maybe<TechnologyNetworkHierarchyMap_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<TechnologyNetworkHierarchyMap_Max_Fields>;
  min?: Maybe<TechnologyNetworkHierarchyMap_Min_Fields>;
  stddev?: Maybe<TechnologyNetworkHierarchyMap_Stddev_Fields>;
  stddev_pop?: Maybe<TechnologyNetworkHierarchyMap_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<TechnologyNetworkHierarchyMap_Stddev_Samp_Fields>;
  sum?: Maybe<TechnologyNetworkHierarchyMap_Sum_Fields>;
  var_pop?: Maybe<TechnologyNetworkHierarchyMap_Var_Pop_Fields>;
  var_samp?: Maybe<TechnologyNetworkHierarchyMap_Var_Samp_Fields>;
  variance?: Maybe<TechnologyNetworkHierarchyMap_Variance_Fields>;
};


/** aggregate fields of "map_technology_network_hierarchy" */
export type TechnologyNetworkHierarchyMap_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<TechnologyNetworkHierarchyMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "map_technology_network_hierarchy" */
export type TechnologyNetworkHierarchyMap_Aggregate_Order_By = {
  avg?: InputMaybe<TechnologyNetworkHierarchyMap_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<TechnologyNetworkHierarchyMap_Max_Order_By>;
  min?: InputMaybe<TechnologyNetworkHierarchyMap_Min_Order_By>;
  stddev?: InputMaybe<TechnologyNetworkHierarchyMap_Stddev_Order_By>;
  stddev_pop?: InputMaybe<TechnologyNetworkHierarchyMap_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<TechnologyNetworkHierarchyMap_Stddev_Samp_Order_By>;
  sum?: InputMaybe<TechnologyNetworkHierarchyMap_Sum_Order_By>;
  var_pop?: InputMaybe<TechnologyNetworkHierarchyMap_Var_Pop_Order_By>;
  var_samp?: InputMaybe<TechnologyNetworkHierarchyMap_Var_Samp_Order_By>;
  variance?: InputMaybe<TechnologyNetworkHierarchyMap_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "map_technology_network_hierarchy" */
export type TechnologyNetworkHierarchyMap_Arr_Rel_Insert_Input = {
  data: Array<TechnologyNetworkHierarchyMap_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<TechnologyNetworkHierarchyMap_On_Conflict>;
};

/** aggregate avg on columns */
export type TechnologyNetworkHierarchyMap_Avg_Fields = {
  __typename?: 'TechnologyNetworkHierarchyMap_avg_fields';
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "map_technology_network_hierarchy" */
export type TechnologyNetworkHierarchyMap_Avg_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "map_technology_network_hierarchy". All fields are combined with a logical 'AND'. */
export type TechnologyNetworkHierarchyMap_Bool_Exp = {
  _and?: InputMaybe<Array<TechnologyNetworkHierarchyMap_Bool_Exp>>;
  _not?: InputMaybe<TechnologyNetworkHierarchyMap_Bool_Exp>;
  _or?: InputMaybe<Array<TechnologyNetworkHierarchyMap_Bool_Exp>>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  networkChild?: InputMaybe<TechnologyNetwork_Bool_Exp>;
  networkChildId?: InputMaybe<Uuid_Comparison_Exp>;
  networkParent?: InputMaybe<TechnologyNetwork_Bool_Exp>;
  networkParentId?: InputMaybe<Uuid_Comparison_Exp>;
  order?: InputMaybe<Int_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "map_technology_network_hierarchy" */
export enum TechnologyNetworkHierarchyMap_Constraint {
  /** unique or primary key constraint on columns "network_child_id", "network_parent_id" */
  MapTechnologyNetworkHierarchyNetworkParentI_7f01cUnique = 'map_technology_network_hierarchy_network_parent_i_7f01c_unique',
  /** unique or primary key constraint on columns "network_child_id", "network_parent_id" */
  MapTechnologyNetworkHierarchyPkey = 'map_technology_network_hierarchy_pkey'
}

/** input type for incrementing numeric columns in table "map_technology_network_hierarchy" */
export type TechnologyNetworkHierarchyMap_Inc_Input = {
  order?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "map_technology_network_hierarchy" */
export type TechnologyNetworkHierarchyMap_Insert_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  networkChild?: InputMaybe<TechnologyNetwork_Obj_Rel_Insert_Input>;
  networkChildId?: InputMaybe<Scalars['uuid']['input']>;
  networkParent?: InputMaybe<TechnologyNetwork_Obj_Rel_Insert_Input>;
  networkParentId?: InputMaybe<Scalars['uuid']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type TechnologyNetworkHierarchyMap_Max_Fields = {
  __typename?: 'TechnologyNetworkHierarchyMap_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  networkChildId?: Maybe<Scalars['uuid']['output']>;
  networkParentId?: Maybe<Scalars['uuid']['output']>;
  order?: Maybe<Scalars['Int']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "map_technology_network_hierarchy" */
export type TechnologyNetworkHierarchyMap_Max_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  networkChildId?: InputMaybe<Order_By>;
  networkParentId?: InputMaybe<Order_By>;
  order?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type TechnologyNetworkHierarchyMap_Min_Fields = {
  __typename?: 'TechnologyNetworkHierarchyMap_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  networkChildId?: Maybe<Scalars['uuid']['output']>;
  networkParentId?: Maybe<Scalars['uuid']['output']>;
  order?: Maybe<Scalars['Int']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "map_technology_network_hierarchy" */
export type TechnologyNetworkHierarchyMap_Min_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  networkChildId?: InputMaybe<Order_By>;
  networkParentId?: InputMaybe<Order_By>;
  order?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "map_technology_network_hierarchy" */
export type TechnologyNetworkHierarchyMap_Mutation_Response = {
  __typename?: 'TechnologyNetworkHierarchyMap_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<TechnologyNetworkHierarchyMap>;
};

/** on_conflict condition type for table "map_technology_network_hierarchy" */
export type TechnologyNetworkHierarchyMap_On_Conflict = {
  constraint: TechnologyNetworkHierarchyMap_Constraint;
  update_columns?: Array<TechnologyNetworkHierarchyMap_Update_Column>;
  where?: InputMaybe<TechnologyNetworkHierarchyMap_Bool_Exp>;
};

/** Ordering options when selecting data from "map_technology_network_hierarchy". */
export type TechnologyNetworkHierarchyMap_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  networkChild?: InputMaybe<TechnologyNetwork_Order_By>;
  networkChildId?: InputMaybe<Order_By>;
  networkParent?: InputMaybe<TechnologyNetwork_Order_By>;
  networkParentId?: InputMaybe<Order_By>;
  order?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: map_technology_network_hierarchy */
export type TechnologyNetworkHierarchyMap_Pk_Columns_Input = {
  networkChildId: Scalars['uuid']['input'];
  networkParentId: Scalars['uuid']['input'];
};

/** select columns of table "map_technology_network_hierarchy" */
export enum TechnologyNetworkHierarchyMap_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  NetworkChildId = 'networkChildId',
  /** column name */
  NetworkParentId = 'networkParentId',
  /** column name */
  Order = 'order',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "map_technology_network_hierarchy" */
export type TechnologyNetworkHierarchyMap_Set_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  networkChildId?: InputMaybe<Scalars['uuid']['input']>;
  networkParentId?: InputMaybe<Scalars['uuid']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type TechnologyNetworkHierarchyMap_Stddev_Fields = {
  __typename?: 'TechnologyNetworkHierarchyMap_stddev_fields';
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "map_technology_network_hierarchy" */
export type TechnologyNetworkHierarchyMap_Stddev_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type TechnologyNetworkHierarchyMap_Stddev_Pop_Fields = {
  __typename?: 'TechnologyNetworkHierarchyMap_stddev_pop_fields';
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "map_technology_network_hierarchy" */
export type TechnologyNetworkHierarchyMap_Stddev_Pop_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type TechnologyNetworkHierarchyMap_Stddev_Samp_Fields = {
  __typename?: 'TechnologyNetworkHierarchyMap_stddev_samp_fields';
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "map_technology_network_hierarchy" */
export type TechnologyNetworkHierarchyMap_Stddev_Samp_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "TechnologyNetworkHierarchyMap" */
export type TechnologyNetworkHierarchyMap_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: TechnologyNetworkHierarchyMap_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type TechnologyNetworkHierarchyMap_Stream_Cursor_Value_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  networkChildId?: InputMaybe<Scalars['uuid']['input']>;
  networkParentId?: InputMaybe<Scalars['uuid']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type TechnologyNetworkHierarchyMap_Sum_Fields = {
  __typename?: 'TechnologyNetworkHierarchyMap_sum_fields';
  order?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "map_technology_network_hierarchy" */
export type TechnologyNetworkHierarchyMap_Sum_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** update columns of table "map_technology_network_hierarchy" */
export enum TechnologyNetworkHierarchyMap_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  NetworkChildId = 'networkChildId',
  /** column name */
  NetworkParentId = 'networkParentId',
  /** column name */
  Order = 'order',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type TechnologyNetworkHierarchyMap_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<TechnologyNetworkHierarchyMap_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TechnologyNetworkHierarchyMap_Set_Input>;
  /** filter the rows which have to be updated */
  where: TechnologyNetworkHierarchyMap_Bool_Exp;
};

/** aggregate var_pop on columns */
export type TechnologyNetworkHierarchyMap_Var_Pop_Fields = {
  __typename?: 'TechnologyNetworkHierarchyMap_var_pop_fields';
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "map_technology_network_hierarchy" */
export type TechnologyNetworkHierarchyMap_Var_Pop_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type TechnologyNetworkHierarchyMap_Var_Samp_Fields = {
  __typename?: 'TechnologyNetworkHierarchyMap_var_samp_fields';
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "map_technology_network_hierarchy" */
export type TechnologyNetworkHierarchyMap_Var_Samp_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type TechnologyNetworkHierarchyMap_Variance_Fields = {
  __typename?: 'TechnologyNetworkHierarchyMap_variance_fields';
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "map_technology_network_hierarchy" */
export type TechnologyNetworkHierarchyMap_Variance_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** aggregated selection of "technology_networks" */
export type TechnologyNetwork_Aggregate = {
  __typename?: 'TechnologyNetwork_aggregate';
  aggregate?: Maybe<TechnologyNetwork_Aggregate_Fields>;
  nodes: Array<TechnologyNetwork>;
};

export type TechnologyNetwork_Aggregate_Bool_Exp = {
  count?: InputMaybe<TechnologyNetwork_Aggregate_Bool_Exp_Count>;
};

export type TechnologyNetwork_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<TechnologyNetwork_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<TechnologyNetwork_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "technology_networks" */
export type TechnologyNetwork_Aggregate_Fields = {
  __typename?: 'TechnologyNetwork_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<TechnologyNetwork_Max_Fields>;
  min?: Maybe<TechnologyNetwork_Min_Fields>;
};


/** aggregate fields of "technology_networks" */
export type TechnologyNetwork_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<TechnologyNetwork_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "technology_networks" */
export type TechnologyNetwork_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<TechnologyNetwork_Max_Order_By>;
  min?: InputMaybe<TechnologyNetwork_Min_Order_By>;
};

/** input type for inserting array relation for remote table "technology_networks" */
export type TechnologyNetwork_Arr_Rel_Insert_Input = {
  data: Array<TechnologyNetwork_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<TechnologyNetwork_On_Conflict>;
};

/** Boolean expression to filter rows from the table "technology_networks". All fields are combined with a logical 'AND'. */
export type TechnologyNetwork_Bool_Exp = {
  _and?: InputMaybe<Array<TechnologyNetwork_Bool_Exp>>;
  _not?: InputMaybe<TechnologyNetwork_Bool_Exp>;
  _or?: InputMaybe<Array<TechnologyNetwork_Bool_Exp>>;
  child?: InputMaybe<TechnologyNetworkHierarchyMap_Bool_Exp>;
  child_aggregate?: InputMaybe<TechnologyNetworkHierarchyMap_Aggregate_Bool_Exp>;
  code?: InputMaybe<String_Comparison_Exp>;
  components?: InputMaybe<ApplicationComponentTechnologyLogicalNetworkMap_Bool_Exp>;
  components_aggregate?: InputMaybe<ApplicationComponentTechnologyLogicalNetworkMap_Aggregate_Bool_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  environment?: InputMaybe<Environment_Enum_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  level?: InputMaybe<Network_Abstraction_Level_Enum_Comparison_Exp>;
  location?: InputMaybe<PhysicalLocation_Bool_Exp>;
  locationId?: InputMaybe<Uuid_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  nodes?: InputMaybe<TechnologyNode_Bool_Exp>;
  nodes_aggregate?: InputMaybe<TechnologyNode_Aggregate_Bool_Exp>;
  parent?: InputMaybe<TechnologyNetworkHierarchyMap_Bool_Exp>;
  parent_aggregate?: InputMaybe<TechnologyNetworkHierarchyMap_Aggregate_Bool_Exp>;
  scope?: InputMaybe<Network_Scope_Enum_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "technology_networks" */
export enum TechnologyNetwork_Constraint {
  /** unique or primary key constraint on columns "code" */
  TechnologyNetworksCodeUnique = 'technology_networks_code_unique',
  /** unique or primary key constraint on columns "id" */
  TechnologyNetworksPkey = 'technology_networks_pkey'
}

/** input type for inserting data into table "technology_networks" */
export type TechnologyNetwork_Insert_Input = {
  child?: InputMaybe<TechnologyNetworkHierarchyMap_Arr_Rel_Insert_Input>;
  code?: InputMaybe<Scalars['String']['input']>;
  components?: InputMaybe<ApplicationComponentTechnologyLogicalNetworkMap_Arr_Rel_Insert_Input>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  environment?: InputMaybe<Scalars['environment_enum']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  level?: InputMaybe<Scalars['network_abstraction_level_enum']['input']>;
  location?: InputMaybe<PhysicalLocation_Obj_Rel_Insert_Input>;
  locationId?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  nodes?: InputMaybe<TechnologyNode_Arr_Rel_Insert_Input>;
  parent?: InputMaybe<TechnologyNetworkHierarchyMap_Arr_Rel_Insert_Input>;
  scope?: InputMaybe<Scalars['network_scope_enum']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type TechnologyNetwork_Max_Fields = {
  __typename?: 'TechnologyNetwork_max_fields';
  code?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  environment?: Maybe<Scalars['environment_enum']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  level?: Maybe<Scalars['network_abstraction_level_enum']['output']>;
  locationId?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  scope?: Maybe<Scalars['network_scope_enum']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "technology_networks" */
export type TechnologyNetwork_Max_Order_By = {
  code?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  environment?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  level?: InputMaybe<Order_By>;
  locationId?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  scope?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type TechnologyNetwork_Min_Fields = {
  __typename?: 'TechnologyNetwork_min_fields';
  code?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  environment?: Maybe<Scalars['environment_enum']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  level?: Maybe<Scalars['network_abstraction_level_enum']['output']>;
  locationId?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  scope?: Maybe<Scalars['network_scope_enum']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "technology_networks" */
export type TechnologyNetwork_Min_Order_By = {
  code?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  environment?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  level?: InputMaybe<Order_By>;
  locationId?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  scope?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "technology_networks" */
export type TechnologyNetwork_Mutation_Response = {
  __typename?: 'TechnologyNetwork_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<TechnologyNetwork>;
};

/** input type for inserting object relation for remote table "technology_networks" */
export type TechnologyNetwork_Obj_Rel_Insert_Input = {
  data: TechnologyNetwork_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<TechnologyNetwork_On_Conflict>;
};

/** on_conflict condition type for table "technology_networks" */
export type TechnologyNetwork_On_Conflict = {
  constraint: TechnologyNetwork_Constraint;
  update_columns?: Array<TechnologyNetwork_Update_Column>;
  where?: InputMaybe<TechnologyNetwork_Bool_Exp>;
};

/** Ordering options when selecting data from "technology_networks". */
export type TechnologyNetwork_Order_By = {
  child_aggregate?: InputMaybe<TechnologyNetworkHierarchyMap_Aggregate_Order_By>;
  code?: InputMaybe<Order_By>;
  components_aggregate?: InputMaybe<ApplicationComponentTechnologyLogicalNetworkMap_Aggregate_Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  environment?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  level?: InputMaybe<Order_By>;
  location?: InputMaybe<PhysicalLocation_Order_By>;
  locationId?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  nodes_aggregate?: InputMaybe<TechnologyNode_Aggregate_Order_By>;
  parent_aggregate?: InputMaybe<TechnologyNetworkHierarchyMap_Aggregate_Order_By>;
  scope?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: technology_networks */
export type TechnologyNetwork_Pk_Columns_Input = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "technology_networks" */
export enum TechnologyNetwork_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Environment = 'environment',
  /** column name */
  Id = 'id',
  /** column name */
  Level = 'level',
  /** column name */
  LocationId = 'locationId',
  /** column name */
  Name = 'name',
  /** column name */
  Scope = 'scope',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "technology_networks" */
export type TechnologyNetwork_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  environment?: InputMaybe<Scalars['environment_enum']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  level?: InputMaybe<Scalars['network_abstraction_level_enum']['input']>;
  locationId?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  scope?: InputMaybe<Scalars['network_scope_enum']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "TechnologyNetwork" */
export type TechnologyNetwork_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: TechnologyNetwork_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type TechnologyNetwork_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  environment?: InputMaybe<Scalars['environment_enum']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  level?: InputMaybe<Scalars['network_abstraction_level_enum']['input']>;
  locationId?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  scope?: InputMaybe<Scalars['network_scope_enum']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "technology_networks" */
export enum TechnologyNetwork_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Environment = 'environment',
  /** column name */
  Id = 'id',
  /** column name */
  Level = 'level',
  /** column name */
  LocationId = 'locationId',
  /** column name */
  Name = 'name',
  /** column name */
  Scope = 'scope',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type TechnologyNetwork_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TechnologyNetwork_Set_Input>;
  /** filter the rows which have to be updated */
  where: TechnologyNetwork_Bool_Exp;
};

/** columns and relationships of "technology_nodes" */
export type TechnologyNode = {
  __typename?: 'TechnologyNode';
  architecture: Scalars['system_architecture_kind_enum']['output'];
  /** An array relationship */
  child: Array<TechnologyNodeHierarchyMap>;
  /** An aggregate relationship */
  child_aggregate: TechnologyNodeHierarchyMap_Aggregate;
  code: Scalars['String']['output'];
  /** An array relationship */
  components: Array<ApplicationComponentTechnologyNodeMap>;
  /** An aggregate relationship */
  components_aggregate: ApplicationComponentTechnologyNodeMap_Aggregate;
  cpuCores?: Maybe<Scalars['Int']['output']>;
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  environment: Scalars['environment_enum']['output'];
  id: Scalars['uuid']['output'];
  kind: Scalars['node_kind_enum']['output'];
  name: Scalars['String']['output'];
  /** An object relationship */
  network?: Maybe<TechnologyNetwork>;
  networkId?: Maybe<Scalars['uuid']['output']>;
  /** An array relationship */
  node: Array<SolutionTechnologyNodeMap>;
  nodeCount?: Maybe<Scalars['Int']['output']>;
  /** An aggregate relationship */
  node_aggregate: SolutionTechnologyNodeMap_Aggregate;
  /** An object relationship */
  operatingSystem: SystemSoftware;
  operatingSystemId: Scalars['uuid']['output'];
  /** An array relationship */
  parent: Array<TechnologyNodeHierarchyMap>;
  /** An aggregate relationship */
  parent_aggregate: TechnologyNodeHierarchyMap_Aggregate;
  ramGb?: Maybe<Scalars['Int']['output']>;
  /** An array relationship */
  sourceNode: Array<FlowGeneric>;
  /** An aggregate relationship */
  sourceNode_aggregate: FlowGeneric_Aggregate;
  storageGb?: Maybe<Scalars['Int']['output']>;
  /** An array relationship */
  systemSoftware: Array<TechnologyNodeSystemSoftwareMap>;
  /** An aggregate relationship */
  systemSoftware_aggregate: TechnologyNodeSystemSoftwareMap_Aggregate;
  /** An array relationship */
  targetNode: Array<FlowGeneric>;
  /** An aggregate relationship */
  targetNode_aggregate: FlowGeneric_Aggregate;
  totalCpuCores?: Maybe<Scalars['Int']['output']>;
  totalRamGb?: Maybe<Scalars['Int']['output']>;
  totalStorageGb?: Maybe<Scalars['Int']['output']>;
  /** An object relationship */
  type: DirectoryObject;
  typeId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};


/** columns and relationships of "technology_nodes" */
export type TechnologyNodeChildArgs = {
  distinct_on?: InputMaybe<Array<TechnologyNodeHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TechnologyNodeHierarchyMap_Order_By>>;
  where?: InputMaybe<TechnologyNodeHierarchyMap_Bool_Exp>;
};


/** columns and relationships of "technology_nodes" */
export type TechnologyNodeChild_AggregateArgs = {
  distinct_on?: InputMaybe<Array<TechnologyNodeHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TechnologyNodeHierarchyMap_Order_By>>;
  where?: InputMaybe<TechnologyNodeHierarchyMap_Bool_Exp>;
};


/** columns and relationships of "technology_nodes" */
export type TechnologyNodeComponentsArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentTechnologyNodeMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentTechnologyNodeMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentTechnologyNodeMap_Bool_Exp>;
};


/** columns and relationships of "technology_nodes" */
export type TechnologyNodeComponents_AggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentTechnologyNodeMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentTechnologyNodeMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentTechnologyNodeMap_Bool_Exp>;
};


/** columns and relationships of "technology_nodes" */
export type TechnologyNodeNodeArgs = {
  distinct_on?: InputMaybe<Array<SolutionTechnologyNodeMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionTechnologyNodeMap_Order_By>>;
  where?: InputMaybe<SolutionTechnologyNodeMap_Bool_Exp>;
};


/** columns and relationships of "technology_nodes" */
export type TechnologyNodeNode_AggregateArgs = {
  distinct_on?: InputMaybe<Array<SolutionTechnologyNodeMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionTechnologyNodeMap_Order_By>>;
  where?: InputMaybe<SolutionTechnologyNodeMap_Bool_Exp>;
};


/** columns and relationships of "technology_nodes" */
export type TechnologyNodeParentArgs = {
  distinct_on?: InputMaybe<Array<TechnologyNodeHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TechnologyNodeHierarchyMap_Order_By>>;
  where?: InputMaybe<TechnologyNodeHierarchyMap_Bool_Exp>;
};


/** columns and relationships of "technology_nodes" */
export type TechnologyNodeParent_AggregateArgs = {
  distinct_on?: InputMaybe<Array<TechnologyNodeHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TechnologyNodeHierarchyMap_Order_By>>;
  where?: InputMaybe<TechnologyNodeHierarchyMap_Bool_Exp>;
};


/** columns and relationships of "technology_nodes" */
export type TechnologyNodeSourceNodeArgs = {
  distinct_on?: InputMaybe<Array<FlowGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FlowGeneric_Order_By>>;
  where?: InputMaybe<FlowGeneric_Bool_Exp>;
};


/** columns and relationships of "technology_nodes" */
export type TechnologyNodeSourceNode_AggregateArgs = {
  distinct_on?: InputMaybe<Array<FlowGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FlowGeneric_Order_By>>;
  where?: InputMaybe<FlowGeneric_Bool_Exp>;
};


/** columns and relationships of "technology_nodes" */
export type TechnologyNodeSystemSoftwareArgs = {
  distinct_on?: InputMaybe<Array<TechnologyNodeSystemSoftwareMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TechnologyNodeSystemSoftwareMap_Order_By>>;
  where?: InputMaybe<TechnologyNodeSystemSoftwareMap_Bool_Exp>;
};


/** columns and relationships of "technology_nodes" */
export type TechnologyNodeSystemSoftware_AggregateArgs = {
  distinct_on?: InputMaybe<Array<TechnologyNodeSystemSoftwareMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TechnologyNodeSystemSoftwareMap_Order_By>>;
  where?: InputMaybe<TechnologyNodeSystemSoftwareMap_Bool_Exp>;
};


/** columns and relationships of "technology_nodes" */
export type TechnologyNodeTargetNodeArgs = {
  distinct_on?: InputMaybe<Array<FlowGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FlowGeneric_Order_By>>;
  where?: InputMaybe<FlowGeneric_Bool_Exp>;
};


/** columns and relationships of "technology_nodes" */
export type TechnologyNodeTargetNode_AggregateArgs = {
  distinct_on?: InputMaybe<Array<FlowGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FlowGeneric_Order_By>>;
  where?: InputMaybe<FlowGeneric_Bool_Exp>;
};

/** columns and relationships of "map_technology_node_hierarchy" */
export type TechnologyNodeHierarchyMap = {
  __typename?: 'TechnologyNodeHierarchyMap';
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  nodeChild: TechnologyNode;
  nodeChildId: Scalars['uuid']['output'];
  /** An object relationship */
  nodeParent: TechnologyNode;
  nodeParentId: Scalars['uuid']['output'];
  order?: Maybe<Scalars['Int']['output']>;
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "map_technology_node_hierarchy" */
export type TechnologyNodeHierarchyMap_Aggregate = {
  __typename?: 'TechnologyNodeHierarchyMap_aggregate';
  aggregate?: Maybe<TechnologyNodeHierarchyMap_Aggregate_Fields>;
  nodes: Array<TechnologyNodeHierarchyMap>;
};

export type TechnologyNodeHierarchyMap_Aggregate_Bool_Exp = {
  count?: InputMaybe<TechnologyNodeHierarchyMap_Aggregate_Bool_Exp_Count>;
};

export type TechnologyNodeHierarchyMap_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<TechnologyNodeHierarchyMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<TechnologyNodeHierarchyMap_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "map_technology_node_hierarchy" */
export type TechnologyNodeHierarchyMap_Aggregate_Fields = {
  __typename?: 'TechnologyNodeHierarchyMap_aggregate_fields';
  avg?: Maybe<TechnologyNodeHierarchyMap_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<TechnologyNodeHierarchyMap_Max_Fields>;
  min?: Maybe<TechnologyNodeHierarchyMap_Min_Fields>;
  stddev?: Maybe<TechnologyNodeHierarchyMap_Stddev_Fields>;
  stddev_pop?: Maybe<TechnologyNodeHierarchyMap_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<TechnologyNodeHierarchyMap_Stddev_Samp_Fields>;
  sum?: Maybe<TechnologyNodeHierarchyMap_Sum_Fields>;
  var_pop?: Maybe<TechnologyNodeHierarchyMap_Var_Pop_Fields>;
  var_samp?: Maybe<TechnologyNodeHierarchyMap_Var_Samp_Fields>;
  variance?: Maybe<TechnologyNodeHierarchyMap_Variance_Fields>;
};


/** aggregate fields of "map_technology_node_hierarchy" */
export type TechnologyNodeHierarchyMap_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<TechnologyNodeHierarchyMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "map_technology_node_hierarchy" */
export type TechnologyNodeHierarchyMap_Aggregate_Order_By = {
  avg?: InputMaybe<TechnologyNodeHierarchyMap_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<TechnologyNodeHierarchyMap_Max_Order_By>;
  min?: InputMaybe<TechnologyNodeHierarchyMap_Min_Order_By>;
  stddev?: InputMaybe<TechnologyNodeHierarchyMap_Stddev_Order_By>;
  stddev_pop?: InputMaybe<TechnologyNodeHierarchyMap_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<TechnologyNodeHierarchyMap_Stddev_Samp_Order_By>;
  sum?: InputMaybe<TechnologyNodeHierarchyMap_Sum_Order_By>;
  var_pop?: InputMaybe<TechnologyNodeHierarchyMap_Var_Pop_Order_By>;
  var_samp?: InputMaybe<TechnologyNodeHierarchyMap_Var_Samp_Order_By>;
  variance?: InputMaybe<TechnologyNodeHierarchyMap_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "map_technology_node_hierarchy" */
export type TechnologyNodeHierarchyMap_Arr_Rel_Insert_Input = {
  data: Array<TechnologyNodeHierarchyMap_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<TechnologyNodeHierarchyMap_On_Conflict>;
};

/** aggregate avg on columns */
export type TechnologyNodeHierarchyMap_Avg_Fields = {
  __typename?: 'TechnologyNodeHierarchyMap_avg_fields';
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "map_technology_node_hierarchy" */
export type TechnologyNodeHierarchyMap_Avg_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "map_technology_node_hierarchy". All fields are combined with a logical 'AND'. */
export type TechnologyNodeHierarchyMap_Bool_Exp = {
  _and?: InputMaybe<Array<TechnologyNodeHierarchyMap_Bool_Exp>>;
  _not?: InputMaybe<TechnologyNodeHierarchyMap_Bool_Exp>;
  _or?: InputMaybe<Array<TechnologyNodeHierarchyMap_Bool_Exp>>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  nodeChild?: InputMaybe<TechnologyNode_Bool_Exp>;
  nodeChildId?: InputMaybe<Uuid_Comparison_Exp>;
  nodeParent?: InputMaybe<TechnologyNode_Bool_Exp>;
  nodeParentId?: InputMaybe<Uuid_Comparison_Exp>;
  order?: InputMaybe<Int_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "map_technology_node_hierarchy" */
export enum TechnologyNodeHierarchyMap_Constraint {
  /** unique or primary key constraint on columns "node_parent_id", "node_child_id" */
  MapTechnologyNodeHierarchyNodeParentIdNodeAea06Unique = 'map_technology_node_hierarchy_node_parent_id_node_aea06_unique',
  /** unique or primary key constraint on columns "node_parent_id", "node_child_id" */
  MapTechnologyNodeHierarchyPkey = 'map_technology_node_hierarchy_pkey'
}

/** input type for incrementing numeric columns in table "map_technology_node_hierarchy" */
export type TechnologyNodeHierarchyMap_Inc_Input = {
  order?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "map_technology_node_hierarchy" */
export type TechnologyNodeHierarchyMap_Insert_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  nodeChild?: InputMaybe<TechnologyNode_Obj_Rel_Insert_Input>;
  nodeChildId?: InputMaybe<Scalars['uuid']['input']>;
  nodeParent?: InputMaybe<TechnologyNode_Obj_Rel_Insert_Input>;
  nodeParentId?: InputMaybe<Scalars['uuid']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type TechnologyNodeHierarchyMap_Max_Fields = {
  __typename?: 'TechnologyNodeHierarchyMap_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  nodeChildId?: Maybe<Scalars['uuid']['output']>;
  nodeParentId?: Maybe<Scalars['uuid']['output']>;
  order?: Maybe<Scalars['Int']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "map_technology_node_hierarchy" */
export type TechnologyNodeHierarchyMap_Max_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  nodeChildId?: InputMaybe<Order_By>;
  nodeParentId?: InputMaybe<Order_By>;
  order?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type TechnologyNodeHierarchyMap_Min_Fields = {
  __typename?: 'TechnologyNodeHierarchyMap_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  nodeChildId?: Maybe<Scalars['uuid']['output']>;
  nodeParentId?: Maybe<Scalars['uuid']['output']>;
  order?: Maybe<Scalars['Int']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "map_technology_node_hierarchy" */
export type TechnologyNodeHierarchyMap_Min_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  nodeChildId?: InputMaybe<Order_By>;
  nodeParentId?: InputMaybe<Order_By>;
  order?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "map_technology_node_hierarchy" */
export type TechnologyNodeHierarchyMap_Mutation_Response = {
  __typename?: 'TechnologyNodeHierarchyMap_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<TechnologyNodeHierarchyMap>;
};

/** on_conflict condition type for table "map_technology_node_hierarchy" */
export type TechnologyNodeHierarchyMap_On_Conflict = {
  constraint: TechnologyNodeHierarchyMap_Constraint;
  update_columns?: Array<TechnologyNodeHierarchyMap_Update_Column>;
  where?: InputMaybe<TechnologyNodeHierarchyMap_Bool_Exp>;
};

/** Ordering options when selecting data from "map_technology_node_hierarchy". */
export type TechnologyNodeHierarchyMap_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  nodeChild?: InputMaybe<TechnologyNode_Order_By>;
  nodeChildId?: InputMaybe<Order_By>;
  nodeParent?: InputMaybe<TechnologyNode_Order_By>;
  nodeParentId?: InputMaybe<Order_By>;
  order?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: map_technology_node_hierarchy */
export type TechnologyNodeHierarchyMap_Pk_Columns_Input = {
  nodeChildId: Scalars['uuid']['input'];
  nodeParentId: Scalars['uuid']['input'];
};

/** select columns of table "map_technology_node_hierarchy" */
export enum TechnologyNodeHierarchyMap_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  NodeChildId = 'nodeChildId',
  /** column name */
  NodeParentId = 'nodeParentId',
  /** column name */
  Order = 'order',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "map_technology_node_hierarchy" */
export type TechnologyNodeHierarchyMap_Set_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  nodeChildId?: InputMaybe<Scalars['uuid']['input']>;
  nodeParentId?: InputMaybe<Scalars['uuid']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type TechnologyNodeHierarchyMap_Stddev_Fields = {
  __typename?: 'TechnologyNodeHierarchyMap_stddev_fields';
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "map_technology_node_hierarchy" */
export type TechnologyNodeHierarchyMap_Stddev_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type TechnologyNodeHierarchyMap_Stddev_Pop_Fields = {
  __typename?: 'TechnologyNodeHierarchyMap_stddev_pop_fields';
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "map_technology_node_hierarchy" */
export type TechnologyNodeHierarchyMap_Stddev_Pop_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type TechnologyNodeHierarchyMap_Stddev_Samp_Fields = {
  __typename?: 'TechnologyNodeHierarchyMap_stddev_samp_fields';
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "map_technology_node_hierarchy" */
export type TechnologyNodeHierarchyMap_Stddev_Samp_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "TechnologyNodeHierarchyMap" */
export type TechnologyNodeHierarchyMap_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: TechnologyNodeHierarchyMap_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type TechnologyNodeHierarchyMap_Stream_Cursor_Value_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  nodeChildId?: InputMaybe<Scalars['uuid']['input']>;
  nodeParentId?: InputMaybe<Scalars['uuid']['input']>;
  order?: InputMaybe<Scalars['Int']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type TechnologyNodeHierarchyMap_Sum_Fields = {
  __typename?: 'TechnologyNodeHierarchyMap_sum_fields';
  order?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "map_technology_node_hierarchy" */
export type TechnologyNodeHierarchyMap_Sum_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** update columns of table "map_technology_node_hierarchy" */
export enum TechnologyNodeHierarchyMap_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  NodeChildId = 'nodeChildId',
  /** column name */
  NodeParentId = 'nodeParentId',
  /** column name */
  Order = 'order',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type TechnologyNodeHierarchyMap_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<TechnologyNodeHierarchyMap_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TechnologyNodeHierarchyMap_Set_Input>;
  /** filter the rows which have to be updated */
  where: TechnologyNodeHierarchyMap_Bool_Exp;
};

/** aggregate var_pop on columns */
export type TechnologyNodeHierarchyMap_Var_Pop_Fields = {
  __typename?: 'TechnologyNodeHierarchyMap_var_pop_fields';
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "map_technology_node_hierarchy" */
export type TechnologyNodeHierarchyMap_Var_Pop_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type TechnologyNodeHierarchyMap_Var_Samp_Fields = {
  __typename?: 'TechnologyNodeHierarchyMap_var_samp_fields';
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "map_technology_node_hierarchy" */
export type TechnologyNodeHierarchyMap_Var_Samp_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type TechnologyNodeHierarchyMap_Variance_Fields = {
  __typename?: 'TechnologyNodeHierarchyMap_variance_fields';
  order?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "map_technology_node_hierarchy" */
export type TechnologyNodeHierarchyMap_Variance_Order_By = {
  order?: InputMaybe<Order_By>;
};

/** columns and relationships of "map_technology_node_system_software" */
export type TechnologyNodeSystemSoftwareMap = {
  __typename?: 'TechnologyNodeSystemSoftwareMap';
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  kind: Scalars['system_software_kind_enum']['output'];
  /** An object relationship */
  node: TechnologyNode;
  nodeId: Scalars['uuid']['output'];
  /** An object relationship */
  systemSoftware: SystemSoftware;
  systemSoftwareId: Scalars['uuid']['output'];
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "map_technology_node_system_software" */
export type TechnologyNodeSystemSoftwareMap_Aggregate = {
  __typename?: 'TechnologyNodeSystemSoftwareMap_aggregate';
  aggregate?: Maybe<TechnologyNodeSystemSoftwareMap_Aggregate_Fields>;
  nodes: Array<TechnologyNodeSystemSoftwareMap>;
};

export type TechnologyNodeSystemSoftwareMap_Aggregate_Bool_Exp = {
  count?: InputMaybe<TechnologyNodeSystemSoftwareMap_Aggregate_Bool_Exp_Count>;
};

export type TechnologyNodeSystemSoftwareMap_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<TechnologyNodeSystemSoftwareMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<TechnologyNodeSystemSoftwareMap_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "map_technology_node_system_software" */
export type TechnologyNodeSystemSoftwareMap_Aggregate_Fields = {
  __typename?: 'TechnologyNodeSystemSoftwareMap_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<TechnologyNodeSystemSoftwareMap_Max_Fields>;
  min?: Maybe<TechnologyNodeSystemSoftwareMap_Min_Fields>;
};


/** aggregate fields of "map_technology_node_system_software" */
export type TechnologyNodeSystemSoftwareMap_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<TechnologyNodeSystemSoftwareMap_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "map_technology_node_system_software" */
export type TechnologyNodeSystemSoftwareMap_Aggregate_Order_By = {
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<TechnologyNodeSystemSoftwareMap_Max_Order_By>;
  min?: InputMaybe<TechnologyNodeSystemSoftwareMap_Min_Order_By>;
};

/** input type for inserting array relation for remote table "map_technology_node_system_software" */
export type TechnologyNodeSystemSoftwareMap_Arr_Rel_Insert_Input = {
  data: Array<TechnologyNodeSystemSoftwareMap_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<TechnologyNodeSystemSoftwareMap_On_Conflict>;
};

/** Boolean expression to filter rows from the table "map_technology_node_system_software". All fields are combined with a logical 'AND'. */
export type TechnologyNodeSystemSoftwareMap_Bool_Exp = {
  _and?: InputMaybe<Array<TechnologyNodeSystemSoftwareMap_Bool_Exp>>;
  _not?: InputMaybe<TechnologyNodeSystemSoftwareMap_Bool_Exp>;
  _or?: InputMaybe<Array<TechnologyNodeSystemSoftwareMap_Bool_Exp>>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  kind?: InputMaybe<System_Software_Kind_Enum_Comparison_Exp>;
  node?: InputMaybe<TechnologyNode_Bool_Exp>;
  nodeId?: InputMaybe<Uuid_Comparison_Exp>;
  systemSoftware?: InputMaybe<SystemSoftware_Bool_Exp>;
  systemSoftwareId?: InputMaybe<Uuid_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "map_technology_node_system_software" */
export enum TechnologyNodeSystemSoftwareMap_Constraint {
  /** unique or primary key constraint on columns "node_id", "system_software_id" */
  MapTechnologyNodeSystemSoftwareNodeIdSyste_37a00Unique = 'map_technology_node_system_software_node_id_syste_37a00_unique',
  /** unique or primary key constraint on columns "node_id", "system_software_id" */
  MapTechnologyNodeSystemSoftwarePkey = 'map_technology_node_system_software_pkey'
}

/** input type for inserting data into table "map_technology_node_system_software" */
export type TechnologyNodeSystemSoftwareMap_Insert_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  kind?: InputMaybe<Scalars['system_software_kind_enum']['input']>;
  node?: InputMaybe<TechnologyNode_Obj_Rel_Insert_Input>;
  nodeId?: InputMaybe<Scalars['uuid']['input']>;
  systemSoftware?: InputMaybe<SystemSoftware_Obj_Rel_Insert_Input>;
  systemSoftwareId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type TechnologyNodeSystemSoftwareMap_Max_Fields = {
  __typename?: 'TechnologyNodeSystemSoftwareMap_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  kind?: Maybe<Scalars['system_software_kind_enum']['output']>;
  nodeId?: Maybe<Scalars['uuid']['output']>;
  systemSoftwareId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "map_technology_node_system_software" */
export type TechnologyNodeSystemSoftwareMap_Max_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  kind?: InputMaybe<Order_By>;
  nodeId?: InputMaybe<Order_By>;
  systemSoftwareId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type TechnologyNodeSystemSoftwareMap_Min_Fields = {
  __typename?: 'TechnologyNodeSystemSoftwareMap_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  kind?: Maybe<Scalars['system_software_kind_enum']['output']>;
  nodeId?: Maybe<Scalars['uuid']['output']>;
  systemSoftwareId?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "map_technology_node_system_software" */
export type TechnologyNodeSystemSoftwareMap_Min_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  kind?: InputMaybe<Order_By>;
  nodeId?: InputMaybe<Order_By>;
  systemSoftwareId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "map_technology_node_system_software" */
export type TechnologyNodeSystemSoftwareMap_Mutation_Response = {
  __typename?: 'TechnologyNodeSystemSoftwareMap_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<TechnologyNodeSystemSoftwareMap>;
};

/** on_conflict condition type for table "map_technology_node_system_software" */
export type TechnologyNodeSystemSoftwareMap_On_Conflict = {
  constraint: TechnologyNodeSystemSoftwareMap_Constraint;
  update_columns?: Array<TechnologyNodeSystemSoftwareMap_Update_Column>;
  where?: InputMaybe<TechnologyNodeSystemSoftwareMap_Bool_Exp>;
};

/** Ordering options when selecting data from "map_technology_node_system_software". */
export type TechnologyNodeSystemSoftwareMap_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  kind?: InputMaybe<Order_By>;
  node?: InputMaybe<TechnologyNode_Order_By>;
  nodeId?: InputMaybe<Order_By>;
  systemSoftware?: InputMaybe<SystemSoftware_Order_By>;
  systemSoftwareId?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: map_technology_node_system_software */
export type TechnologyNodeSystemSoftwareMap_Pk_Columns_Input = {
  nodeId: Scalars['uuid']['input'];
  systemSoftwareId: Scalars['uuid']['input'];
};

/** select columns of table "map_technology_node_system_software" */
export enum TechnologyNodeSystemSoftwareMap_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Kind = 'kind',
  /** column name */
  NodeId = 'nodeId',
  /** column name */
  SystemSoftwareId = 'systemSoftwareId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "map_technology_node_system_software" */
export type TechnologyNodeSystemSoftwareMap_Set_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  kind?: InputMaybe<Scalars['system_software_kind_enum']['input']>;
  nodeId?: InputMaybe<Scalars['uuid']['input']>;
  systemSoftwareId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "TechnologyNodeSystemSoftwareMap" */
export type TechnologyNodeSystemSoftwareMap_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: TechnologyNodeSystemSoftwareMap_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type TechnologyNodeSystemSoftwareMap_Stream_Cursor_Value_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  kind?: InputMaybe<Scalars['system_software_kind_enum']['input']>;
  nodeId?: InputMaybe<Scalars['uuid']['input']>;
  systemSoftwareId?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "map_technology_node_system_software" */
export enum TechnologyNodeSystemSoftwareMap_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Kind = 'kind',
  /** column name */
  NodeId = 'nodeId',
  /** column name */
  SystemSoftwareId = 'systemSoftwareId',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type TechnologyNodeSystemSoftwareMap_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TechnologyNodeSystemSoftwareMap_Set_Input>;
  /** filter the rows which have to be updated */
  where: TechnologyNodeSystemSoftwareMap_Bool_Exp;
};

/** aggregated selection of "technology_nodes" */
export type TechnologyNode_Aggregate = {
  __typename?: 'TechnologyNode_aggregate';
  aggregate?: Maybe<TechnologyNode_Aggregate_Fields>;
  nodes: Array<TechnologyNode>;
};

export type TechnologyNode_Aggregate_Bool_Exp = {
  count?: InputMaybe<TechnologyNode_Aggregate_Bool_Exp_Count>;
};

export type TechnologyNode_Aggregate_Bool_Exp_Count = {
  arguments?: InputMaybe<Array<TechnologyNode_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
  filter?: InputMaybe<TechnologyNode_Bool_Exp>;
  predicate: Int_Comparison_Exp;
};

/** aggregate fields of "technology_nodes" */
export type TechnologyNode_Aggregate_Fields = {
  __typename?: 'TechnologyNode_aggregate_fields';
  avg?: Maybe<TechnologyNode_Avg_Fields>;
  count: Scalars['Int']['output'];
  max?: Maybe<TechnologyNode_Max_Fields>;
  min?: Maybe<TechnologyNode_Min_Fields>;
  stddev?: Maybe<TechnologyNode_Stddev_Fields>;
  stddev_pop?: Maybe<TechnologyNode_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<TechnologyNode_Stddev_Samp_Fields>;
  sum?: Maybe<TechnologyNode_Sum_Fields>;
  var_pop?: Maybe<TechnologyNode_Var_Pop_Fields>;
  var_samp?: Maybe<TechnologyNode_Var_Samp_Fields>;
  variance?: Maybe<TechnologyNode_Variance_Fields>;
};


/** aggregate fields of "technology_nodes" */
export type TechnologyNode_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<TechnologyNode_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** order by aggregate values of table "technology_nodes" */
export type TechnologyNode_Aggregate_Order_By = {
  avg?: InputMaybe<TechnologyNode_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<TechnologyNode_Max_Order_By>;
  min?: InputMaybe<TechnologyNode_Min_Order_By>;
  stddev?: InputMaybe<TechnologyNode_Stddev_Order_By>;
  stddev_pop?: InputMaybe<TechnologyNode_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<TechnologyNode_Stddev_Samp_Order_By>;
  sum?: InputMaybe<TechnologyNode_Sum_Order_By>;
  var_pop?: InputMaybe<TechnologyNode_Var_Pop_Order_By>;
  var_samp?: InputMaybe<TechnologyNode_Var_Samp_Order_By>;
  variance?: InputMaybe<TechnologyNode_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "technology_nodes" */
export type TechnologyNode_Arr_Rel_Insert_Input = {
  data: Array<TechnologyNode_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<TechnologyNode_On_Conflict>;
};

/** aggregate avg on columns */
export type TechnologyNode_Avg_Fields = {
  __typename?: 'TechnologyNode_avg_fields';
  cpuCores?: Maybe<Scalars['Float']['output']>;
  nodeCount?: Maybe<Scalars['Float']['output']>;
  ramGb?: Maybe<Scalars['Float']['output']>;
  storageGb?: Maybe<Scalars['Float']['output']>;
  totalCpuCores?: Maybe<Scalars['Float']['output']>;
  totalRamGb?: Maybe<Scalars['Float']['output']>;
  totalStorageGb?: Maybe<Scalars['Float']['output']>;
};

/** order by avg() on columns of table "technology_nodes" */
export type TechnologyNode_Avg_Order_By = {
  cpuCores?: InputMaybe<Order_By>;
  nodeCount?: InputMaybe<Order_By>;
  ramGb?: InputMaybe<Order_By>;
  storageGb?: InputMaybe<Order_By>;
  totalCpuCores?: InputMaybe<Order_By>;
  totalRamGb?: InputMaybe<Order_By>;
  totalStorageGb?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "technology_nodes". All fields are combined with a logical 'AND'. */
export type TechnologyNode_Bool_Exp = {
  _and?: InputMaybe<Array<TechnologyNode_Bool_Exp>>;
  _not?: InputMaybe<TechnologyNode_Bool_Exp>;
  _or?: InputMaybe<Array<TechnologyNode_Bool_Exp>>;
  architecture?: InputMaybe<System_Architecture_Kind_Enum_Comparison_Exp>;
  child?: InputMaybe<TechnologyNodeHierarchyMap_Bool_Exp>;
  child_aggregate?: InputMaybe<TechnologyNodeHierarchyMap_Aggregate_Bool_Exp>;
  code?: InputMaybe<String_Comparison_Exp>;
  components?: InputMaybe<ApplicationComponentTechnologyNodeMap_Bool_Exp>;
  components_aggregate?: InputMaybe<ApplicationComponentTechnologyNodeMap_Aggregate_Bool_Exp>;
  cpuCores?: InputMaybe<Int_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  environment?: InputMaybe<Environment_Enum_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  kind?: InputMaybe<Node_Kind_Enum_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  network?: InputMaybe<TechnologyNetwork_Bool_Exp>;
  networkId?: InputMaybe<Uuid_Comparison_Exp>;
  node?: InputMaybe<SolutionTechnologyNodeMap_Bool_Exp>;
  nodeCount?: InputMaybe<Int_Comparison_Exp>;
  node_aggregate?: InputMaybe<SolutionTechnologyNodeMap_Aggregate_Bool_Exp>;
  operatingSystem?: InputMaybe<SystemSoftware_Bool_Exp>;
  operatingSystemId?: InputMaybe<Uuid_Comparison_Exp>;
  parent?: InputMaybe<TechnologyNodeHierarchyMap_Bool_Exp>;
  parent_aggregate?: InputMaybe<TechnologyNodeHierarchyMap_Aggregate_Bool_Exp>;
  ramGb?: InputMaybe<Int_Comparison_Exp>;
  sourceNode?: InputMaybe<FlowGeneric_Bool_Exp>;
  sourceNode_aggregate?: InputMaybe<FlowGeneric_Aggregate_Bool_Exp>;
  storageGb?: InputMaybe<Int_Comparison_Exp>;
  systemSoftware?: InputMaybe<TechnologyNodeSystemSoftwareMap_Bool_Exp>;
  systemSoftware_aggregate?: InputMaybe<TechnologyNodeSystemSoftwareMap_Aggregate_Bool_Exp>;
  targetNode?: InputMaybe<FlowGeneric_Bool_Exp>;
  targetNode_aggregate?: InputMaybe<FlowGeneric_Aggregate_Bool_Exp>;
  totalCpuCores?: InputMaybe<Int_Comparison_Exp>;
  totalRamGb?: InputMaybe<Int_Comparison_Exp>;
  totalStorageGb?: InputMaybe<Int_Comparison_Exp>;
  type?: InputMaybe<DirectoryObject_Bool_Exp>;
  typeId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "technology_nodes" */
export enum TechnologyNode_Constraint {
  /** unique or primary key constraint on columns "code" */
  TechnologyNodesCodeUnique = 'technology_nodes_code_unique',
  /** unique or primary key constraint on columns "id" */
  TechnologyNodesPkey = 'technology_nodes_pkey'
}

/** input type for incrementing numeric columns in table "technology_nodes" */
export type TechnologyNode_Inc_Input = {
  cpuCores?: InputMaybe<Scalars['Int']['input']>;
  nodeCount?: InputMaybe<Scalars['Int']['input']>;
  ramGb?: InputMaybe<Scalars['Int']['input']>;
  storageGb?: InputMaybe<Scalars['Int']['input']>;
  totalCpuCores?: InputMaybe<Scalars['Int']['input']>;
  totalRamGb?: InputMaybe<Scalars['Int']['input']>;
  totalStorageGb?: InputMaybe<Scalars['Int']['input']>;
};

/** input type for inserting data into table "technology_nodes" */
export type TechnologyNode_Insert_Input = {
  architecture?: InputMaybe<Scalars['system_architecture_kind_enum']['input']>;
  child?: InputMaybe<TechnologyNodeHierarchyMap_Arr_Rel_Insert_Input>;
  code?: InputMaybe<Scalars['String']['input']>;
  components?: InputMaybe<ApplicationComponentTechnologyNodeMap_Arr_Rel_Insert_Input>;
  cpuCores?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  environment?: InputMaybe<Scalars['environment_enum']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  kind?: InputMaybe<Scalars['node_kind_enum']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  network?: InputMaybe<TechnologyNetwork_Obj_Rel_Insert_Input>;
  networkId?: InputMaybe<Scalars['uuid']['input']>;
  node?: InputMaybe<SolutionTechnologyNodeMap_Arr_Rel_Insert_Input>;
  nodeCount?: InputMaybe<Scalars['Int']['input']>;
  operatingSystem?: InputMaybe<SystemSoftware_Obj_Rel_Insert_Input>;
  operatingSystemId?: InputMaybe<Scalars['uuid']['input']>;
  parent?: InputMaybe<TechnologyNodeHierarchyMap_Arr_Rel_Insert_Input>;
  ramGb?: InputMaybe<Scalars['Int']['input']>;
  sourceNode?: InputMaybe<FlowGeneric_Arr_Rel_Insert_Input>;
  storageGb?: InputMaybe<Scalars['Int']['input']>;
  systemSoftware?: InputMaybe<TechnologyNodeSystemSoftwareMap_Arr_Rel_Insert_Input>;
  targetNode?: InputMaybe<FlowGeneric_Arr_Rel_Insert_Input>;
  totalCpuCores?: InputMaybe<Scalars['Int']['input']>;
  totalRamGb?: InputMaybe<Scalars['Int']['input']>;
  totalStorageGb?: InputMaybe<Scalars['Int']['input']>;
  type?: InputMaybe<DirectoryObject_Obj_Rel_Insert_Input>;
  typeId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type TechnologyNode_Max_Fields = {
  __typename?: 'TechnologyNode_max_fields';
  architecture?: Maybe<Scalars['system_architecture_kind_enum']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  cpuCores?: Maybe<Scalars['Int']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  environment?: Maybe<Scalars['environment_enum']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  kind?: Maybe<Scalars['node_kind_enum']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  networkId?: Maybe<Scalars['uuid']['output']>;
  nodeCount?: Maybe<Scalars['Int']['output']>;
  operatingSystemId?: Maybe<Scalars['uuid']['output']>;
  ramGb?: Maybe<Scalars['Int']['output']>;
  storageGb?: Maybe<Scalars['Int']['output']>;
  totalCpuCores?: Maybe<Scalars['Int']['output']>;
  totalRamGb?: Maybe<Scalars['Int']['output']>;
  totalStorageGb?: Maybe<Scalars['Int']['output']>;
  typeId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by max() on columns of table "technology_nodes" */
export type TechnologyNode_Max_Order_By = {
  architecture?: InputMaybe<Order_By>;
  code?: InputMaybe<Order_By>;
  cpuCores?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  environment?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  kind?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  networkId?: InputMaybe<Order_By>;
  nodeCount?: InputMaybe<Order_By>;
  operatingSystemId?: InputMaybe<Order_By>;
  ramGb?: InputMaybe<Order_By>;
  storageGb?: InputMaybe<Order_By>;
  totalCpuCores?: InputMaybe<Order_By>;
  totalRamGb?: InputMaybe<Order_By>;
  totalStorageGb?: InputMaybe<Order_By>;
  typeId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type TechnologyNode_Min_Fields = {
  __typename?: 'TechnologyNode_min_fields';
  architecture?: Maybe<Scalars['system_architecture_kind_enum']['output']>;
  code?: Maybe<Scalars['String']['output']>;
  cpuCores?: Maybe<Scalars['Int']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  environment?: Maybe<Scalars['environment_enum']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  kind?: Maybe<Scalars['node_kind_enum']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  networkId?: Maybe<Scalars['uuid']['output']>;
  nodeCount?: Maybe<Scalars['Int']['output']>;
  operatingSystemId?: Maybe<Scalars['uuid']['output']>;
  ramGb?: Maybe<Scalars['Int']['output']>;
  storageGb?: Maybe<Scalars['Int']['output']>;
  totalCpuCores?: Maybe<Scalars['Int']['output']>;
  totalRamGb?: Maybe<Scalars['Int']['output']>;
  totalStorageGb?: Maybe<Scalars['Int']['output']>;
  typeId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** order by min() on columns of table "technology_nodes" */
export type TechnologyNode_Min_Order_By = {
  architecture?: InputMaybe<Order_By>;
  code?: InputMaybe<Order_By>;
  cpuCores?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  environment?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  kind?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  networkId?: InputMaybe<Order_By>;
  nodeCount?: InputMaybe<Order_By>;
  operatingSystemId?: InputMaybe<Order_By>;
  ramGb?: InputMaybe<Order_By>;
  storageGb?: InputMaybe<Order_By>;
  totalCpuCores?: InputMaybe<Order_By>;
  totalRamGb?: InputMaybe<Order_By>;
  totalStorageGb?: InputMaybe<Order_By>;
  typeId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "technology_nodes" */
export type TechnologyNode_Mutation_Response = {
  __typename?: 'TechnologyNode_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<TechnologyNode>;
};

/** input type for inserting object relation for remote table "technology_nodes" */
export type TechnologyNode_Obj_Rel_Insert_Input = {
  data: TechnologyNode_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<TechnologyNode_On_Conflict>;
};

/** on_conflict condition type for table "technology_nodes" */
export type TechnologyNode_On_Conflict = {
  constraint: TechnologyNode_Constraint;
  update_columns?: Array<TechnologyNode_Update_Column>;
  where?: InputMaybe<TechnologyNode_Bool_Exp>;
};

/** Ordering options when selecting data from "technology_nodes". */
export type TechnologyNode_Order_By = {
  architecture?: InputMaybe<Order_By>;
  child_aggregate?: InputMaybe<TechnologyNodeHierarchyMap_Aggregate_Order_By>;
  code?: InputMaybe<Order_By>;
  components_aggregate?: InputMaybe<ApplicationComponentTechnologyNodeMap_Aggregate_Order_By>;
  cpuCores?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  environment?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  kind?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  network?: InputMaybe<TechnologyNetwork_Order_By>;
  networkId?: InputMaybe<Order_By>;
  nodeCount?: InputMaybe<Order_By>;
  node_aggregate?: InputMaybe<SolutionTechnologyNodeMap_Aggregate_Order_By>;
  operatingSystem?: InputMaybe<SystemSoftware_Order_By>;
  operatingSystemId?: InputMaybe<Order_By>;
  parent_aggregate?: InputMaybe<TechnologyNodeHierarchyMap_Aggregate_Order_By>;
  ramGb?: InputMaybe<Order_By>;
  sourceNode_aggregate?: InputMaybe<FlowGeneric_Aggregate_Order_By>;
  storageGb?: InputMaybe<Order_By>;
  systemSoftware_aggregate?: InputMaybe<TechnologyNodeSystemSoftwareMap_Aggregate_Order_By>;
  targetNode_aggregate?: InputMaybe<FlowGeneric_Aggregate_Order_By>;
  totalCpuCores?: InputMaybe<Order_By>;
  totalRamGb?: InputMaybe<Order_By>;
  totalStorageGb?: InputMaybe<Order_By>;
  type?: InputMaybe<DirectoryObject_Order_By>;
  typeId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: technology_nodes */
export type TechnologyNode_Pk_Columns_Input = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "technology_nodes" */
export enum TechnologyNode_Select_Column {
  /** column name */
  Architecture = 'architecture',
  /** column name */
  Code = 'code',
  /** column name */
  CpuCores = 'cpuCores',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Environment = 'environment',
  /** column name */
  Id = 'id',
  /** column name */
  Kind = 'kind',
  /** column name */
  Name = 'name',
  /** column name */
  NetworkId = 'networkId',
  /** column name */
  NodeCount = 'nodeCount',
  /** column name */
  OperatingSystemId = 'operatingSystemId',
  /** column name */
  RamGb = 'ramGb',
  /** column name */
  StorageGb = 'storageGb',
  /** column name */
  TotalCpuCores = 'totalCpuCores',
  /** column name */
  TotalRamGb = 'totalRamGb',
  /** column name */
  TotalStorageGb = 'totalStorageGb',
  /** column name */
  TypeId = 'typeId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "technology_nodes" */
export type TechnologyNode_Set_Input = {
  architecture?: InputMaybe<Scalars['system_architecture_kind_enum']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  cpuCores?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  environment?: InputMaybe<Scalars['environment_enum']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  kind?: InputMaybe<Scalars['node_kind_enum']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  networkId?: InputMaybe<Scalars['uuid']['input']>;
  nodeCount?: InputMaybe<Scalars['Int']['input']>;
  operatingSystemId?: InputMaybe<Scalars['uuid']['input']>;
  ramGb?: InputMaybe<Scalars['Int']['input']>;
  storageGb?: InputMaybe<Scalars['Int']['input']>;
  totalCpuCores?: InputMaybe<Scalars['Int']['input']>;
  totalRamGb?: InputMaybe<Scalars['Int']['input']>;
  totalStorageGb?: InputMaybe<Scalars['Int']['input']>;
  typeId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate stddev on columns */
export type TechnologyNode_Stddev_Fields = {
  __typename?: 'TechnologyNode_stddev_fields';
  cpuCores?: Maybe<Scalars['Float']['output']>;
  nodeCount?: Maybe<Scalars['Float']['output']>;
  ramGb?: Maybe<Scalars['Float']['output']>;
  storageGb?: Maybe<Scalars['Float']['output']>;
  totalCpuCores?: Maybe<Scalars['Float']['output']>;
  totalRamGb?: Maybe<Scalars['Float']['output']>;
  totalStorageGb?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev() on columns of table "technology_nodes" */
export type TechnologyNode_Stddev_Order_By = {
  cpuCores?: InputMaybe<Order_By>;
  nodeCount?: InputMaybe<Order_By>;
  ramGb?: InputMaybe<Order_By>;
  storageGb?: InputMaybe<Order_By>;
  totalCpuCores?: InputMaybe<Order_By>;
  totalRamGb?: InputMaybe<Order_By>;
  totalStorageGb?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type TechnologyNode_Stddev_Pop_Fields = {
  __typename?: 'TechnologyNode_stddev_pop_fields';
  cpuCores?: Maybe<Scalars['Float']['output']>;
  nodeCount?: Maybe<Scalars['Float']['output']>;
  ramGb?: Maybe<Scalars['Float']['output']>;
  storageGb?: Maybe<Scalars['Float']['output']>;
  totalCpuCores?: Maybe<Scalars['Float']['output']>;
  totalRamGb?: Maybe<Scalars['Float']['output']>;
  totalStorageGb?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_pop() on columns of table "technology_nodes" */
export type TechnologyNode_Stddev_Pop_Order_By = {
  cpuCores?: InputMaybe<Order_By>;
  nodeCount?: InputMaybe<Order_By>;
  ramGb?: InputMaybe<Order_By>;
  storageGb?: InputMaybe<Order_By>;
  totalCpuCores?: InputMaybe<Order_By>;
  totalRamGb?: InputMaybe<Order_By>;
  totalStorageGb?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type TechnologyNode_Stddev_Samp_Fields = {
  __typename?: 'TechnologyNode_stddev_samp_fields';
  cpuCores?: Maybe<Scalars['Float']['output']>;
  nodeCount?: Maybe<Scalars['Float']['output']>;
  ramGb?: Maybe<Scalars['Float']['output']>;
  storageGb?: Maybe<Scalars['Float']['output']>;
  totalCpuCores?: Maybe<Scalars['Float']['output']>;
  totalRamGb?: Maybe<Scalars['Float']['output']>;
  totalStorageGb?: Maybe<Scalars['Float']['output']>;
};

/** order by stddev_samp() on columns of table "technology_nodes" */
export type TechnologyNode_Stddev_Samp_Order_By = {
  cpuCores?: InputMaybe<Order_By>;
  nodeCount?: InputMaybe<Order_By>;
  ramGb?: InputMaybe<Order_By>;
  storageGb?: InputMaybe<Order_By>;
  totalCpuCores?: InputMaybe<Order_By>;
  totalRamGb?: InputMaybe<Order_By>;
  totalStorageGb?: InputMaybe<Order_By>;
};

/** Streaming cursor of the table "TechnologyNode" */
export type TechnologyNode_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: TechnologyNode_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type TechnologyNode_Stream_Cursor_Value_Input = {
  architecture?: InputMaybe<Scalars['system_architecture_kind_enum']['input']>;
  code?: InputMaybe<Scalars['String']['input']>;
  cpuCores?: InputMaybe<Scalars['Int']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  environment?: InputMaybe<Scalars['environment_enum']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  kind?: InputMaybe<Scalars['node_kind_enum']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  networkId?: InputMaybe<Scalars['uuid']['input']>;
  nodeCount?: InputMaybe<Scalars['Int']['input']>;
  operatingSystemId?: InputMaybe<Scalars['uuid']['input']>;
  ramGb?: InputMaybe<Scalars['Int']['input']>;
  storageGb?: InputMaybe<Scalars['Int']['input']>;
  totalCpuCores?: InputMaybe<Scalars['Int']['input']>;
  totalRamGb?: InputMaybe<Scalars['Int']['input']>;
  totalStorageGb?: InputMaybe<Scalars['Int']['input']>;
  typeId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate sum on columns */
export type TechnologyNode_Sum_Fields = {
  __typename?: 'TechnologyNode_sum_fields';
  cpuCores?: Maybe<Scalars['Int']['output']>;
  nodeCount?: Maybe<Scalars['Int']['output']>;
  ramGb?: Maybe<Scalars['Int']['output']>;
  storageGb?: Maybe<Scalars['Int']['output']>;
  totalCpuCores?: Maybe<Scalars['Int']['output']>;
  totalRamGb?: Maybe<Scalars['Int']['output']>;
  totalStorageGb?: Maybe<Scalars['Int']['output']>;
};

/** order by sum() on columns of table "technology_nodes" */
export type TechnologyNode_Sum_Order_By = {
  cpuCores?: InputMaybe<Order_By>;
  nodeCount?: InputMaybe<Order_By>;
  ramGb?: InputMaybe<Order_By>;
  storageGb?: InputMaybe<Order_By>;
  totalCpuCores?: InputMaybe<Order_By>;
  totalRamGb?: InputMaybe<Order_By>;
  totalStorageGb?: InputMaybe<Order_By>;
};

/** update columns of table "technology_nodes" */
export enum TechnologyNode_Update_Column {
  /** column name */
  Architecture = 'architecture',
  /** column name */
  Code = 'code',
  /** column name */
  CpuCores = 'cpuCores',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Environment = 'environment',
  /** column name */
  Id = 'id',
  /** column name */
  Kind = 'kind',
  /** column name */
  Name = 'name',
  /** column name */
  NetworkId = 'networkId',
  /** column name */
  NodeCount = 'nodeCount',
  /** column name */
  OperatingSystemId = 'operatingSystemId',
  /** column name */
  RamGb = 'ramGb',
  /** column name */
  StorageGb = 'storageGb',
  /** column name */
  TotalCpuCores = 'totalCpuCores',
  /** column name */
  TotalRamGb = 'totalRamGb',
  /** column name */
  TotalStorageGb = 'totalStorageGb',
  /** column name */
  TypeId = 'typeId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type TechnologyNode_Updates = {
  /** increments the numeric columns with given value of the filtered values */
  _inc?: InputMaybe<TechnologyNode_Inc_Input>;
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<TechnologyNode_Set_Input>;
  /** filter the rows which have to be updated */
  where: TechnologyNode_Bool_Exp;
};

/** aggregate var_pop on columns */
export type TechnologyNode_Var_Pop_Fields = {
  __typename?: 'TechnologyNode_var_pop_fields';
  cpuCores?: Maybe<Scalars['Float']['output']>;
  nodeCount?: Maybe<Scalars['Float']['output']>;
  ramGb?: Maybe<Scalars['Float']['output']>;
  storageGb?: Maybe<Scalars['Float']['output']>;
  totalCpuCores?: Maybe<Scalars['Float']['output']>;
  totalRamGb?: Maybe<Scalars['Float']['output']>;
  totalStorageGb?: Maybe<Scalars['Float']['output']>;
};

/** order by var_pop() on columns of table "technology_nodes" */
export type TechnologyNode_Var_Pop_Order_By = {
  cpuCores?: InputMaybe<Order_By>;
  nodeCount?: InputMaybe<Order_By>;
  ramGb?: InputMaybe<Order_By>;
  storageGb?: InputMaybe<Order_By>;
  totalCpuCores?: InputMaybe<Order_By>;
  totalRamGb?: InputMaybe<Order_By>;
  totalStorageGb?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type TechnologyNode_Var_Samp_Fields = {
  __typename?: 'TechnologyNode_var_samp_fields';
  cpuCores?: Maybe<Scalars['Float']['output']>;
  nodeCount?: Maybe<Scalars['Float']['output']>;
  ramGb?: Maybe<Scalars['Float']['output']>;
  storageGb?: Maybe<Scalars['Float']['output']>;
  totalCpuCores?: Maybe<Scalars['Float']['output']>;
  totalRamGb?: Maybe<Scalars['Float']['output']>;
  totalStorageGb?: Maybe<Scalars['Float']['output']>;
};

/** order by var_samp() on columns of table "technology_nodes" */
export type TechnologyNode_Var_Samp_Order_By = {
  cpuCores?: InputMaybe<Order_By>;
  nodeCount?: InputMaybe<Order_By>;
  ramGb?: InputMaybe<Order_By>;
  storageGb?: InputMaybe<Order_By>;
  totalCpuCores?: InputMaybe<Order_By>;
  totalRamGb?: InputMaybe<Order_By>;
  totalStorageGb?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type TechnologyNode_Variance_Fields = {
  __typename?: 'TechnologyNode_variance_fields';
  cpuCores?: Maybe<Scalars['Float']['output']>;
  nodeCount?: Maybe<Scalars['Float']['output']>;
  ramGb?: Maybe<Scalars['Float']['output']>;
  storageGb?: Maybe<Scalars['Float']['output']>;
  totalCpuCores?: Maybe<Scalars['Float']['output']>;
  totalRamGb?: Maybe<Scalars['Float']['output']>;
  totalStorageGb?: Maybe<Scalars['Float']['output']>;
};

/** order by variance() on columns of table "technology_nodes" */
export type TechnologyNode_Variance_Order_By = {
  cpuCores?: InputMaybe<Order_By>;
  nodeCount?: InputMaybe<Order_By>;
  ramGb?: InputMaybe<Order_By>;
  storageGb?: InputMaybe<Order_By>;
  totalCpuCores?: InputMaybe<Order_By>;
  totalRamGb?: InputMaybe<Order_By>;
  totalStorageGb?: InputMaybe<Order_By>;
};

/** Boolean expression to compare columns of type "assessment_type_enum". All fields are combined with logical 'AND'. */
export type Assessment_Type_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['assessment_type_enum']['input']>;
  _gt?: InputMaybe<Scalars['assessment_type_enum']['input']>;
  _gte?: InputMaybe<Scalars['assessment_type_enum']['input']>;
  _in?: InputMaybe<Array<Scalars['assessment_type_enum']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['assessment_type_enum']['input']>;
  _lte?: InputMaybe<Scalars['assessment_type_enum']['input']>;
  _neq?: InputMaybe<Scalars['assessment_type_enum']['input']>;
  _nin?: InputMaybe<Array<Scalars['assessment_type_enum']['input']>>;
};

/** Boolean expression to compare columns of type "capability_assessment_type_enum". All fields are combined with logical 'AND'. */
export type Capability_Assessment_Type_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['capability_assessment_type_enum']['input']>;
  _gt?: InputMaybe<Scalars['capability_assessment_type_enum']['input']>;
  _gte?: InputMaybe<Scalars['capability_assessment_type_enum']['input']>;
  _in?: InputMaybe<Array<Scalars['capability_assessment_type_enum']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['capability_assessment_type_enum']['input']>;
  _lte?: InputMaybe<Scalars['capability_assessment_type_enum']['input']>;
  _neq?: InputMaybe<Scalars['capability_assessment_type_enum']['input']>;
  _nin?: InputMaybe<Array<Scalars['capability_assessment_type_enum']['input']>>;
};

/** ordering argument of a cursor */
export enum Cursor_Ordering {
  /** ascending ordering of the cursor */
  Asc = 'ASC',
  /** descending ordering of the cursor */
  Desc = 'DESC'
}

/** Boolean expression to compare columns of type "data_access_kind_enum". All fields are combined with logical 'AND'. */
export type Data_Access_Kind_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['data_access_kind_enum']['input']>;
  _gt?: InputMaybe<Scalars['data_access_kind_enum']['input']>;
  _gte?: InputMaybe<Scalars['data_access_kind_enum']['input']>;
  _in?: InputMaybe<Array<Scalars['data_access_kind_enum']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['data_access_kind_enum']['input']>;
  _lte?: InputMaybe<Scalars['data_access_kind_enum']['input']>;
  _neq?: InputMaybe<Scalars['data_access_kind_enum']['input']>;
  _nin?: InputMaybe<Array<Scalars['data_access_kind_enum']['input']>>;
};

/** Boolean expression to compare columns of type "directory_kind_enum". All fields are combined with logical 'AND'. */
export type Directory_Kind_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['directory_kind_enum']['input']>;
  _gt?: InputMaybe<Scalars['directory_kind_enum']['input']>;
  _gte?: InputMaybe<Scalars['directory_kind_enum']['input']>;
  _in?: InputMaybe<Array<Scalars['directory_kind_enum']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['directory_kind_enum']['input']>;
  _lte?: InputMaybe<Scalars['directory_kind_enum']['input']>;
  _neq?: InputMaybe<Scalars['directory_kind_enum']['input']>;
  _nin?: InputMaybe<Array<Scalars['directory_kind_enum']['input']>>;
};

/** Boolean expression to compare columns of type "directory_link_type_enum". All fields are combined with logical 'AND'. */
export type Directory_Link_Type_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['directory_link_type_enum']['input']>;
  _gt?: InputMaybe<Scalars['directory_link_type_enum']['input']>;
  _gte?: InputMaybe<Scalars['directory_link_type_enum']['input']>;
  _in?: InputMaybe<Array<Scalars['directory_link_type_enum']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['directory_link_type_enum']['input']>;
  _lte?: InputMaybe<Scalars['directory_link_type_enum']['input']>;
  _neq?: InputMaybe<Scalars['directory_link_type_enum']['input']>;
  _nin?: InputMaybe<Array<Scalars['directory_link_type_enum']['input']>>;
};

/** Boolean expression to compare columns of type "environment_enum". All fields are combined with logical 'AND'. */
export type Environment_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['environment_enum']['input']>;
  _gt?: InputMaybe<Scalars['environment_enum']['input']>;
  _gte?: InputMaybe<Scalars['environment_enum']['input']>;
  _in?: InputMaybe<Array<Scalars['environment_enum']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['environment_enum']['input']>;
  _lte?: InputMaybe<Scalars['environment_enum']['input']>;
  _neq?: InputMaybe<Scalars['environment_enum']['input']>;
  _nin?: InputMaybe<Array<Scalars['environment_enum']['input']>>;
};

/** Boolean expression to compare columns of type "interface_method_enum". All fields are combined with logical 'AND'. */
export type Interface_Method_Enum_Array_Comparison_Exp = {
  /** is the array contained in the given array value */
  _contained_in?: InputMaybe<Array<Scalars['interface_method_enum']['input']>>;
  /** does the array contain the given value */
  _contains?: InputMaybe<Array<Scalars['interface_method_enum']['input']>>;
  _eq?: InputMaybe<Array<Scalars['interface_method_enum']['input']>>;
  _gt?: InputMaybe<Array<Scalars['interface_method_enum']['input']>>;
  _gte?: InputMaybe<Array<Scalars['interface_method_enum']['input']>>;
  _in?: InputMaybe<Array<Array<Scalars['interface_method_enum']['input']>>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Array<Scalars['interface_method_enum']['input']>>;
  _lte?: InputMaybe<Array<Scalars['interface_method_enum']['input']>>;
  _neq?: InputMaybe<Array<Scalars['interface_method_enum']['input']>>;
  _nin?: InputMaybe<Array<Array<Scalars['interface_method_enum']['input']>>>;
};

/** Boolean expression to compare columns of type "layer_kind_enum". All fields are combined with logical 'AND'. */
export type Layer_Kind_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['layer_kind_enum']['input']>;
  _gt?: InputMaybe<Scalars['layer_kind_enum']['input']>;
  _gte?: InputMaybe<Scalars['layer_kind_enum']['input']>;
  _in?: InputMaybe<Array<Scalars['layer_kind_enum']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['layer_kind_enum']['input']>;
  _lte?: InputMaybe<Scalars['layer_kind_enum']['input']>;
  _neq?: InputMaybe<Scalars['layer_kind_enum']['input']>;
  _nin?: InputMaybe<Array<Scalars['layer_kind_enum']['input']>>;
};

/** columns and relationships of "map_solution_constraint" */
export type MapSolutionConstraint = {
  __typename?: 'mapSolutionConstraint';
  /** An object relationship */
  constraint: MotivationElementGeneric;
  constraintId: Scalars['uuid']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  /** An object relationship */
  solution: Solution;
  solutionId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "map_solution_constraint" */
export type MapSolutionConstraint_Aggregate = {
  __typename?: 'mapSolutionConstraint_aggregate';
  aggregate?: Maybe<MapSolutionConstraint_Aggregate_Fields>;
  nodes: Array<MapSolutionConstraint>;
};

/** aggregate fields of "map_solution_constraint" */
export type MapSolutionConstraint_Aggregate_Fields = {
  __typename?: 'mapSolutionConstraint_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<MapSolutionConstraint_Max_Fields>;
  min?: Maybe<MapSolutionConstraint_Min_Fields>;
};


/** aggregate fields of "map_solution_constraint" */
export type MapSolutionConstraint_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<MapSolutionConstraint_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "map_solution_constraint". All fields are combined with a logical 'AND'. */
export type MapSolutionConstraint_Bool_Exp = {
  _and?: InputMaybe<Array<MapSolutionConstraint_Bool_Exp>>;
  _not?: InputMaybe<MapSolutionConstraint_Bool_Exp>;
  _or?: InputMaybe<Array<MapSolutionConstraint_Bool_Exp>>;
  constraint?: InputMaybe<MotivationElementGeneric_Bool_Exp>;
  constraintId?: InputMaybe<Uuid_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  solution?: InputMaybe<Solution_Bool_Exp>;
  solutionId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "map_solution_constraint" */
export enum MapSolutionConstraint_Constraint {
  /** unique or primary key constraint on columns "constraint_id", "solution_id" */
  MapSolutionConstraintConstraintIdSolutionIdUnique = 'map_solution_constraint_constraint_id_solution_id_unique',
  /** unique or primary key constraint on columns "constraint_id", "solution_id" */
  MapSolutionConstraintPkey = 'map_solution_constraint_pkey'
}

/** input type for inserting data into table "map_solution_constraint" */
export type MapSolutionConstraint_Insert_Input = {
  constraint?: InputMaybe<MotivationElementGeneric_Obj_Rel_Insert_Input>;
  constraintId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  solution?: InputMaybe<Solution_Obj_Rel_Insert_Input>;
  solutionId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type MapSolutionConstraint_Max_Fields = {
  __typename?: 'mapSolutionConstraint_max_fields';
  constraintId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  solutionId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type MapSolutionConstraint_Min_Fields = {
  __typename?: 'mapSolutionConstraint_min_fields';
  constraintId?: Maybe<Scalars['uuid']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  solutionId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "map_solution_constraint" */
export type MapSolutionConstraint_Mutation_Response = {
  __typename?: 'mapSolutionConstraint_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<MapSolutionConstraint>;
};

/** on_conflict condition type for table "map_solution_constraint" */
export type MapSolutionConstraint_On_Conflict = {
  constraint: MapSolutionConstraint_Constraint;
  update_columns?: Array<MapSolutionConstraint_Update_Column>;
  where?: InputMaybe<MapSolutionConstraint_Bool_Exp>;
};

/** Ordering options when selecting data from "map_solution_constraint". */
export type MapSolutionConstraint_Order_By = {
  constraint?: InputMaybe<MotivationElementGeneric_Order_By>;
  constraintId?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  solution?: InputMaybe<Solution_Order_By>;
  solutionId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: map_solution_constraint */
export type MapSolutionConstraint_Pk_Columns_Input = {
  constraintId: Scalars['uuid']['input'];
  solutionId: Scalars['uuid']['input'];
};

/** select columns of table "map_solution_constraint" */
export enum MapSolutionConstraint_Select_Column {
  /** column name */
  ConstraintId = 'constraintId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  SolutionId = 'solutionId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "map_solution_constraint" */
export type MapSolutionConstraint_Set_Input = {
  constraintId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  solutionId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "mapSolutionConstraint" */
export type MapSolutionConstraint_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: MapSolutionConstraint_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type MapSolutionConstraint_Stream_Cursor_Value_Input = {
  constraintId?: InputMaybe<Scalars['uuid']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  solutionId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "map_solution_constraint" */
export enum MapSolutionConstraint_Update_Column {
  /** column name */
  ConstraintId = 'constraintId',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  SolutionId = 'solutionId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type MapSolutionConstraint_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<MapSolutionConstraint_Set_Input>;
  /** filter the rows which have to be updated */
  where: MapSolutionConstraint_Bool_Exp;
};

/** columns and relationships of "map_tenant_user_profiles" */
export type MapTenantUserProfiles = {
  __typename?: 'mapTenantUserProfiles';
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  tenantId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
  userId: Scalars['uuid']['output'];
};

/** aggregated selection of "map_tenant_user_profiles" */
export type MapTenantUserProfiles_Aggregate = {
  __typename?: 'mapTenantUserProfiles_aggregate';
  aggregate?: Maybe<MapTenantUserProfiles_Aggregate_Fields>;
  nodes: Array<MapTenantUserProfiles>;
};

/** aggregate fields of "map_tenant_user_profiles" */
export type MapTenantUserProfiles_Aggregate_Fields = {
  __typename?: 'mapTenantUserProfiles_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<MapTenantUserProfiles_Max_Fields>;
  min?: Maybe<MapTenantUserProfiles_Min_Fields>;
};


/** aggregate fields of "map_tenant_user_profiles" */
export type MapTenantUserProfiles_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<MapTenantUserProfiles_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "map_tenant_user_profiles". All fields are combined with a logical 'AND'. */
export type MapTenantUserProfiles_Bool_Exp = {
  _and?: InputMaybe<Array<MapTenantUserProfiles_Bool_Exp>>;
  _not?: InputMaybe<MapTenantUserProfiles_Bool_Exp>;
  _or?: InputMaybe<Array<MapTenantUserProfiles_Bool_Exp>>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  tenantId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
  userId?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "map_tenant_user_profiles" */
export enum MapTenantUserProfiles_Constraint {
  /** unique or primary key constraint on columns "user_id" */
  MapTenantUserProfilesPkey = 'map_tenant_user_profiles_pkey'
}

/** input type for inserting data into table "map_tenant_user_profiles" */
export type MapTenantUserProfiles_Insert_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type MapTenantUserProfiles_Max_Fields = {
  __typename?: 'mapTenantUserProfiles_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type MapTenantUserProfiles_Min_Fields = {
  __typename?: 'mapTenantUserProfiles_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  tenantId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
  userId?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "map_tenant_user_profiles" */
export type MapTenantUserProfiles_Mutation_Response = {
  __typename?: 'mapTenantUserProfiles_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<MapTenantUserProfiles>;
};

/** on_conflict condition type for table "map_tenant_user_profiles" */
export type MapTenantUserProfiles_On_Conflict = {
  constraint: MapTenantUserProfiles_Constraint;
  update_columns?: Array<MapTenantUserProfiles_Update_Column>;
  where?: InputMaybe<MapTenantUserProfiles_Bool_Exp>;
};

/** Ordering options when selecting data from "map_tenant_user_profiles". */
export type MapTenantUserProfiles_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  tenantId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
  userId?: InputMaybe<Order_By>;
};

/** primary key columns input for table: map_tenant_user_profiles */
export type MapTenantUserProfiles_Pk_Columns_Input = {
  userId: Scalars['uuid']['input'];
};

/** select columns of table "map_tenant_user_profiles" */
export enum MapTenantUserProfiles_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy',
  /** column name */
  UserId = 'userId'
}

/** input type for updating data in table "map_tenant_user_profiles" */
export type MapTenantUserProfiles_Set_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "mapTenantUserProfiles" */
export type MapTenantUserProfiles_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: MapTenantUserProfiles_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type MapTenantUserProfiles_Stream_Cursor_Value_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  tenantId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
  userId?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "map_tenant_user_profiles" */
export enum MapTenantUserProfiles_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  TenantId = 'tenantId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy',
  /** column name */
  UserId = 'userId'
}

export type MapTenantUserProfiles_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<MapTenantUserProfiles_Set_Input>;
  /** filter the rows which have to be updated */
  where: MapTenantUserProfiles_Bool_Exp;
};

/** Boolean expression to compare columns of type "motivation_kind_enum". All fields are combined with logical 'AND'. */
export type Motivation_Kind_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['motivation_kind_enum']['input']>;
  _gt?: InputMaybe<Scalars['motivation_kind_enum']['input']>;
  _gte?: InputMaybe<Scalars['motivation_kind_enum']['input']>;
  _in?: InputMaybe<Array<Scalars['motivation_kind_enum']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['motivation_kind_enum']['input']>;
  _lte?: InputMaybe<Scalars['motivation_kind_enum']['input']>;
  _neq?: InputMaybe<Scalars['motivation_kind_enum']['input']>;
  _nin?: InputMaybe<Array<Scalars['motivation_kind_enum']['input']>>;
};

/** Boolean expression to compare columns of type "motivation_priority_enum". All fields are combined with logical 'AND'. */
export type Motivation_Priority_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['motivation_priority_enum']['input']>;
  _gt?: InputMaybe<Scalars['motivation_priority_enum']['input']>;
  _gte?: InputMaybe<Scalars['motivation_priority_enum']['input']>;
  _in?: InputMaybe<Array<Scalars['motivation_priority_enum']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['motivation_priority_enum']['input']>;
  _lte?: InputMaybe<Scalars['motivation_priority_enum']['input']>;
  _neq?: InputMaybe<Scalars['motivation_priority_enum']['input']>;
  _nin?: InputMaybe<Array<Scalars['motivation_priority_enum']['input']>>;
};

/** Boolean expression to compare columns of type "motivation_status_enum". All fields are combined with logical 'AND'. */
export type Motivation_Status_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['motivation_status_enum']['input']>;
  _gt?: InputMaybe<Scalars['motivation_status_enum']['input']>;
  _gte?: InputMaybe<Scalars['motivation_status_enum']['input']>;
  _in?: InputMaybe<Array<Scalars['motivation_status_enum']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['motivation_status_enum']['input']>;
  _lte?: InputMaybe<Scalars['motivation_status_enum']['input']>;
  _neq?: InputMaybe<Scalars['motivation_status_enum']['input']>;
  _nin?: InputMaybe<Array<Scalars['motivation_status_enum']['input']>>;
};

/** mutation root */
export type Mutation_Root = {
  __typename?: 'mutation_root';
  /** delete data from the table: "components" */
  deleteApplicationComponent?: Maybe<ApplicationComponent_Mutation_Response>;
  /** delete data from the table: "map_application_component_actor_role" */
  deleteApplicationComponentBusinessActorRoleMap?: Maybe<ApplicationComponentBusinessActorRoleMap_Mutation_Response>;
  /** delete single row from the table: "map_application_component_actor_role" */
  deleteApplicationComponentBusinessActorRoleMapByPk?: Maybe<ApplicationComponentBusinessActorRoleMap>;
  /** delete single row from the table: "components" */
  deleteApplicationComponentByPk?: Maybe<ApplicationComponent>;
  /** delete data from the table: "map_application_component_data_object" */
  deleteApplicationComponentDataObjectMap?: Maybe<ApplicationComponentDataObjectMap_Mutation_Response>;
  /** delete single row from the table: "map_application_component_data_object" */
  deleteApplicationComponentDataObjectMapByPk?: Maybe<ApplicationComponentDataObjectMap>;
  /** delete data from the table: "map_application_component_directory" */
  deleteApplicationComponentDirectoryMap?: Maybe<ApplicationComponentDirectoryMap_Mutation_Response>;
  /** delete single row from the table: "map_application_component_directory" */
  deleteApplicationComponentDirectoryMapByPk?: Maybe<ApplicationComponentDirectoryMap>;
  /** delete data from the table: "map_application_component_event" */
  deleteApplicationComponentEventMap?: Maybe<ApplicationComponentEventMap_Mutation_Response>;
  /** delete single row from the table: "map_application_component_event" */
  deleteApplicationComponentEventMapByPk?: Maybe<ApplicationComponentEventMap>;
  /** delete data from the table: "map_application_component_function" */
  deleteApplicationComponentFunctionMap?: Maybe<ApplicationComponentFunctionMap_Mutation_Response>;
  /** delete single row from the table: "map_application_component_function" */
  deleteApplicationComponentFunctionMapByPk?: Maybe<ApplicationComponentFunctionMap>;
  /** delete data from the table: "map_application_component_hierarchy" */
  deleteApplicationComponentHierarchyMap?: Maybe<ApplicationComponentHierarchyMap_Mutation_Response>;
  /** delete single row from the table: "map_application_component_hierarchy" */
  deleteApplicationComponentHierarchyMapByPk?: Maybe<ApplicationComponentHierarchyMap>;
  /** delete data from the table: "map_application_component_interface" */
  deleteApplicationComponentInterfaceMap?: Maybe<ApplicationComponentInterfaceMap_Mutation_Response>;
  /** delete single row from the table: "map_application_component_interface" */
  deleteApplicationComponentInterfaceMapByPk?: Maybe<ApplicationComponentInterfaceMap>;
  /** delete data from the table: "map_application_component_product" */
  deleteApplicationComponentProductMap?: Maybe<ApplicationComponentProductMap_Mutation_Response>;
  /** delete single row from the table: "map_application_component_product" */
  deleteApplicationComponentProductMapByPk?: Maybe<ApplicationComponentProductMap>;
  /** delete data from the table: "map_application_component_stakeholder" */
  deleteApplicationComponentStakeholderMap?: Maybe<ApplicationComponentStakeholderMap_Mutation_Response>;
  /** delete single row from the table: "map_application_component_stakeholder" */
  deleteApplicationComponentStakeholderMapByPk?: Maybe<ApplicationComponentStakeholderMap>;
  /** delete data from the table: "map_application_component_system_software" */
  deleteApplicationComponentSystemSoftwareMap?: Maybe<ApplicationComponentSystemSoftwareMap_Mutation_Response>;
  /** delete single row from the table: "map_application_component_system_software" */
  deleteApplicationComponentSystemSoftwareMapByPk?: Maybe<ApplicationComponentSystemSoftwareMap>;
  /** delete data from the table: "map_application_component_technology_logical_network" */
  deleteApplicationComponentTechnologyLogicalNetworkMap?: Maybe<ApplicationComponentTechnologyLogicalNetworkMap_Mutation_Response>;
  /** delete single row from the table: "map_application_component_technology_logical_network" */
  deleteApplicationComponentTechnologyLogicalNetworkMapByPk?: Maybe<ApplicationComponentTechnologyLogicalNetworkMap>;
  /** delete data from the table: "map_application_component_technology_node" */
  deleteApplicationComponentTechnologyNodeMap?: Maybe<ApplicationComponentTechnologyNodeMap_Mutation_Response>;
  /** delete single row from the table: "map_application_component_technology_node" */
  deleteApplicationComponentTechnologyNodeMapByPk?: Maybe<ApplicationComponentTechnologyNodeMap>;
  /** delete data from the table: "map_application_function_data_object" */
  deleteApplicationFunctionDataObjectMap?: Maybe<ApplicationFunctionDataObjectMap_Mutation_Response>;
  /** delete single row from the table: "map_application_function_data_object" */
  deleteApplicationFunctionDataObjectMapByPk?: Maybe<ApplicationFunctionDataObjectMap>;
  /** delete data from the table: "map_application_interface_function" */
  deleteApplicationFunctionInterfaceMap?: Maybe<ApplicationFunctionInterfaceMap_Mutation_Response>;
  /** delete single row from the table: "map_application_interface_function" */
  deleteApplicationFunctionInterfaceMapByPk?: Maybe<ApplicationFunctionInterfaceMap>;
  /** delete data from the table: "actors" */
  deleteBusinessActor?: Maybe<BusinessActor_Mutation_Response>;
  /** delete single row from the table: "actors" */
  deleteBusinessActorByPk?: Maybe<BusinessActor>;
  /** delete data from the table: "map_business_actor_role" */
  deleteBusinessActorRoleMap?: Maybe<BusinessActorRoleMap_Mutation_Response>;
  /** delete single row from the table: "map_business_actor_role" */
  deleteBusinessActorRoleMapByPk?: Maybe<BusinessActorRoleMap>;
  /** delete data from the table: "map_business_process_function" */
  deleteBusinessProcessFunctionMap?: Maybe<BusinessProcessFunctionMap_Mutation_Response>;
  /** delete single row from the table: "map_business_process_function" */
  deleteBusinessProcessFunctionMapByPk?: Maybe<BusinessProcessFunctionMap>;
  /** delete data from the table: "map_business_process_hierarchy" */
  deleteBusinessProcessHierarchyMap?: Maybe<BusinessProcessHierarchyMap_Mutation_Response>;
  /** delete single row from the table: "map_business_process_hierarchy" */
  deleteBusinessProcessHierarchyMapByPk?: Maybe<BusinessProcessHierarchyMap>;
  /** delete data from the table: "map_business_process_motivation_item" */
  deleteBusinessProcessMotivationItemMap?: Maybe<BusinessProcessMotivationItemMap_Mutation_Response>;
  /** delete single row from the table: "map_business_process_motivation_item" */
  deleteBusinessProcessMotivationItemMapByPk?: Maybe<BusinessProcessMotivationItemMap>;
  /** delete data from the table: "products" */
  deleteBusinessProduct?: Maybe<BusinessProduct_Mutation_Response>;
  /** delete single row from the table: "products" */
  deleteBusinessProductByPk?: Maybe<BusinessProduct>;
  /** delete data from the table: "roles" */
  deleteBusinessRole?: Maybe<BusinessRole_Mutation_Response>;
  /** delete single row from the table: "roles" */
  deleteBusinessRoleByPk?: Maybe<BusinessRole>;
  /** delete data from the table: "capabilities" */
  deleteCapability?: Maybe<Capability_Mutation_Response>;
  /** delete data from the table: "map_capability_application_component_assessment" */
  deleteCapabilityApplicationComponentAssessmentMap?: Maybe<CapabilityApplicationComponentAssessmentMap_Mutation_Response>;
  /** delete single row from the table: "map_capability_application_component_assessment" */
  deleteCapabilityApplicationComponentAssessmentMapByPk?: Maybe<CapabilityApplicationComponentAssessmentMap>;
  /** delete data from the table: "map_capability_application_component" */
  deleteCapabilityApplicationComponentMap?: Maybe<CapabilityApplicationComponentMap_Mutation_Response>;
  /** delete single row from the table: "map_capability_application_component" */
  deleteCapabilityApplicationComponentMapByPk?: Maybe<CapabilityApplicationComponentMap>;
  /** delete data from the table: "map_capability_business_process_assessment" */
  deleteCapabilityBusinessProcessAssessmentMap?: Maybe<CapabilityBusinessProcessAssessmentMap_Mutation_Response>;
  /** delete single row from the table: "map_capability_business_process_assessment" */
  deleteCapabilityBusinessProcessAssessmentMapByPk?: Maybe<CapabilityBusinessProcessAssessmentMap>;
  /** delete data from the table: "map_capability_business_process" */
  deleteCapabilityBusinessProcessMap?: Maybe<CapabilityBusinessProcessMap_Mutation_Response>;
  /** delete single row from the table: "map_capability_business_process" */
  deleteCapabilityBusinessProcessMapByPk?: Maybe<CapabilityBusinessProcessMap>;
  /** delete single row from the table: "capabilities" */
  deleteCapabilityByPk?: Maybe<Capability>;
  /** delete data from the table: "map_capability_hierarchy" */
  deleteCapabilityHierarchyMap?: Maybe<CapabilityHierarchyMap_Mutation_Response>;
  /** delete single row from the table: "map_capability_hierarchy" */
  deleteCapabilityHierarchyMapByPk?: Maybe<CapabilityHierarchyMap>;
  /** delete data from the table: "data_objects" */
  deleteDataObject?: Maybe<DataObject_Mutation_Response>;
  /** delete single row from the table: "data_objects" */
  deleteDataObjectByPk?: Maybe<DataObject>;
  /** delete data from the table: "map_directory_items" */
  deleteDirectoryItemsMap?: Maybe<DirectoryItemsMap_Mutation_Response>;
  /** delete single row from the table: "map_directory_items" */
  deleteDirectoryItemsMapByPk?: Maybe<DirectoryItemsMap>;
  /** delete data from the table: "directories" */
  deleteDirectoryObject?: Maybe<DirectoryObject_Mutation_Response>;
  /** delete single row from the table: "directories" */
  deleteDirectoryObjectByPk?: Maybe<DirectoryObject>;
  /** delete data from the table: "employees" */
  deleteEmployee?: Maybe<Employee_Mutation_Response>;
  /** delete single row from the table: "employees" */
  deleteEmployeeByPk?: Maybe<Employee>;
  /** delete data from the table: "events" */
  deleteEventGeneric?: Maybe<EventGeneric_Mutation_Response>;
  /** delete single row from the table: "events" */
  deleteEventGenericByPk?: Maybe<EventGeneric>;
  /** delete data from the table: "flows" */
  deleteFlowGeneric?: Maybe<FlowGeneric_Mutation_Response>;
  /** delete single row from the table: "flows" */
  deleteFlowGenericByPk?: Maybe<FlowGeneric>;
  /** delete data from the table: "functions" */
  deleteFunctionGeneric?: Maybe<FunctionGeneric_Mutation_Response>;
  /** delete single row from the table: "functions" */
  deleteFunctionGenericByPk?: Maybe<FunctionGeneric>;
  /** delete data from the table: "interfaces" */
  deleteInterfaceGeneric?: Maybe<InterfaceGeneric_Mutation_Response>;
  /** delete single row from the table: "interfaces" */
  deleteInterfaceGenericByPk?: Maybe<InterfaceGeneric>;
  /** delete data from the table: "motivations" */
  deleteMotivationElementGeneric?: Maybe<MotivationElementGeneric_Mutation_Response>;
  /** delete single row from the table: "motivations" */
  deleteMotivationElementGenericByPk?: Maybe<MotivationElementGeneric>;
  /** delete data from the table: "map_motivation_item_hierarchy" */
  deleteMotivationItemHierarchyMap?: Maybe<MotivationItemHierarchyMap_Mutation_Response>;
  /** delete single row from the table: "map_motivation_item_hierarchy" */
  deleteMotivationItemHierarchyMapByPk?: Maybe<MotivationItemHierarchyMap>;
  /** delete data from the table: "locations" */
  deletePhysicalLocation?: Maybe<PhysicalLocation_Mutation_Response>;
  /** delete single row from the table: "locations" */
  deletePhysicalLocationByPk?: Maybe<PhysicalLocation>;
  /** delete data from the table: "plateaus" */
  deletePlateau?: Maybe<Plateau_Mutation_Response>;
  /** delete single row from the table: "plateaus" */
  deletePlateauByPk?: Maybe<Plateau>;
  /** delete data from the table: "processes" */
  deleteProcessGeneric?: Maybe<ProcessGeneric_Mutation_Response>;
  /** delete single row from the table: "processes" */
  deleteProcessGenericByPk?: Maybe<ProcessGeneric>;
  /** delete data from the table: "services" */
  deleteServiceGeneric?: Maybe<ServiceGeneric_Mutation_Response>;
  /** delete single row from the table: "services" */
  deleteServiceGenericByPk?: Maybe<ServiceGeneric>;
  /** delete data from the table: "solutions" */
  deleteSolution?: Maybe<Solution_Mutation_Response>;
  /** delete data from the table: "map_solution_application_component" */
  deleteSolutionApplicationComponentMap?: Maybe<SolutionApplicationComponentMap_Mutation_Response>;
  /** delete single row from the table: "map_solution_application_component" */
  deleteSolutionApplicationComponentMapByPk?: Maybe<SolutionApplicationComponentMap>;
  /** delete data from the table: "map_solution_application_function" */
  deleteSolutionApplicationFunctionMap?: Maybe<SolutionApplicationFunctionMap_Mutation_Response>;
  /** delete single row from the table: "map_solution_application_function" */
  deleteSolutionApplicationFunctionMapByPk?: Maybe<SolutionApplicationFunctionMap>;
  /** delete single row from the table: "solutions" */
  deleteSolutionByPk?: Maybe<Solution>;
  /** delete data from the table: "map_solution_data_object" */
  deleteSolutionDataObjectMap?: Maybe<SolutionDataObjectMap_Mutation_Response>;
  /** delete single row from the table: "map_solution_data_object" */
  deleteSolutionDataObjectMapByPk?: Maybe<SolutionDataObjectMap>;
  /** delete data from the table: "map_solution_flow" */
  deleteSolutionFlowMap?: Maybe<SolutionFlowMap_Mutation_Response>;
  /** delete single row from the table: "map_solution_flow" */
  deleteSolutionFlowMapByPk?: Maybe<SolutionFlowMap>;
  /** delete data from the table: "map_solution_motivation_component" */
  deleteSolutionMotivationComponentMap?: Maybe<SolutionMotivationComponentMap_Mutation_Response>;
  /** delete single row from the table: "map_solution_motivation_component" */
  deleteSolutionMotivationComponentMapByPk?: Maybe<SolutionMotivationComponentMap>;
  /** delete data from the table: "map_solution_motivation" */
  deleteSolutionMotivationElementMap?: Maybe<SolutionMotivationElementMap_Mutation_Response>;
  /** delete single row from the table: "map_solution_motivation" */
  deleteSolutionMotivationElementMapByPk?: Maybe<SolutionMotivationElementMap>;
  /** delete data from the table: "map_solution_stakeholder" */
  deleteSolutionStakeholderMap?: Maybe<SolutionStakeholderMap_Mutation_Response>;
  /** delete single row from the table: "map_solution_stakeholder" */
  deleteSolutionStakeholderMapByPk?: Maybe<SolutionStakeholderMap>;
  /** delete data from the table: "map_solution_technology_node" */
  deleteSolutionTechnologyNodeMap?: Maybe<SolutionTechnologyNodeMap_Mutation_Response>;
  /** delete single row from the table: "map_solution_technology_node" */
  deleteSolutionTechnologyNodeMapByPk?: Maybe<SolutionTechnologyNodeMap>;
  /** delete data from the table: "stakeholders" */
  deleteStakeholder?: Maybe<Stakeholder_Mutation_Response>;
  /** delete single row from the table: "stakeholders" */
  deleteStakeholderByPk?: Maybe<Stakeholder>;
  /** delete data from the table: "system_software" */
  deleteSystemSoftware?: Maybe<SystemSoftware_Mutation_Response>;
  /** delete single row from the table: "system_software" */
  deleteSystemSoftwareByPk?: Maybe<SystemSoftware>;
  /** delete data from the table: "technology_networks" */
  deleteTechnologyNetwork?: Maybe<TechnologyNetwork_Mutation_Response>;
  /** delete single row from the table: "technology_networks" */
  deleteTechnologyNetworkByPk?: Maybe<TechnologyNetwork>;
  /** delete data from the table: "map_technology_network_hierarchy" */
  deleteTechnologyNetworkHierarchyMap?: Maybe<TechnologyNetworkHierarchyMap_Mutation_Response>;
  /** delete single row from the table: "map_technology_network_hierarchy" */
  deleteTechnologyNetworkHierarchyMapByPk?: Maybe<TechnologyNetworkHierarchyMap>;
  /** delete data from the table: "technology_nodes" */
  deleteTechnologyNode?: Maybe<TechnologyNode_Mutation_Response>;
  /** delete single row from the table: "technology_nodes" */
  deleteTechnologyNodeByPk?: Maybe<TechnologyNode>;
  /** delete data from the table: "map_technology_node_hierarchy" */
  deleteTechnologyNodeHierarchyMap?: Maybe<TechnologyNodeHierarchyMap_Mutation_Response>;
  /** delete single row from the table: "map_technology_node_hierarchy" */
  deleteTechnologyNodeHierarchyMapByPk?: Maybe<TechnologyNodeHierarchyMap>;
  /** delete data from the table: "map_technology_node_system_software" */
  deleteTechnologyNodeSystemSoftwareMap?: Maybe<TechnologyNodeSystemSoftwareMap_Mutation_Response>;
  /** delete single row from the table: "map_technology_node_system_software" */
  deleteTechnologyNodeSystemSoftwareMapByPk?: Maybe<TechnologyNodeSystemSoftwareMap>;
  /** delete data from the table: "map_solution_constraint" */
  delete_mapSolutionConstraint?: Maybe<MapSolutionConstraint_Mutation_Response>;
  /** delete single row from the table: "map_solution_constraint" */
  delete_mapSolutionConstraint_by_pk?: Maybe<MapSolutionConstraint>;
  /** delete data from the table: "map_tenant_user_profiles" */
  delete_mapTenantUserProfiles?: Maybe<MapTenantUserProfiles_Mutation_Response>;
  /** delete single row from the table: "map_tenant_user_profiles" */
  delete_mapTenantUserProfiles_by_pk?: Maybe<MapTenantUserProfiles>;
  /** delete data from the table: "tenants" */
  delete_tenants?: Maybe<Tenants_Mutation_Response>;
  /** delete single row from the table: "tenants" */
  delete_tenants_by_pk?: Maybe<Tenants>;
  /** delete data from the table: "user_profiles" */
  delete_userProfiles?: Maybe<UserProfiles_Mutation_Response>;
  /** delete single row from the table: "user_profiles" */
  delete_userProfiles_by_pk?: Maybe<UserProfiles>;
  /** insert data into the table: "components" */
  insertApplicationComponent?: Maybe<ApplicationComponent_Mutation_Response>;
  /** insert data into the table: "map_application_component_actor_role" */
  insertApplicationComponentBusinessActorRoleMap?: Maybe<ApplicationComponentBusinessActorRoleMap_Mutation_Response>;
  /** insert a single row into the table: "map_application_component_actor_role" */
  insertApplicationComponentBusinessActorRoleMapOne?: Maybe<ApplicationComponentBusinessActorRoleMap>;
  /** insert data into the table: "map_application_component_data_object" */
  insertApplicationComponentDataObjectMap?: Maybe<ApplicationComponentDataObjectMap_Mutation_Response>;
  /** insert a single row into the table: "map_application_component_data_object" */
  insertApplicationComponentDataObjectMapOne?: Maybe<ApplicationComponentDataObjectMap>;
  /** insert data into the table: "map_application_component_directory" */
  insertApplicationComponentDirectoryMap?: Maybe<ApplicationComponentDirectoryMap_Mutation_Response>;
  /** insert a single row into the table: "map_application_component_directory" */
  insertApplicationComponentDirectoryMapOne?: Maybe<ApplicationComponentDirectoryMap>;
  /** insert data into the table: "map_application_component_event" */
  insertApplicationComponentEventMap?: Maybe<ApplicationComponentEventMap_Mutation_Response>;
  /** insert a single row into the table: "map_application_component_event" */
  insertApplicationComponentEventMapOne?: Maybe<ApplicationComponentEventMap>;
  /** insert data into the table: "map_application_component_function" */
  insertApplicationComponentFunctionMap?: Maybe<ApplicationComponentFunctionMap_Mutation_Response>;
  /** insert a single row into the table: "map_application_component_function" */
  insertApplicationComponentFunctionMapOne?: Maybe<ApplicationComponentFunctionMap>;
  /** insert data into the table: "map_application_component_hierarchy" */
  insertApplicationComponentHierarchyMap?: Maybe<ApplicationComponentHierarchyMap_Mutation_Response>;
  /** insert a single row into the table: "map_application_component_hierarchy" */
  insertApplicationComponentHierarchyMapOne?: Maybe<ApplicationComponentHierarchyMap>;
  /** insert data into the table: "map_application_component_interface" */
  insertApplicationComponentInterfaceMap?: Maybe<ApplicationComponentInterfaceMap_Mutation_Response>;
  /** insert a single row into the table: "map_application_component_interface" */
  insertApplicationComponentInterfaceMapOne?: Maybe<ApplicationComponentInterfaceMap>;
  /** insert a single row into the table: "components" */
  insertApplicationComponentOne?: Maybe<ApplicationComponent>;
  /** insert data into the table: "map_application_component_product" */
  insertApplicationComponentProductMap?: Maybe<ApplicationComponentProductMap_Mutation_Response>;
  /** insert a single row into the table: "map_application_component_product" */
  insertApplicationComponentProductMapOne?: Maybe<ApplicationComponentProductMap>;
  /** insert data into the table: "map_application_component_stakeholder" */
  insertApplicationComponentStakeholderMap?: Maybe<ApplicationComponentStakeholderMap_Mutation_Response>;
  /** insert a single row into the table: "map_application_component_stakeholder" */
  insertApplicationComponentStakeholderMapOne?: Maybe<ApplicationComponentStakeholderMap>;
  /** insert data into the table: "map_application_component_system_software" */
  insertApplicationComponentSystemSoftwareMap?: Maybe<ApplicationComponentSystemSoftwareMap_Mutation_Response>;
  /** insert a single row into the table: "map_application_component_system_software" */
  insertApplicationComponentSystemSoftwareMapOne?: Maybe<ApplicationComponentSystemSoftwareMap>;
  /** insert data into the table: "map_application_component_technology_logical_network" */
  insertApplicationComponentTechnologyLogicalNetworkMap?: Maybe<ApplicationComponentTechnologyLogicalNetworkMap_Mutation_Response>;
  /** insert a single row into the table: "map_application_component_technology_logical_network" */
  insertApplicationComponentTechnologyLogicalNetworkMapOne?: Maybe<ApplicationComponentTechnologyLogicalNetworkMap>;
  /** insert data into the table: "map_application_component_technology_node" */
  insertApplicationComponentTechnologyNodeMap?: Maybe<ApplicationComponentTechnologyNodeMap_Mutation_Response>;
  /** insert a single row into the table: "map_application_component_technology_node" */
  insertApplicationComponentTechnologyNodeMapOne?: Maybe<ApplicationComponentTechnologyNodeMap>;
  /** insert data into the table: "map_application_function_data_object" */
  insertApplicationFunctionDataObjectMap?: Maybe<ApplicationFunctionDataObjectMap_Mutation_Response>;
  /** insert a single row into the table: "map_application_function_data_object" */
  insertApplicationFunctionDataObjectMapOne?: Maybe<ApplicationFunctionDataObjectMap>;
  /** insert data into the table: "map_application_interface_function" */
  insertApplicationFunctionInterfaceMap?: Maybe<ApplicationFunctionInterfaceMap_Mutation_Response>;
  /** insert a single row into the table: "map_application_interface_function" */
  insertApplicationFunctionInterfaceMapOne?: Maybe<ApplicationFunctionInterfaceMap>;
  /** insert data into the table: "actors" */
  insertBusinessActor?: Maybe<BusinessActor_Mutation_Response>;
  /** insert a single row into the table: "actors" */
  insertBusinessActorOne?: Maybe<BusinessActor>;
  /** insert data into the table: "map_business_actor_role" */
  insertBusinessActorRoleMap?: Maybe<BusinessActorRoleMap_Mutation_Response>;
  /** insert a single row into the table: "map_business_actor_role" */
  insertBusinessActorRoleMapOne?: Maybe<BusinessActorRoleMap>;
  /** insert data into the table: "map_business_process_function" */
  insertBusinessProcessFunctionMap?: Maybe<BusinessProcessFunctionMap_Mutation_Response>;
  /** insert a single row into the table: "map_business_process_function" */
  insertBusinessProcessFunctionMapOne?: Maybe<BusinessProcessFunctionMap>;
  /** insert data into the table: "map_business_process_hierarchy" */
  insertBusinessProcessHierarchyMap?: Maybe<BusinessProcessHierarchyMap_Mutation_Response>;
  /** insert a single row into the table: "map_business_process_hierarchy" */
  insertBusinessProcessHierarchyMapOne?: Maybe<BusinessProcessHierarchyMap>;
  /** insert data into the table: "map_business_process_motivation_item" */
  insertBusinessProcessMotivationItemMap?: Maybe<BusinessProcessMotivationItemMap_Mutation_Response>;
  /** insert a single row into the table: "map_business_process_motivation_item" */
  insertBusinessProcessMotivationItemMapOne?: Maybe<BusinessProcessMotivationItemMap>;
  /** insert data into the table: "products" */
  insertBusinessProduct?: Maybe<BusinessProduct_Mutation_Response>;
  /** insert a single row into the table: "products" */
  insertBusinessProductOne?: Maybe<BusinessProduct>;
  /** insert data into the table: "roles" */
  insertBusinessRole?: Maybe<BusinessRole_Mutation_Response>;
  /** insert a single row into the table: "roles" */
  insertBusinessRoleOne?: Maybe<BusinessRole>;
  /** insert data into the table: "capabilities" */
  insertCapability?: Maybe<Capability_Mutation_Response>;
  /** insert data into the table: "map_capability_application_component_assessment" */
  insertCapabilityApplicationComponentAssessmentMap?: Maybe<CapabilityApplicationComponentAssessmentMap_Mutation_Response>;
  /** insert a single row into the table: "map_capability_application_component_assessment" */
  insertCapabilityApplicationComponentAssessmentMapOne?: Maybe<CapabilityApplicationComponentAssessmentMap>;
  /** insert data into the table: "map_capability_application_component" */
  insertCapabilityApplicationComponentMap?: Maybe<CapabilityApplicationComponentMap_Mutation_Response>;
  /** insert a single row into the table: "map_capability_application_component" */
  insertCapabilityApplicationComponentMapOne?: Maybe<CapabilityApplicationComponentMap>;
  /** insert data into the table: "map_capability_business_process_assessment" */
  insertCapabilityBusinessProcessAssessmentMap?: Maybe<CapabilityBusinessProcessAssessmentMap_Mutation_Response>;
  /** insert a single row into the table: "map_capability_business_process_assessment" */
  insertCapabilityBusinessProcessAssessmentMapOne?: Maybe<CapabilityBusinessProcessAssessmentMap>;
  /** insert data into the table: "map_capability_business_process" */
  insertCapabilityBusinessProcessMap?: Maybe<CapabilityBusinessProcessMap_Mutation_Response>;
  /** insert a single row into the table: "map_capability_business_process" */
  insertCapabilityBusinessProcessMapOne?: Maybe<CapabilityBusinessProcessMap>;
  /** insert data into the table: "map_capability_hierarchy" */
  insertCapabilityHierarchyMap?: Maybe<CapabilityHierarchyMap_Mutation_Response>;
  /** insert a single row into the table: "map_capability_hierarchy" */
  insertCapabilityHierarchyMapOne?: Maybe<CapabilityHierarchyMap>;
  /** insert a single row into the table: "capabilities" */
  insertCapabilityOne?: Maybe<Capability>;
  /** insert data into the table: "data_objects" */
  insertDataObject?: Maybe<DataObject_Mutation_Response>;
  /** insert a single row into the table: "data_objects" */
  insertDataObjectOne?: Maybe<DataObject>;
  /** insert data into the table: "map_directory_items" */
  insertDirectoryItemsMap?: Maybe<DirectoryItemsMap_Mutation_Response>;
  /** insert a single row into the table: "map_directory_items" */
  insertDirectoryItemsMapOne?: Maybe<DirectoryItemsMap>;
  /** insert data into the table: "directories" */
  insertDirectoryObject?: Maybe<DirectoryObject_Mutation_Response>;
  /** insert a single row into the table: "directories" */
  insertDirectoryObjectOne?: Maybe<DirectoryObject>;
  /** insert data into the table: "employees" */
  insertEmployee?: Maybe<Employee_Mutation_Response>;
  /** insert a single row into the table: "employees" */
  insertEmployeeOne?: Maybe<Employee>;
  /** insert data into the table: "events" */
  insertEventGeneric?: Maybe<EventGeneric_Mutation_Response>;
  /** insert a single row into the table: "events" */
  insertEventGenericOne?: Maybe<EventGeneric>;
  /** insert data into the table: "flows" */
  insertFlowGeneric?: Maybe<FlowGeneric_Mutation_Response>;
  /** insert a single row into the table: "flows" */
  insertFlowGenericOne?: Maybe<FlowGeneric>;
  /** insert data into the table: "functions" */
  insertFunctionGeneric?: Maybe<FunctionGeneric_Mutation_Response>;
  /** insert a single row into the table: "functions" */
  insertFunctionGenericOne?: Maybe<FunctionGeneric>;
  /** insert data into the table: "interfaces" */
  insertInterfaceGeneric?: Maybe<InterfaceGeneric_Mutation_Response>;
  /** insert a single row into the table: "interfaces" */
  insertInterfaceGenericOne?: Maybe<InterfaceGeneric>;
  /** insert data into the table: "motivations" */
  insertMotivationElementGeneric?: Maybe<MotivationElementGeneric_Mutation_Response>;
  /** insert a single row into the table: "motivations" */
  insertMotivationElementGenericOne?: Maybe<MotivationElementGeneric>;
  /** insert data into the table: "map_motivation_item_hierarchy" */
  insertMotivationItemHierarchyMap?: Maybe<MotivationItemHierarchyMap_Mutation_Response>;
  /** insert a single row into the table: "map_motivation_item_hierarchy" */
  insertMotivationItemHierarchyMapOne?: Maybe<MotivationItemHierarchyMap>;
  /** insert data into the table: "locations" */
  insertPhysicalLocation?: Maybe<PhysicalLocation_Mutation_Response>;
  /** insert a single row into the table: "locations" */
  insertPhysicalLocationOne?: Maybe<PhysicalLocation>;
  /** insert data into the table: "plateaus" */
  insertPlateau?: Maybe<Plateau_Mutation_Response>;
  /** insert a single row into the table: "plateaus" */
  insertPlateauOne?: Maybe<Plateau>;
  /** insert data into the table: "processes" */
  insertProcessGeneric?: Maybe<ProcessGeneric_Mutation_Response>;
  /** insert a single row into the table: "processes" */
  insertProcessGenericOne?: Maybe<ProcessGeneric>;
  /** insert data into the table: "services" */
  insertServiceGeneric?: Maybe<ServiceGeneric_Mutation_Response>;
  /** insert a single row into the table: "services" */
  insertServiceGenericOne?: Maybe<ServiceGeneric>;
  /** insert data into the table: "solutions" */
  insertSolution?: Maybe<Solution_Mutation_Response>;
  /** insert data into the table: "map_solution_application_component" */
  insertSolutionApplicationComponentMap?: Maybe<SolutionApplicationComponentMap_Mutation_Response>;
  /** insert a single row into the table: "map_solution_application_component" */
  insertSolutionApplicationComponentMapOne?: Maybe<SolutionApplicationComponentMap>;
  /** insert data into the table: "map_solution_application_function" */
  insertSolutionApplicationFunctionMap?: Maybe<SolutionApplicationFunctionMap_Mutation_Response>;
  /** insert a single row into the table: "map_solution_application_function" */
  insertSolutionApplicationFunctionMapOne?: Maybe<SolutionApplicationFunctionMap>;
  /** insert data into the table: "map_solution_data_object" */
  insertSolutionDataObjectMap?: Maybe<SolutionDataObjectMap_Mutation_Response>;
  /** insert a single row into the table: "map_solution_data_object" */
  insertSolutionDataObjectMapOne?: Maybe<SolutionDataObjectMap>;
  /** insert data into the table: "map_solution_flow" */
  insertSolutionFlowMap?: Maybe<SolutionFlowMap_Mutation_Response>;
  /** insert a single row into the table: "map_solution_flow" */
  insertSolutionFlowMapOne?: Maybe<SolutionFlowMap>;
  /** insert data into the table: "map_solution_motivation_component" */
  insertSolutionMotivationComponentMap?: Maybe<SolutionMotivationComponentMap_Mutation_Response>;
  /** insert a single row into the table: "map_solution_motivation_component" */
  insertSolutionMotivationComponentMapOne?: Maybe<SolutionMotivationComponentMap>;
  /** insert data into the table: "map_solution_motivation" */
  insertSolutionMotivationElementMap?: Maybe<SolutionMotivationElementMap_Mutation_Response>;
  /** insert a single row into the table: "map_solution_motivation" */
  insertSolutionMotivationElementMapOne?: Maybe<SolutionMotivationElementMap>;
  /** insert a single row into the table: "solutions" */
  insertSolutionOne?: Maybe<Solution>;
  /** insert data into the table: "map_solution_stakeholder" */
  insertSolutionStakeholderMap?: Maybe<SolutionStakeholderMap_Mutation_Response>;
  /** insert a single row into the table: "map_solution_stakeholder" */
  insertSolutionStakeholderMapOne?: Maybe<SolutionStakeholderMap>;
  /** insert data into the table: "map_solution_technology_node" */
  insertSolutionTechnologyNodeMap?: Maybe<SolutionTechnologyNodeMap_Mutation_Response>;
  /** insert a single row into the table: "map_solution_technology_node" */
  insertSolutionTechnologyNodeMapOne?: Maybe<SolutionTechnologyNodeMap>;
  /** insert data into the table: "stakeholders" */
  insertStakeholder?: Maybe<Stakeholder_Mutation_Response>;
  /** insert a single row into the table: "stakeholders" */
  insertStakeholderOne?: Maybe<Stakeholder>;
  /** insert data into the table: "system_software" */
  insertSystemSoftware?: Maybe<SystemSoftware_Mutation_Response>;
  /** insert a single row into the table: "system_software" */
  insertSystemSoftwareOne?: Maybe<SystemSoftware>;
  /** insert data into the table: "technology_networks" */
  insertTechnologyNetwork?: Maybe<TechnologyNetwork_Mutation_Response>;
  /** insert data into the table: "map_technology_network_hierarchy" */
  insertTechnologyNetworkHierarchyMap?: Maybe<TechnologyNetworkHierarchyMap_Mutation_Response>;
  /** insert a single row into the table: "map_technology_network_hierarchy" */
  insertTechnologyNetworkHierarchyMapOne?: Maybe<TechnologyNetworkHierarchyMap>;
  /** insert a single row into the table: "technology_networks" */
  insertTechnologyNetworkOne?: Maybe<TechnologyNetwork>;
  /** insert data into the table: "technology_nodes" */
  insertTechnologyNode?: Maybe<TechnologyNode_Mutation_Response>;
  /** insert data into the table: "map_technology_node_hierarchy" */
  insertTechnologyNodeHierarchyMap?: Maybe<TechnologyNodeHierarchyMap_Mutation_Response>;
  /** insert a single row into the table: "map_technology_node_hierarchy" */
  insertTechnologyNodeHierarchyMapOne?: Maybe<TechnologyNodeHierarchyMap>;
  /** insert a single row into the table: "technology_nodes" */
  insertTechnologyNodeOne?: Maybe<TechnologyNode>;
  /** insert data into the table: "map_technology_node_system_software" */
  insertTechnologyNodeSystemSoftwareMap?: Maybe<TechnologyNodeSystemSoftwareMap_Mutation_Response>;
  /** insert a single row into the table: "map_technology_node_system_software" */
  insertTechnologyNodeSystemSoftwareMapOne?: Maybe<TechnologyNodeSystemSoftwareMap>;
  /** insert data into the table: "map_solution_constraint" */
  insert_mapSolutionConstraint?: Maybe<MapSolutionConstraint_Mutation_Response>;
  /** insert a single row into the table: "map_solution_constraint" */
  insert_mapSolutionConstraint_one?: Maybe<MapSolutionConstraint>;
  /** insert data into the table: "map_tenant_user_profiles" */
  insert_mapTenantUserProfiles?: Maybe<MapTenantUserProfiles_Mutation_Response>;
  /** insert a single row into the table: "map_tenant_user_profiles" */
  insert_mapTenantUserProfiles_one?: Maybe<MapTenantUserProfiles>;
  /** insert data into the table: "tenants" */
  insert_tenants?: Maybe<Tenants_Mutation_Response>;
  /** insert a single row into the table: "tenants" */
  insert_tenants_one?: Maybe<Tenants>;
  /** insert data into the table: "user_profiles" */
  insert_userProfiles?: Maybe<UserProfiles_Mutation_Response>;
  /** insert a single row into the table: "user_profiles" */
  insert_userProfiles_one?: Maybe<UserProfiles>;
  /** update data of the table: "components" */
  updateApplicationComponent?: Maybe<ApplicationComponent_Mutation_Response>;
  /** update data of the table: "map_application_component_actor_role" */
  updateApplicationComponentBusinessActorRoleMap?: Maybe<ApplicationComponentBusinessActorRoleMap_Mutation_Response>;
  /** update single row of the table: "map_application_component_actor_role" */
  updateApplicationComponentBusinessActorRoleMapByPk?: Maybe<ApplicationComponentBusinessActorRoleMap>;
  /** update single row of the table: "components" */
  updateApplicationComponentByPk?: Maybe<ApplicationComponent>;
  /** update data of the table: "map_application_component_data_object" */
  updateApplicationComponentDataObjectMap?: Maybe<ApplicationComponentDataObjectMap_Mutation_Response>;
  /** update single row of the table: "map_application_component_data_object" */
  updateApplicationComponentDataObjectMapByPk?: Maybe<ApplicationComponentDataObjectMap>;
  /** update data of the table: "map_application_component_directory" */
  updateApplicationComponentDirectoryMap?: Maybe<ApplicationComponentDirectoryMap_Mutation_Response>;
  /** update single row of the table: "map_application_component_directory" */
  updateApplicationComponentDirectoryMapByPk?: Maybe<ApplicationComponentDirectoryMap>;
  /** update data of the table: "map_application_component_event" */
  updateApplicationComponentEventMap?: Maybe<ApplicationComponentEventMap_Mutation_Response>;
  /** update single row of the table: "map_application_component_event" */
  updateApplicationComponentEventMapByPk?: Maybe<ApplicationComponentEventMap>;
  /** update data of the table: "map_application_component_function" */
  updateApplicationComponentFunctionMap?: Maybe<ApplicationComponentFunctionMap_Mutation_Response>;
  /** update single row of the table: "map_application_component_function" */
  updateApplicationComponentFunctionMapByPk?: Maybe<ApplicationComponentFunctionMap>;
  /** update data of the table: "map_application_component_hierarchy" */
  updateApplicationComponentHierarchyMap?: Maybe<ApplicationComponentHierarchyMap_Mutation_Response>;
  /** update single row of the table: "map_application_component_hierarchy" */
  updateApplicationComponentHierarchyMapByPk?: Maybe<ApplicationComponentHierarchyMap>;
  /** update data of the table: "map_application_component_interface" */
  updateApplicationComponentInterfaceMap?: Maybe<ApplicationComponentInterfaceMap_Mutation_Response>;
  /** update single row of the table: "map_application_component_interface" */
  updateApplicationComponentInterfaceMapByPk?: Maybe<ApplicationComponentInterfaceMap>;
  /** update data of the table: "map_application_component_product" */
  updateApplicationComponentProductMap?: Maybe<ApplicationComponentProductMap_Mutation_Response>;
  /** update single row of the table: "map_application_component_product" */
  updateApplicationComponentProductMapByPk?: Maybe<ApplicationComponentProductMap>;
  /** update data of the table: "map_application_component_stakeholder" */
  updateApplicationComponentStakeholderMap?: Maybe<ApplicationComponentStakeholderMap_Mutation_Response>;
  /** update single row of the table: "map_application_component_stakeholder" */
  updateApplicationComponentStakeholderMapByPk?: Maybe<ApplicationComponentStakeholderMap>;
  /** update data of the table: "map_application_component_system_software" */
  updateApplicationComponentSystemSoftwareMap?: Maybe<ApplicationComponentSystemSoftwareMap_Mutation_Response>;
  /** update single row of the table: "map_application_component_system_software" */
  updateApplicationComponentSystemSoftwareMapByPk?: Maybe<ApplicationComponentSystemSoftwareMap>;
  /** update data of the table: "map_application_component_technology_logical_network" */
  updateApplicationComponentTechnologyLogicalNetworkMap?: Maybe<ApplicationComponentTechnologyLogicalNetworkMap_Mutation_Response>;
  /** update single row of the table: "map_application_component_technology_logical_network" */
  updateApplicationComponentTechnologyLogicalNetworkMapByPk?: Maybe<ApplicationComponentTechnologyLogicalNetworkMap>;
  /** update data of the table: "map_application_component_technology_node" */
  updateApplicationComponentTechnologyNodeMap?: Maybe<ApplicationComponentTechnologyNodeMap_Mutation_Response>;
  /** update single row of the table: "map_application_component_technology_node" */
  updateApplicationComponentTechnologyNodeMapByPk?: Maybe<ApplicationComponentTechnologyNodeMap>;
  /** update data of the table: "map_application_function_data_object" */
  updateApplicationFunctionDataObjectMap?: Maybe<ApplicationFunctionDataObjectMap_Mutation_Response>;
  /** update single row of the table: "map_application_function_data_object" */
  updateApplicationFunctionDataObjectMapByPk?: Maybe<ApplicationFunctionDataObjectMap>;
  /** update data of the table: "map_application_interface_function" */
  updateApplicationFunctionInterfaceMap?: Maybe<ApplicationFunctionInterfaceMap_Mutation_Response>;
  /** update single row of the table: "map_application_interface_function" */
  updateApplicationFunctionInterfaceMapByPk?: Maybe<ApplicationFunctionInterfaceMap>;
  /** update data of the table: "actors" */
  updateBusinessActor?: Maybe<BusinessActor_Mutation_Response>;
  /** update single row of the table: "actors" */
  updateBusinessActorByPk?: Maybe<BusinessActor>;
  /** update data of the table: "map_business_actor_role" */
  updateBusinessActorRoleMap?: Maybe<BusinessActorRoleMap_Mutation_Response>;
  /** update single row of the table: "map_business_actor_role" */
  updateBusinessActorRoleMapByPk?: Maybe<BusinessActorRoleMap>;
  /** update data of the table: "map_business_process_function" */
  updateBusinessProcessFunctionMap?: Maybe<BusinessProcessFunctionMap_Mutation_Response>;
  /** update single row of the table: "map_business_process_function" */
  updateBusinessProcessFunctionMapByPk?: Maybe<BusinessProcessFunctionMap>;
  /** update data of the table: "map_business_process_hierarchy" */
  updateBusinessProcessHierarchyMap?: Maybe<BusinessProcessHierarchyMap_Mutation_Response>;
  /** update single row of the table: "map_business_process_hierarchy" */
  updateBusinessProcessHierarchyMapByPk?: Maybe<BusinessProcessHierarchyMap>;
  /** update data of the table: "map_business_process_motivation_item" */
  updateBusinessProcessMotivationItemMap?: Maybe<BusinessProcessMotivationItemMap_Mutation_Response>;
  /** update single row of the table: "map_business_process_motivation_item" */
  updateBusinessProcessMotivationItemMapByPk?: Maybe<BusinessProcessMotivationItemMap>;
  /** update data of the table: "products" */
  updateBusinessProduct?: Maybe<BusinessProduct_Mutation_Response>;
  /** update single row of the table: "products" */
  updateBusinessProductByPk?: Maybe<BusinessProduct>;
  /** update data of the table: "roles" */
  updateBusinessRole?: Maybe<BusinessRole_Mutation_Response>;
  /** update single row of the table: "roles" */
  updateBusinessRoleByPk?: Maybe<BusinessRole>;
  /** update data of the table: "capabilities" */
  updateCapability?: Maybe<Capability_Mutation_Response>;
  /** update data of the table: "map_capability_application_component_assessment" */
  updateCapabilityApplicationComponentAssessmentMap?: Maybe<CapabilityApplicationComponentAssessmentMap_Mutation_Response>;
  /** update single row of the table: "map_capability_application_component_assessment" */
  updateCapabilityApplicationComponentAssessmentMapByPk?: Maybe<CapabilityApplicationComponentAssessmentMap>;
  /** update data of the table: "map_capability_application_component" */
  updateCapabilityApplicationComponentMap?: Maybe<CapabilityApplicationComponentMap_Mutation_Response>;
  /** update single row of the table: "map_capability_application_component" */
  updateCapabilityApplicationComponentMapByPk?: Maybe<CapabilityApplicationComponentMap>;
  /** update data of the table: "map_capability_business_process_assessment" */
  updateCapabilityBusinessProcessAssessmentMap?: Maybe<CapabilityBusinessProcessAssessmentMap_Mutation_Response>;
  /** update single row of the table: "map_capability_business_process_assessment" */
  updateCapabilityBusinessProcessAssessmentMapByPk?: Maybe<CapabilityBusinessProcessAssessmentMap>;
  /** update data of the table: "map_capability_business_process" */
  updateCapabilityBusinessProcessMap?: Maybe<CapabilityBusinessProcessMap_Mutation_Response>;
  /** update single row of the table: "map_capability_business_process" */
  updateCapabilityBusinessProcessMapByPk?: Maybe<CapabilityBusinessProcessMap>;
  /** update single row of the table: "capabilities" */
  updateCapabilityByPk?: Maybe<Capability>;
  /** update data of the table: "map_capability_hierarchy" */
  updateCapabilityHierarchyMap?: Maybe<CapabilityHierarchyMap_Mutation_Response>;
  /** update single row of the table: "map_capability_hierarchy" */
  updateCapabilityHierarchyMapByPk?: Maybe<CapabilityHierarchyMap>;
  /** update data of the table: "data_objects" */
  updateDataObject?: Maybe<DataObject_Mutation_Response>;
  /** update single row of the table: "data_objects" */
  updateDataObjectByPk?: Maybe<DataObject>;
  /** update data of the table: "map_directory_items" */
  updateDirectoryItemsMap?: Maybe<DirectoryItemsMap_Mutation_Response>;
  /** update single row of the table: "map_directory_items" */
  updateDirectoryItemsMapByPk?: Maybe<DirectoryItemsMap>;
  /** update data of the table: "directories" */
  updateDirectoryObject?: Maybe<DirectoryObject_Mutation_Response>;
  /** update single row of the table: "directories" */
  updateDirectoryObjectByPk?: Maybe<DirectoryObject>;
  /** update data of the table: "employees" */
  updateEmployee?: Maybe<Employee_Mutation_Response>;
  /** update single row of the table: "employees" */
  updateEmployeeByPk?: Maybe<Employee>;
  /** update data of the table: "events" */
  updateEventGeneric?: Maybe<EventGeneric_Mutation_Response>;
  /** update single row of the table: "events" */
  updateEventGenericByPk?: Maybe<EventGeneric>;
  /** update data of the table: "flows" */
  updateFlowGeneric?: Maybe<FlowGeneric_Mutation_Response>;
  /** update single row of the table: "flows" */
  updateFlowGenericByPk?: Maybe<FlowGeneric>;
  /** update data of the table: "functions" */
  updateFunctionGeneric?: Maybe<FunctionGeneric_Mutation_Response>;
  /** update single row of the table: "functions" */
  updateFunctionGenericByPk?: Maybe<FunctionGeneric>;
  /** update data of the table: "interfaces" */
  updateInterfaceGeneric?: Maybe<InterfaceGeneric_Mutation_Response>;
  /** update single row of the table: "interfaces" */
  updateInterfaceGenericByPk?: Maybe<InterfaceGeneric>;
  /** update data of the table: "motivations" */
  updateMotivationElementGeneric?: Maybe<MotivationElementGeneric_Mutation_Response>;
  /** update single row of the table: "motivations" */
  updateMotivationElementGenericByPk?: Maybe<MotivationElementGeneric>;
  /** update data of the table: "map_motivation_item_hierarchy" */
  updateMotivationItemHierarchyMap?: Maybe<MotivationItemHierarchyMap_Mutation_Response>;
  /** update single row of the table: "map_motivation_item_hierarchy" */
  updateMotivationItemHierarchyMapByPk?: Maybe<MotivationItemHierarchyMap>;
  /** update data of the table: "locations" */
  updatePhysicalLocation?: Maybe<PhysicalLocation_Mutation_Response>;
  /** update single row of the table: "locations" */
  updatePhysicalLocationByPk?: Maybe<PhysicalLocation>;
  /** update data of the table: "plateaus" */
  updatePlateau?: Maybe<Plateau_Mutation_Response>;
  /** update single row of the table: "plateaus" */
  updatePlateauByPk?: Maybe<Plateau>;
  /** update data of the table: "processes" */
  updateProcessGeneric?: Maybe<ProcessGeneric_Mutation_Response>;
  /** update single row of the table: "processes" */
  updateProcessGenericByPk?: Maybe<ProcessGeneric>;
  /** update data of the table: "services" */
  updateServiceGeneric?: Maybe<ServiceGeneric_Mutation_Response>;
  /** update single row of the table: "services" */
  updateServiceGenericByPk?: Maybe<ServiceGeneric>;
  /** update data of the table: "solutions" */
  updateSolution?: Maybe<Solution_Mutation_Response>;
  /** update data of the table: "map_solution_application_component" */
  updateSolutionApplicationComponentMap?: Maybe<SolutionApplicationComponentMap_Mutation_Response>;
  /** update single row of the table: "map_solution_application_component" */
  updateSolutionApplicationComponentMapByPk?: Maybe<SolutionApplicationComponentMap>;
  /** update data of the table: "map_solution_application_function" */
  updateSolutionApplicationFunctionMap?: Maybe<SolutionApplicationFunctionMap_Mutation_Response>;
  /** update single row of the table: "map_solution_application_function" */
  updateSolutionApplicationFunctionMapByPk?: Maybe<SolutionApplicationFunctionMap>;
  /** update single row of the table: "solutions" */
  updateSolutionByPk?: Maybe<Solution>;
  /** update data of the table: "map_solution_data_object" */
  updateSolutionDataObjectMap?: Maybe<SolutionDataObjectMap_Mutation_Response>;
  /** update single row of the table: "map_solution_data_object" */
  updateSolutionDataObjectMapByPk?: Maybe<SolutionDataObjectMap>;
  /** update data of the table: "map_solution_flow" */
  updateSolutionFlowMap?: Maybe<SolutionFlowMap_Mutation_Response>;
  /** update single row of the table: "map_solution_flow" */
  updateSolutionFlowMapByPk?: Maybe<SolutionFlowMap>;
  /** update data of the table: "map_solution_motivation_component" */
  updateSolutionMotivationComponentMap?: Maybe<SolutionMotivationComponentMap_Mutation_Response>;
  /** update single row of the table: "map_solution_motivation_component" */
  updateSolutionMotivationComponentMapByPk?: Maybe<SolutionMotivationComponentMap>;
  /** update data of the table: "map_solution_motivation" */
  updateSolutionMotivationElementMap?: Maybe<SolutionMotivationElementMap_Mutation_Response>;
  /** update single row of the table: "map_solution_motivation" */
  updateSolutionMotivationElementMapByPk?: Maybe<SolutionMotivationElementMap>;
  /** update data of the table: "map_solution_stakeholder" */
  updateSolutionStakeholderMap?: Maybe<SolutionStakeholderMap_Mutation_Response>;
  /** update single row of the table: "map_solution_stakeholder" */
  updateSolutionStakeholderMapByPk?: Maybe<SolutionStakeholderMap>;
  /** update data of the table: "map_solution_technology_node" */
  updateSolutionTechnologyNodeMap?: Maybe<SolutionTechnologyNodeMap_Mutation_Response>;
  /** update single row of the table: "map_solution_technology_node" */
  updateSolutionTechnologyNodeMapByPk?: Maybe<SolutionTechnologyNodeMap>;
  /** update data of the table: "stakeholders" */
  updateStakeholder?: Maybe<Stakeholder_Mutation_Response>;
  /** update single row of the table: "stakeholders" */
  updateStakeholderByPk?: Maybe<Stakeholder>;
  /** update data of the table: "system_software" */
  updateSystemSoftware?: Maybe<SystemSoftware_Mutation_Response>;
  /** update single row of the table: "system_software" */
  updateSystemSoftwareByPk?: Maybe<SystemSoftware>;
  /** update data of the table: "technology_networks" */
  updateTechnologyNetwork?: Maybe<TechnologyNetwork_Mutation_Response>;
  /** update single row of the table: "technology_networks" */
  updateTechnologyNetworkByPk?: Maybe<TechnologyNetwork>;
  /** update data of the table: "map_technology_network_hierarchy" */
  updateTechnologyNetworkHierarchyMap?: Maybe<TechnologyNetworkHierarchyMap_Mutation_Response>;
  /** update single row of the table: "map_technology_network_hierarchy" */
  updateTechnologyNetworkHierarchyMapByPk?: Maybe<TechnologyNetworkHierarchyMap>;
  /** update data of the table: "technology_nodes" */
  updateTechnologyNode?: Maybe<TechnologyNode_Mutation_Response>;
  /** update single row of the table: "technology_nodes" */
  updateTechnologyNodeByPk?: Maybe<TechnologyNode>;
  /** update data of the table: "map_technology_node_hierarchy" */
  updateTechnologyNodeHierarchyMap?: Maybe<TechnologyNodeHierarchyMap_Mutation_Response>;
  /** update single row of the table: "map_technology_node_hierarchy" */
  updateTechnologyNodeHierarchyMapByPk?: Maybe<TechnologyNodeHierarchyMap>;
  /** update data of the table: "map_technology_node_system_software" */
  updateTechnologyNodeSystemSoftwareMap?: Maybe<TechnologyNodeSystemSoftwareMap_Mutation_Response>;
  /** update single row of the table: "map_technology_node_system_software" */
  updateTechnologyNodeSystemSoftwareMapByPk?: Maybe<TechnologyNodeSystemSoftwareMap>;
  /** update multiples rows of table: "map_application_component_actor_role" */
  update_ApplicationComponentBusinessActorRoleMap_many?: Maybe<Array<Maybe<ApplicationComponentBusinessActorRoleMap_Mutation_Response>>>;
  /** update multiples rows of table: "map_application_component_data_object" */
  update_ApplicationComponentDataObjectMap_many?: Maybe<Array<Maybe<ApplicationComponentDataObjectMap_Mutation_Response>>>;
  /** update multiples rows of table: "map_application_component_directory" */
  update_ApplicationComponentDirectoryMap_many?: Maybe<Array<Maybe<ApplicationComponentDirectoryMap_Mutation_Response>>>;
  /** update multiples rows of table: "map_application_component_event" */
  update_ApplicationComponentEventMap_many?: Maybe<Array<Maybe<ApplicationComponentEventMap_Mutation_Response>>>;
  /** update multiples rows of table: "map_application_component_function" */
  update_ApplicationComponentFunctionMap_many?: Maybe<Array<Maybe<ApplicationComponentFunctionMap_Mutation_Response>>>;
  /** update multiples rows of table: "map_application_component_hierarchy" */
  update_ApplicationComponentHierarchyMap_many?: Maybe<Array<Maybe<ApplicationComponentHierarchyMap_Mutation_Response>>>;
  /** update multiples rows of table: "map_application_component_interface" */
  update_ApplicationComponentInterfaceMap_many?: Maybe<Array<Maybe<ApplicationComponentInterfaceMap_Mutation_Response>>>;
  /** update multiples rows of table: "map_application_component_product" */
  update_ApplicationComponentProductMap_many?: Maybe<Array<Maybe<ApplicationComponentProductMap_Mutation_Response>>>;
  /** update multiples rows of table: "map_application_component_stakeholder" */
  update_ApplicationComponentStakeholderMap_many?: Maybe<Array<Maybe<ApplicationComponentStakeholderMap_Mutation_Response>>>;
  /** update multiples rows of table: "map_application_component_system_software" */
  update_ApplicationComponentSystemSoftwareMap_many?: Maybe<Array<Maybe<ApplicationComponentSystemSoftwareMap_Mutation_Response>>>;
  /** update multiples rows of table: "map_application_component_technology_logical_network" */
  update_ApplicationComponentTechnologyLogicalNetworkMap_many?: Maybe<Array<Maybe<ApplicationComponentTechnologyLogicalNetworkMap_Mutation_Response>>>;
  /** update multiples rows of table: "map_application_component_technology_node" */
  update_ApplicationComponentTechnologyNodeMap_many?: Maybe<Array<Maybe<ApplicationComponentTechnologyNodeMap_Mutation_Response>>>;
  /** update multiples rows of table: "components" */
  update_ApplicationComponent_many?: Maybe<Array<Maybe<ApplicationComponent_Mutation_Response>>>;
  /** update multiples rows of table: "map_application_function_data_object" */
  update_ApplicationFunctionDataObjectMap_many?: Maybe<Array<Maybe<ApplicationFunctionDataObjectMap_Mutation_Response>>>;
  /** update multiples rows of table: "map_application_interface_function" */
  update_ApplicationFunctionInterfaceMap_many?: Maybe<Array<Maybe<ApplicationFunctionInterfaceMap_Mutation_Response>>>;
  /** update multiples rows of table: "map_business_actor_role" */
  update_BusinessActorRoleMap_many?: Maybe<Array<Maybe<BusinessActorRoleMap_Mutation_Response>>>;
  /** update multiples rows of table: "actors" */
  update_BusinessActor_many?: Maybe<Array<Maybe<BusinessActor_Mutation_Response>>>;
  /** update multiples rows of table: "map_business_process_function" */
  update_BusinessProcessFunctionMap_many?: Maybe<Array<Maybe<BusinessProcessFunctionMap_Mutation_Response>>>;
  /** update multiples rows of table: "map_business_process_hierarchy" */
  update_BusinessProcessHierarchyMap_many?: Maybe<Array<Maybe<BusinessProcessHierarchyMap_Mutation_Response>>>;
  /** update multiples rows of table: "map_business_process_motivation_item" */
  update_BusinessProcessMotivationItemMap_many?: Maybe<Array<Maybe<BusinessProcessMotivationItemMap_Mutation_Response>>>;
  /** update multiples rows of table: "products" */
  update_BusinessProduct_many?: Maybe<Array<Maybe<BusinessProduct_Mutation_Response>>>;
  /** update multiples rows of table: "roles" */
  update_BusinessRole_many?: Maybe<Array<Maybe<BusinessRole_Mutation_Response>>>;
  /** update multiples rows of table: "map_capability_application_component_assessment" */
  update_CapabilityApplicationComponentAssessmentMap_many?: Maybe<Array<Maybe<CapabilityApplicationComponentAssessmentMap_Mutation_Response>>>;
  /** update multiples rows of table: "map_capability_application_component" */
  update_CapabilityApplicationComponentMap_many?: Maybe<Array<Maybe<CapabilityApplicationComponentMap_Mutation_Response>>>;
  /** update multiples rows of table: "map_capability_business_process_assessment" */
  update_CapabilityBusinessProcessAssessmentMap_many?: Maybe<Array<Maybe<CapabilityBusinessProcessAssessmentMap_Mutation_Response>>>;
  /** update multiples rows of table: "map_capability_business_process" */
  update_CapabilityBusinessProcessMap_many?: Maybe<Array<Maybe<CapabilityBusinessProcessMap_Mutation_Response>>>;
  /** update multiples rows of table: "map_capability_hierarchy" */
  update_CapabilityHierarchyMap_many?: Maybe<Array<Maybe<CapabilityHierarchyMap_Mutation_Response>>>;
  /** update multiples rows of table: "capabilities" */
  update_Capability_many?: Maybe<Array<Maybe<Capability_Mutation_Response>>>;
  /** update multiples rows of table: "data_objects" */
  update_DataObject_many?: Maybe<Array<Maybe<DataObject_Mutation_Response>>>;
  /** update multiples rows of table: "map_directory_items" */
  update_DirectoryItemsMap_many?: Maybe<Array<Maybe<DirectoryItemsMap_Mutation_Response>>>;
  /** update multiples rows of table: "directories" */
  update_DirectoryObject_many?: Maybe<Array<Maybe<DirectoryObject_Mutation_Response>>>;
  /** update multiples rows of table: "employees" */
  update_Employee_many?: Maybe<Array<Maybe<Employee_Mutation_Response>>>;
  /** update multiples rows of table: "events" */
  update_EventGeneric_many?: Maybe<Array<Maybe<EventGeneric_Mutation_Response>>>;
  /** update multiples rows of table: "flows" */
  update_FlowGeneric_many?: Maybe<Array<Maybe<FlowGeneric_Mutation_Response>>>;
  /** update multiples rows of table: "functions" */
  update_FunctionGeneric_many?: Maybe<Array<Maybe<FunctionGeneric_Mutation_Response>>>;
  /** update multiples rows of table: "interfaces" */
  update_InterfaceGeneric_many?: Maybe<Array<Maybe<InterfaceGeneric_Mutation_Response>>>;
  /** update multiples rows of table: "motivations" */
  update_MotivationElementGeneric_many?: Maybe<Array<Maybe<MotivationElementGeneric_Mutation_Response>>>;
  /** update multiples rows of table: "map_motivation_item_hierarchy" */
  update_MotivationItemHierarchyMap_many?: Maybe<Array<Maybe<MotivationItemHierarchyMap_Mutation_Response>>>;
  /** update multiples rows of table: "locations" */
  update_PhysicalLocation_many?: Maybe<Array<Maybe<PhysicalLocation_Mutation_Response>>>;
  /** update multiples rows of table: "plateaus" */
  update_Plateau_many?: Maybe<Array<Maybe<Plateau_Mutation_Response>>>;
  /** update multiples rows of table: "processes" */
  update_ProcessGeneric_many?: Maybe<Array<Maybe<ProcessGeneric_Mutation_Response>>>;
  /** update multiples rows of table: "services" */
  update_ServiceGeneric_many?: Maybe<Array<Maybe<ServiceGeneric_Mutation_Response>>>;
  /** update multiples rows of table: "map_solution_application_component" */
  update_SolutionApplicationComponentMap_many?: Maybe<Array<Maybe<SolutionApplicationComponentMap_Mutation_Response>>>;
  /** update multiples rows of table: "map_solution_application_function" */
  update_SolutionApplicationFunctionMap_many?: Maybe<Array<Maybe<SolutionApplicationFunctionMap_Mutation_Response>>>;
  /** update multiples rows of table: "map_solution_data_object" */
  update_SolutionDataObjectMap_many?: Maybe<Array<Maybe<SolutionDataObjectMap_Mutation_Response>>>;
  /** update multiples rows of table: "map_solution_flow" */
  update_SolutionFlowMap_many?: Maybe<Array<Maybe<SolutionFlowMap_Mutation_Response>>>;
  /** update multiples rows of table: "map_solution_motivation_component" */
  update_SolutionMotivationComponentMap_many?: Maybe<Array<Maybe<SolutionMotivationComponentMap_Mutation_Response>>>;
  /** update multiples rows of table: "map_solution_motivation" */
  update_SolutionMotivationElementMap_many?: Maybe<Array<Maybe<SolutionMotivationElementMap_Mutation_Response>>>;
  /** update multiples rows of table: "map_solution_stakeholder" */
  update_SolutionStakeholderMap_many?: Maybe<Array<Maybe<SolutionStakeholderMap_Mutation_Response>>>;
  /** update multiples rows of table: "map_solution_technology_node" */
  update_SolutionTechnologyNodeMap_many?: Maybe<Array<Maybe<SolutionTechnologyNodeMap_Mutation_Response>>>;
  /** update multiples rows of table: "solutions" */
  update_Solution_many?: Maybe<Array<Maybe<Solution_Mutation_Response>>>;
  /** update multiples rows of table: "stakeholders" */
  update_Stakeholder_many?: Maybe<Array<Maybe<Stakeholder_Mutation_Response>>>;
  /** update multiples rows of table: "system_software" */
  update_SystemSoftware_many?: Maybe<Array<Maybe<SystemSoftware_Mutation_Response>>>;
  /** update multiples rows of table: "map_technology_network_hierarchy" */
  update_TechnologyNetworkHierarchyMap_many?: Maybe<Array<Maybe<TechnologyNetworkHierarchyMap_Mutation_Response>>>;
  /** update multiples rows of table: "technology_networks" */
  update_TechnologyNetwork_many?: Maybe<Array<Maybe<TechnologyNetwork_Mutation_Response>>>;
  /** update multiples rows of table: "map_technology_node_hierarchy" */
  update_TechnologyNodeHierarchyMap_many?: Maybe<Array<Maybe<TechnologyNodeHierarchyMap_Mutation_Response>>>;
  /** update multiples rows of table: "map_technology_node_system_software" */
  update_TechnologyNodeSystemSoftwareMap_many?: Maybe<Array<Maybe<TechnologyNodeSystemSoftwareMap_Mutation_Response>>>;
  /** update multiples rows of table: "technology_nodes" */
  update_TechnologyNode_many?: Maybe<Array<Maybe<TechnologyNode_Mutation_Response>>>;
  /** update data of the table: "map_solution_constraint" */
  update_mapSolutionConstraint?: Maybe<MapSolutionConstraint_Mutation_Response>;
  /** update single row of the table: "map_solution_constraint" */
  update_mapSolutionConstraint_by_pk?: Maybe<MapSolutionConstraint>;
  /** update multiples rows of table: "map_solution_constraint" */
  update_mapSolutionConstraint_many?: Maybe<Array<Maybe<MapSolutionConstraint_Mutation_Response>>>;
  /** update data of the table: "map_tenant_user_profiles" */
  update_mapTenantUserProfiles?: Maybe<MapTenantUserProfiles_Mutation_Response>;
  /** update single row of the table: "map_tenant_user_profiles" */
  update_mapTenantUserProfiles_by_pk?: Maybe<MapTenantUserProfiles>;
  /** update multiples rows of table: "map_tenant_user_profiles" */
  update_mapTenantUserProfiles_many?: Maybe<Array<Maybe<MapTenantUserProfiles_Mutation_Response>>>;
  /** update data of the table: "tenants" */
  update_tenants?: Maybe<Tenants_Mutation_Response>;
  /** update single row of the table: "tenants" */
  update_tenants_by_pk?: Maybe<Tenants>;
  /** update multiples rows of table: "tenants" */
  update_tenants_many?: Maybe<Array<Maybe<Tenants_Mutation_Response>>>;
  /** update data of the table: "user_profiles" */
  update_userProfiles?: Maybe<UserProfiles_Mutation_Response>;
  /** update single row of the table: "user_profiles" */
  update_userProfiles_by_pk?: Maybe<UserProfiles>;
  /** update multiples rows of table: "user_profiles" */
  update_userProfiles_many?: Maybe<Array<Maybe<UserProfiles_Mutation_Response>>>;
};


/** mutation root */
export type Mutation_RootDeleteApplicationComponentArgs = {
  where: ApplicationComponent_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteApplicationComponentBusinessActorRoleMapArgs = {
  where: ApplicationComponentBusinessActorRoleMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteApplicationComponentBusinessActorRoleMapByPkArgs = {
  actorId: Scalars['uuid']['input'];
  componentId: Scalars['uuid']['input'];
  roleId: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteApplicationComponentByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteApplicationComponentDataObjectMapArgs = {
  where: ApplicationComponentDataObjectMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteApplicationComponentDataObjectMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  dataObjectId: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteApplicationComponentDirectoryMapArgs = {
  where: ApplicationComponentDirectoryMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteApplicationComponentDirectoryMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  directoryId: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteApplicationComponentEventMapArgs = {
  where: ApplicationComponentEventMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteApplicationComponentEventMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  eventId: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteApplicationComponentFunctionMapArgs = {
  where: ApplicationComponentFunctionMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteApplicationComponentFunctionMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  functionId: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteApplicationComponentHierarchyMapArgs = {
  where: ApplicationComponentHierarchyMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteApplicationComponentHierarchyMapByPkArgs = {
  componentChildId: Scalars['uuid']['input'];
  componentParentId: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteApplicationComponentInterfaceMapArgs = {
  where: ApplicationComponentInterfaceMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteApplicationComponentInterfaceMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  interfaceId: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteApplicationComponentProductMapArgs = {
  where: ApplicationComponentProductMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteApplicationComponentProductMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  productId: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteApplicationComponentStakeholderMapArgs = {
  where: ApplicationComponentStakeholderMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteApplicationComponentStakeholderMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  stakeholderId: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteApplicationComponentSystemSoftwareMapArgs = {
  where: ApplicationComponentSystemSoftwareMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteApplicationComponentSystemSoftwareMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  systemSoftwareId: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteApplicationComponentTechnologyLogicalNetworkMapArgs = {
  where: ApplicationComponentTechnologyLogicalNetworkMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteApplicationComponentTechnologyLogicalNetworkMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  logicalNetworkId: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteApplicationComponentTechnologyNodeMapArgs = {
  where: ApplicationComponentTechnologyNodeMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteApplicationComponentTechnologyNodeMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  nodeId: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteApplicationFunctionDataObjectMapArgs = {
  where: ApplicationFunctionDataObjectMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteApplicationFunctionDataObjectMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  dataObjectId: Scalars['uuid']['input'];
  functionId: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteApplicationFunctionInterfaceMapArgs = {
  where: ApplicationFunctionInterfaceMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteApplicationFunctionInterfaceMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  functionId: Scalars['uuid']['input'];
  interfaceId: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteBusinessActorArgs = {
  where: BusinessActor_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteBusinessActorByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteBusinessActorRoleMapArgs = {
  where: BusinessActorRoleMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteBusinessActorRoleMapByPkArgs = {
  actorId: Scalars['uuid']['input'];
  roleId: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteBusinessProcessFunctionMapArgs = {
  where: BusinessProcessFunctionMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteBusinessProcessFunctionMapByPkArgs = {
  functionId: Scalars['uuid']['input'];
  processId: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteBusinessProcessHierarchyMapArgs = {
  where: BusinessProcessHierarchyMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteBusinessProcessHierarchyMapByPkArgs = {
  processChildId: Scalars['uuid']['input'];
  processParentId: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteBusinessProcessMotivationItemMapArgs = {
  where: BusinessProcessMotivationItemMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteBusinessProcessMotivationItemMapByPkArgs = {
  motivationId: Scalars['uuid']['input'];
  processId: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteBusinessProductArgs = {
  where: BusinessProduct_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteBusinessProductByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteBusinessRoleArgs = {
  where: BusinessRole_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteBusinessRoleByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteCapabilityArgs = {
  where: Capability_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteCapabilityApplicationComponentAssessmentMapArgs = {
  where: CapabilityApplicationComponentAssessmentMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteCapabilityApplicationComponentAssessmentMapByPkArgs = {
  assessmentId: Scalars['uuid']['input'];
  capabilityId: Scalars['uuid']['input'];
  componentId: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteCapabilityApplicationComponentMapArgs = {
  where: CapabilityApplicationComponentMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteCapabilityApplicationComponentMapByPkArgs = {
  capabilityId: Scalars['uuid']['input'];
  componentId: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteCapabilityBusinessProcessAssessmentMapArgs = {
  where: CapabilityBusinessProcessAssessmentMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteCapabilityBusinessProcessAssessmentMapByPkArgs = {
  assessmentId: Scalars['uuid']['input'];
  capabilityId: Scalars['uuid']['input'];
  processId: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteCapabilityBusinessProcessMapArgs = {
  where: CapabilityBusinessProcessMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteCapabilityBusinessProcessMapByPkArgs = {
  capabilityId: Scalars['uuid']['input'];
  processId: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteCapabilityByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteCapabilityHierarchyMapArgs = {
  where: CapabilityHierarchyMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteCapabilityHierarchyMapByPkArgs = {
  childId: Scalars['uuid']['input'];
  parentId: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteDataObjectArgs = {
  where: DataObject_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteDataObjectByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteDirectoryItemsMapArgs = {
  where: DirectoryItemsMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteDirectoryItemsMapByPkArgs = {
  sourceId: Scalars['uuid']['input'];
  targetId: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteDirectoryObjectArgs = {
  where: DirectoryObject_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteDirectoryObjectByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteEmployeeArgs = {
  where: Employee_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteEmployeeByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteEventGenericArgs = {
  where: EventGeneric_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteEventGenericByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteFlowGenericArgs = {
  where: FlowGeneric_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteFlowGenericByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteFunctionGenericArgs = {
  where: FunctionGeneric_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteFunctionGenericByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteInterfaceGenericArgs = {
  where: InterfaceGeneric_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteInterfaceGenericByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteMotivationElementGenericArgs = {
  where: MotivationElementGeneric_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteMotivationElementGenericByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteMotivationItemHierarchyMapArgs = {
  where: MotivationItemHierarchyMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteMotivationItemHierarchyMapByPkArgs = {
  childId: Scalars['uuid']['input'];
  parentId: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeletePhysicalLocationArgs = {
  where: PhysicalLocation_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeletePhysicalLocationByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeletePlateauArgs = {
  where: Plateau_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeletePlateauByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteProcessGenericArgs = {
  where: ProcessGeneric_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteProcessGenericByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteServiceGenericArgs = {
  where: ServiceGeneric_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteServiceGenericByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteSolutionArgs = {
  where: Solution_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteSolutionApplicationComponentMapArgs = {
  where: SolutionApplicationComponentMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteSolutionApplicationComponentMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  solutionId: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteSolutionApplicationFunctionMapArgs = {
  where: SolutionApplicationFunctionMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteSolutionApplicationFunctionMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  functionId: Scalars['uuid']['input'];
  solutionId: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteSolutionByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteSolutionDataObjectMapArgs = {
  where: SolutionDataObjectMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteSolutionDataObjectMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  dataObjectId: Scalars['uuid']['input'];
  solutionId: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteSolutionFlowMapArgs = {
  where: SolutionFlowMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteSolutionFlowMapByPkArgs = {
  flowId: Scalars['uuid']['input'];
  solutionId: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteSolutionMotivationComponentMapArgs = {
  where: SolutionMotivationComponentMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteSolutionMotivationComponentMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  motivationId: Scalars['uuid']['input'];
  solutionId: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteSolutionMotivationElementMapArgs = {
  where: SolutionMotivationElementMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteSolutionMotivationElementMapByPkArgs = {
  motivationId: Scalars['uuid']['input'];
  solutionId: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteSolutionStakeholderMapArgs = {
  where: SolutionStakeholderMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteSolutionStakeholderMapByPkArgs = {
  solutionId: Scalars['uuid']['input'];
  stakeholderId: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteSolutionTechnologyNodeMapArgs = {
  where: SolutionTechnologyNodeMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteSolutionTechnologyNodeMapByPkArgs = {
  nodeId: Scalars['uuid']['input'];
  solutionId: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteStakeholderArgs = {
  where: Stakeholder_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteStakeholderByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteSystemSoftwareArgs = {
  where: SystemSoftware_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteSystemSoftwareByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteTechnologyNetworkArgs = {
  where: TechnologyNetwork_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteTechnologyNetworkByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteTechnologyNetworkHierarchyMapArgs = {
  where: TechnologyNetworkHierarchyMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteTechnologyNetworkHierarchyMapByPkArgs = {
  networkChildId: Scalars['uuid']['input'];
  networkParentId: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteTechnologyNodeArgs = {
  where: TechnologyNode_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteTechnologyNodeByPkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteTechnologyNodeHierarchyMapArgs = {
  where: TechnologyNodeHierarchyMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteTechnologyNodeHierarchyMapByPkArgs = {
  nodeChildId: Scalars['uuid']['input'];
  nodeParentId: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDeleteTechnologyNodeSystemSoftwareMapArgs = {
  where: TechnologyNodeSystemSoftwareMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDeleteTechnologyNodeSystemSoftwareMapByPkArgs = {
  nodeId: Scalars['uuid']['input'];
  systemSoftwareId: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_MapSolutionConstraintArgs = {
  where: MapSolutionConstraint_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_MapSolutionConstraint_By_PkArgs = {
  constraintId: Scalars['uuid']['input'];
  solutionId: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_MapTenantUserProfilesArgs = {
  where: MapTenantUserProfiles_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_MapTenantUserProfiles_By_PkArgs = {
  userId: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_TenantsArgs = {
  where: Tenants_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Tenants_By_PkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootDelete_UserProfilesArgs = {
  where: UserProfiles_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_UserProfiles_By_PkArgs = {
  id: Scalars['uuid']['input'];
};


/** mutation root */
export type Mutation_RootInsertApplicationComponentArgs = {
  objects: Array<ApplicationComponent_Insert_Input>;
  on_conflict?: InputMaybe<ApplicationComponent_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertApplicationComponentBusinessActorRoleMapArgs = {
  objects: Array<ApplicationComponentBusinessActorRoleMap_Insert_Input>;
  on_conflict?: InputMaybe<ApplicationComponentBusinessActorRoleMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertApplicationComponentBusinessActorRoleMapOneArgs = {
  object: ApplicationComponentBusinessActorRoleMap_Insert_Input;
  on_conflict?: InputMaybe<ApplicationComponentBusinessActorRoleMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertApplicationComponentDataObjectMapArgs = {
  objects: Array<ApplicationComponentDataObjectMap_Insert_Input>;
  on_conflict?: InputMaybe<ApplicationComponentDataObjectMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertApplicationComponentDataObjectMapOneArgs = {
  object: ApplicationComponentDataObjectMap_Insert_Input;
  on_conflict?: InputMaybe<ApplicationComponentDataObjectMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertApplicationComponentDirectoryMapArgs = {
  objects: Array<ApplicationComponentDirectoryMap_Insert_Input>;
  on_conflict?: InputMaybe<ApplicationComponentDirectoryMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertApplicationComponentDirectoryMapOneArgs = {
  object: ApplicationComponentDirectoryMap_Insert_Input;
  on_conflict?: InputMaybe<ApplicationComponentDirectoryMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertApplicationComponentEventMapArgs = {
  objects: Array<ApplicationComponentEventMap_Insert_Input>;
  on_conflict?: InputMaybe<ApplicationComponentEventMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertApplicationComponentEventMapOneArgs = {
  object: ApplicationComponentEventMap_Insert_Input;
  on_conflict?: InputMaybe<ApplicationComponentEventMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertApplicationComponentFunctionMapArgs = {
  objects: Array<ApplicationComponentFunctionMap_Insert_Input>;
  on_conflict?: InputMaybe<ApplicationComponentFunctionMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertApplicationComponentFunctionMapOneArgs = {
  object: ApplicationComponentFunctionMap_Insert_Input;
  on_conflict?: InputMaybe<ApplicationComponentFunctionMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertApplicationComponentHierarchyMapArgs = {
  objects: Array<ApplicationComponentHierarchyMap_Insert_Input>;
  on_conflict?: InputMaybe<ApplicationComponentHierarchyMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertApplicationComponentHierarchyMapOneArgs = {
  object: ApplicationComponentHierarchyMap_Insert_Input;
  on_conflict?: InputMaybe<ApplicationComponentHierarchyMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertApplicationComponentInterfaceMapArgs = {
  objects: Array<ApplicationComponentInterfaceMap_Insert_Input>;
  on_conflict?: InputMaybe<ApplicationComponentInterfaceMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertApplicationComponentInterfaceMapOneArgs = {
  object: ApplicationComponentInterfaceMap_Insert_Input;
  on_conflict?: InputMaybe<ApplicationComponentInterfaceMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertApplicationComponentOneArgs = {
  object: ApplicationComponent_Insert_Input;
  on_conflict?: InputMaybe<ApplicationComponent_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertApplicationComponentProductMapArgs = {
  objects: Array<ApplicationComponentProductMap_Insert_Input>;
  on_conflict?: InputMaybe<ApplicationComponentProductMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertApplicationComponentProductMapOneArgs = {
  object: ApplicationComponentProductMap_Insert_Input;
  on_conflict?: InputMaybe<ApplicationComponentProductMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertApplicationComponentStakeholderMapArgs = {
  objects: Array<ApplicationComponentStakeholderMap_Insert_Input>;
  on_conflict?: InputMaybe<ApplicationComponentStakeholderMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertApplicationComponentStakeholderMapOneArgs = {
  object: ApplicationComponentStakeholderMap_Insert_Input;
  on_conflict?: InputMaybe<ApplicationComponentStakeholderMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertApplicationComponentSystemSoftwareMapArgs = {
  objects: Array<ApplicationComponentSystemSoftwareMap_Insert_Input>;
  on_conflict?: InputMaybe<ApplicationComponentSystemSoftwareMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertApplicationComponentSystemSoftwareMapOneArgs = {
  object: ApplicationComponentSystemSoftwareMap_Insert_Input;
  on_conflict?: InputMaybe<ApplicationComponentSystemSoftwareMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertApplicationComponentTechnologyLogicalNetworkMapArgs = {
  objects: Array<ApplicationComponentTechnologyLogicalNetworkMap_Insert_Input>;
  on_conflict?: InputMaybe<ApplicationComponentTechnologyLogicalNetworkMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertApplicationComponentTechnologyLogicalNetworkMapOneArgs = {
  object: ApplicationComponentTechnologyLogicalNetworkMap_Insert_Input;
  on_conflict?: InputMaybe<ApplicationComponentTechnologyLogicalNetworkMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertApplicationComponentTechnologyNodeMapArgs = {
  objects: Array<ApplicationComponentTechnologyNodeMap_Insert_Input>;
  on_conflict?: InputMaybe<ApplicationComponentTechnologyNodeMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertApplicationComponentTechnologyNodeMapOneArgs = {
  object: ApplicationComponentTechnologyNodeMap_Insert_Input;
  on_conflict?: InputMaybe<ApplicationComponentTechnologyNodeMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertApplicationFunctionDataObjectMapArgs = {
  objects: Array<ApplicationFunctionDataObjectMap_Insert_Input>;
  on_conflict?: InputMaybe<ApplicationFunctionDataObjectMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertApplicationFunctionDataObjectMapOneArgs = {
  object: ApplicationFunctionDataObjectMap_Insert_Input;
  on_conflict?: InputMaybe<ApplicationFunctionDataObjectMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertApplicationFunctionInterfaceMapArgs = {
  objects: Array<ApplicationFunctionInterfaceMap_Insert_Input>;
  on_conflict?: InputMaybe<ApplicationFunctionInterfaceMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertApplicationFunctionInterfaceMapOneArgs = {
  object: ApplicationFunctionInterfaceMap_Insert_Input;
  on_conflict?: InputMaybe<ApplicationFunctionInterfaceMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertBusinessActorArgs = {
  objects: Array<BusinessActor_Insert_Input>;
  on_conflict?: InputMaybe<BusinessActor_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertBusinessActorOneArgs = {
  object: BusinessActor_Insert_Input;
  on_conflict?: InputMaybe<BusinessActor_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertBusinessActorRoleMapArgs = {
  objects: Array<BusinessActorRoleMap_Insert_Input>;
  on_conflict?: InputMaybe<BusinessActorRoleMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertBusinessActorRoleMapOneArgs = {
  object: BusinessActorRoleMap_Insert_Input;
  on_conflict?: InputMaybe<BusinessActorRoleMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertBusinessProcessFunctionMapArgs = {
  objects: Array<BusinessProcessFunctionMap_Insert_Input>;
  on_conflict?: InputMaybe<BusinessProcessFunctionMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertBusinessProcessFunctionMapOneArgs = {
  object: BusinessProcessFunctionMap_Insert_Input;
  on_conflict?: InputMaybe<BusinessProcessFunctionMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertBusinessProcessHierarchyMapArgs = {
  objects: Array<BusinessProcessHierarchyMap_Insert_Input>;
  on_conflict?: InputMaybe<BusinessProcessHierarchyMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertBusinessProcessHierarchyMapOneArgs = {
  object: BusinessProcessHierarchyMap_Insert_Input;
  on_conflict?: InputMaybe<BusinessProcessHierarchyMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertBusinessProcessMotivationItemMapArgs = {
  objects: Array<BusinessProcessMotivationItemMap_Insert_Input>;
  on_conflict?: InputMaybe<BusinessProcessMotivationItemMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertBusinessProcessMotivationItemMapOneArgs = {
  object: BusinessProcessMotivationItemMap_Insert_Input;
  on_conflict?: InputMaybe<BusinessProcessMotivationItemMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertBusinessProductArgs = {
  objects: Array<BusinessProduct_Insert_Input>;
  on_conflict?: InputMaybe<BusinessProduct_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertBusinessProductOneArgs = {
  object: BusinessProduct_Insert_Input;
  on_conflict?: InputMaybe<BusinessProduct_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertBusinessRoleArgs = {
  objects: Array<BusinessRole_Insert_Input>;
  on_conflict?: InputMaybe<BusinessRole_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertBusinessRoleOneArgs = {
  object: BusinessRole_Insert_Input;
  on_conflict?: InputMaybe<BusinessRole_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertCapabilityArgs = {
  objects: Array<Capability_Insert_Input>;
  on_conflict?: InputMaybe<Capability_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertCapabilityApplicationComponentAssessmentMapArgs = {
  objects: Array<CapabilityApplicationComponentAssessmentMap_Insert_Input>;
  on_conflict?: InputMaybe<CapabilityApplicationComponentAssessmentMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertCapabilityApplicationComponentAssessmentMapOneArgs = {
  object: CapabilityApplicationComponentAssessmentMap_Insert_Input;
  on_conflict?: InputMaybe<CapabilityApplicationComponentAssessmentMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertCapabilityApplicationComponentMapArgs = {
  objects: Array<CapabilityApplicationComponentMap_Insert_Input>;
  on_conflict?: InputMaybe<CapabilityApplicationComponentMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertCapabilityApplicationComponentMapOneArgs = {
  object: CapabilityApplicationComponentMap_Insert_Input;
  on_conflict?: InputMaybe<CapabilityApplicationComponentMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertCapabilityBusinessProcessAssessmentMapArgs = {
  objects: Array<CapabilityBusinessProcessAssessmentMap_Insert_Input>;
  on_conflict?: InputMaybe<CapabilityBusinessProcessAssessmentMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertCapabilityBusinessProcessAssessmentMapOneArgs = {
  object: CapabilityBusinessProcessAssessmentMap_Insert_Input;
  on_conflict?: InputMaybe<CapabilityBusinessProcessAssessmentMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertCapabilityBusinessProcessMapArgs = {
  objects: Array<CapabilityBusinessProcessMap_Insert_Input>;
  on_conflict?: InputMaybe<CapabilityBusinessProcessMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertCapabilityBusinessProcessMapOneArgs = {
  object: CapabilityBusinessProcessMap_Insert_Input;
  on_conflict?: InputMaybe<CapabilityBusinessProcessMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertCapabilityHierarchyMapArgs = {
  objects: Array<CapabilityHierarchyMap_Insert_Input>;
  on_conflict?: InputMaybe<CapabilityHierarchyMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertCapabilityHierarchyMapOneArgs = {
  object: CapabilityHierarchyMap_Insert_Input;
  on_conflict?: InputMaybe<CapabilityHierarchyMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertCapabilityOneArgs = {
  object: Capability_Insert_Input;
  on_conflict?: InputMaybe<Capability_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertDataObjectArgs = {
  objects: Array<DataObject_Insert_Input>;
  on_conflict?: InputMaybe<DataObject_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertDataObjectOneArgs = {
  object: DataObject_Insert_Input;
  on_conflict?: InputMaybe<DataObject_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertDirectoryItemsMapArgs = {
  objects: Array<DirectoryItemsMap_Insert_Input>;
  on_conflict?: InputMaybe<DirectoryItemsMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertDirectoryItemsMapOneArgs = {
  object: DirectoryItemsMap_Insert_Input;
  on_conflict?: InputMaybe<DirectoryItemsMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertDirectoryObjectArgs = {
  objects: Array<DirectoryObject_Insert_Input>;
  on_conflict?: InputMaybe<DirectoryObject_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertDirectoryObjectOneArgs = {
  object: DirectoryObject_Insert_Input;
  on_conflict?: InputMaybe<DirectoryObject_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertEmployeeArgs = {
  objects: Array<Employee_Insert_Input>;
  on_conflict?: InputMaybe<Employee_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertEmployeeOneArgs = {
  object: Employee_Insert_Input;
  on_conflict?: InputMaybe<Employee_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertEventGenericArgs = {
  objects: Array<EventGeneric_Insert_Input>;
  on_conflict?: InputMaybe<EventGeneric_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertEventGenericOneArgs = {
  object: EventGeneric_Insert_Input;
  on_conflict?: InputMaybe<EventGeneric_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertFlowGenericArgs = {
  objects: Array<FlowGeneric_Insert_Input>;
  on_conflict?: InputMaybe<FlowGeneric_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertFlowGenericOneArgs = {
  object: FlowGeneric_Insert_Input;
  on_conflict?: InputMaybe<FlowGeneric_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertFunctionGenericArgs = {
  objects: Array<FunctionGeneric_Insert_Input>;
  on_conflict?: InputMaybe<FunctionGeneric_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertFunctionGenericOneArgs = {
  object: FunctionGeneric_Insert_Input;
  on_conflict?: InputMaybe<FunctionGeneric_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertInterfaceGenericArgs = {
  objects: Array<InterfaceGeneric_Insert_Input>;
  on_conflict?: InputMaybe<InterfaceGeneric_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertInterfaceGenericOneArgs = {
  object: InterfaceGeneric_Insert_Input;
  on_conflict?: InputMaybe<InterfaceGeneric_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertMotivationElementGenericArgs = {
  objects: Array<MotivationElementGeneric_Insert_Input>;
  on_conflict?: InputMaybe<MotivationElementGeneric_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertMotivationElementGenericOneArgs = {
  object: MotivationElementGeneric_Insert_Input;
  on_conflict?: InputMaybe<MotivationElementGeneric_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertMotivationItemHierarchyMapArgs = {
  objects: Array<MotivationItemHierarchyMap_Insert_Input>;
  on_conflict?: InputMaybe<MotivationItemHierarchyMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertMotivationItemHierarchyMapOneArgs = {
  object: MotivationItemHierarchyMap_Insert_Input;
  on_conflict?: InputMaybe<MotivationItemHierarchyMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertPhysicalLocationArgs = {
  objects: Array<PhysicalLocation_Insert_Input>;
  on_conflict?: InputMaybe<PhysicalLocation_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertPhysicalLocationOneArgs = {
  object: PhysicalLocation_Insert_Input;
  on_conflict?: InputMaybe<PhysicalLocation_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertPlateauArgs = {
  objects: Array<Plateau_Insert_Input>;
  on_conflict?: InputMaybe<Plateau_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertPlateauOneArgs = {
  object: Plateau_Insert_Input;
  on_conflict?: InputMaybe<Plateau_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertProcessGenericArgs = {
  objects: Array<ProcessGeneric_Insert_Input>;
  on_conflict?: InputMaybe<ProcessGeneric_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertProcessGenericOneArgs = {
  object: ProcessGeneric_Insert_Input;
  on_conflict?: InputMaybe<ProcessGeneric_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertServiceGenericArgs = {
  objects: Array<ServiceGeneric_Insert_Input>;
  on_conflict?: InputMaybe<ServiceGeneric_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertServiceGenericOneArgs = {
  object: ServiceGeneric_Insert_Input;
  on_conflict?: InputMaybe<ServiceGeneric_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertSolutionArgs = {
  objects: Array<Solution_Insert_Input>;
  on_conflict?: InputMaybe<Solution_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertSolutionApplicationComponentMapArgs = {
  objects: Array<SolutionApplicationComponentMap_Insert_Input>;
  on_conflict?: InputMaybe<SolutionApplicationComponentMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertSolutionApplicationComponentMapOneArgs = {
  object: SolutionApplicationComponentMap_Insert_Input;
  on_conflict?: InputMaybe<SolutionApplicationComponentMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertSolutionApplicationFunctionMapArgs = {
  objects: Array<SolutionApplicationFunctionMap_Insert_Input>;
  on_conflict?: InputMaybe<SolutionApplicationFunctionMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertSolutionApplicationFunctionMapOneArgs = {
  object: SolutionApplicationFunctionMap_Insert_Input;
  on_conflict?: InputMaybe<SolutionApplicationFunctionMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertSolutionDataObjectMapArgs = {
  objects: Array<SolutionDataObjectMap_Insert_Input>;
  on_conflict?: InputMaybe<SolutionDataObjectMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertSolutionDataObjectMapOneArgs = {
  object: SolutionDataObjectMap_Insert_Input;
  on_conflict?: InputMaybe<SolutionDataObjectMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertSolutionFlowMapArgs = {
  objects: Array<SolutionFlowMap_Insert_Input>;
  on_conflict?: InputMaybe<SolutionFlowMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertSolutionFlowMapOneArgs = {
  object: SolutionFlowMap_Insert_Input;
  on_conflict?: InputMaybe<SolutionFlowMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertSolutionMotivationComponentMapArgs = {
  objects: Array<SolutionMotivationComponentMap_Insert_Input>;
  on_conflict?: InputMaybe<SolutionMotivationComponentMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertSolutionMotivationComponentMapOneArgs = {
  object: SolutionMotivationComponentMap_Insert_Input;
  on_conflict?: InputMaybe<SolutionMotivationComponentMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertSolutionMotivationElementMapArgs = {
  objects: Array<SolutionMotivationElementMap_Insert_Input>;
  on_conflict?: InputMaybe<SolutionMotivationElementMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertSolutionMotivationElementMapOneArgs = {
  object: SolutionMotivationElementMap_Insert_Input;
  on_conflict?: InputMaybe<SolutionMotivationElementMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertSolutionOneArgs = {
  object: Solution_Insert_Input;
  on_conflict?: InputMaybe<Solution_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertSolutionStakeholderMapArgs = {
  objects: Array<SolutionStakeholderMap_Insert_Input>;
  on_conflict?: InputMaybe<SolutionStakeholderMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertSolutionStakeholderMapOneArgs = {
  object: SolutionStakeholderMap_Insert_Input;
  on_conflict?: InputMaybe<SolutionStakeholderMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertSolutionTechnologyNodeMapArgs = {
  objects: Array<SolutionTechnologyNodeMap_Insert_Input>;
  on_conflict?: InputMaybe<SolutionTechnologyNodeMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertSolutionTechnologyNodeMapOneArgs = {
  object: SolutionTechnologyNodeMap_Insert_Input;
  on_conflict?: InputMaybe<SolutionTechnologyNodeMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertStakeholderArgs = {
  objects: Array<Stakeholder_Insert_Input>;
  on_conflict?: InputMaybe<Stakeholder_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertStakeholderOneArgs = {
  object: Stakeholder_Insert_Input;
  on_conflict?: InputMaybe<Stakeholder_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertSystemSoftwareArgs = {
  objects: Array<SystemSoftware_Insert_Input>;
  on_conflict?: InputMaybe<SystemSoftware_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertSystemSoftwareOneArgs = {
  object: SystemSoftware_Insert_Input;
  on_conflict?: InputMaybe<SystemSoftware_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertTechnologyNetworkArgs = {
  objects: Array<TechnologyNetwork_Insert_Input>;
  on_conflict?: InputMaybe<TechnologyNetwork_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertTechnologyNetworkHierarchyMapArgs = {
  objects: Array<TechnologyNetworkHierarchyMap_Insert_Input>;
  on_conflict?: InputMaybe<TechnologyNetworkHierarchyMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertTechnologyNetworkHierarchyMapOneArgs = {
  object: TechnologyNetworkHierarchyMap_Insert_Input;
  on_conflict?: InputMaybe<TechnologyNetworkHierarchyMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertTechnologyNetworkOneArgs = {
  object: TechnologyNetwork_Insert_Input;
  on_conflict?: InputMaybe<TechnologyNetwork_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertTechnologyNodeArgs = {
  objects: Array<TechnologyNode_Insert_Input>;
  on_conflict?: InputMaybe<TechnologyNode_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertTechnologyNodeHierarchyMapArgs = {
  objects: Array<TechnologyNodeHierarchyMap_Insert_Input>;
  on_conflict?: InputMaybe<TechnologyNodeHierarchyMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertTechnologyNodeHierarchyMapOneArgs = {
  object: TechnologyNodeHierarchyMap_Insert_Input;
  on_conflict?: InputMaybe<TechnologyNodeHierarchyMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertTechnologyNodeOneArgs = {
  object: TechnologyNode_Insert_Input;
  on_conflict?: InputMaybe<TechnologyNode_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertTechnologyNodeSystemSoftwareMapArgs = {
  objects: Array<TechnologyNodeSystemSoftwareMap_Insert_Input>;
  on_conflict?: InputMaybe<TechnologyNodeSystemSoftwareMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsertTechnologyNodeSystemSoftwareMapOneArgs = {
  object: TechnologyNodeSystemSoftwareMap_Insert_Input;
  on_conflict?: InputMaybe<TechnologyNodeSystemSoftwareMap_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_MapSolutionConstraintArgs = {
  objects: Array<MapSolutionConstraint_Insert_Input>;
  on_conflict?: InputMaybe<MapSolutionConstraint_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_MapSolutionConstraint_OneArgs = {
  object: MapSolutionConstraint_Insert_Input;
  on_conflict?: InputMaybe<MapSolutionConstraint_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_MapTenantUserProfilesArgs = {
  objects: Array<MapTenantUserProfiles_Insert_Input>;
  on_conflict?: InputMaybe<MapTenantUserProfiles_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_MapTenantUserProfiles_OneArgs = {
  object: MapTenantUserProfiles_Insert_Input;
  on_conflict?: InputMaybe<MapTenantUserProfiles_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_TenantsArgs = {
  objects: Array<Tenants_Insert_Input>;
  on_conflict?: InputMaybe<Tenants_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Tenants_OneArgs = {
  object: Tenants_Insert_Input;
  on_conflict?: InputMaybe<Tenants_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_UserProfilesArgs = {
  objects: Array<UserProfiles_Insert_Input>;
  on_conflict?: InputMaybe<UserProfiles_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_UserProfiles_OneArgs = {
  object: UserProfiles_Insert_Input;
  on_conflict?: InputMaybe<UserProfiles_On_Conflict>;
};


/** mutation root */
export type Mutation_RootUpdateApplicationComponentArgs = {
  _set?: InputMaybe<ApplicationComponent_Set_Input>;
  where: ApplicationComponent_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateApplicationComponentBusinessActorRoleMapArgs = {
  _set?: InputMaybe<ApplicationComponentBusinessActorRoleMap_Set_Input>;
  where: ApplicationComponentBusinessActorRoleMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateApplicationComponentBusinessActorRoleMapByPkArgs = {
  _set?: InputMaybe<ApplicationComponentBusinessActorRoleMap_Set_Input>;
  pk_columns: ApplicationComponentBusinessActorRoleMap_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateApplicationComponentByPkArgs = {
  _set?: InputMaybe<ApplicationComponent_Set_Input>;
  pk_columns: ApplicationComponent_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateApplicationComponentDataObjectMapArgs = {
  _set?: InputMaybe<ApplicationComponentDataObjectMap_Set_Input>;
  where: ApplicationComponentDataObjectMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateApplicationComponentDataObjectMapByPkArgs = {
  _set?: InputMaybe<ApplicationComponentDataObjectMap_Set_Input>;
  pk_columns: ApplicationComponentDataObjectMap_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateApplicationComponentDirectoryMapArgs = {
  _set?: InputMaybe<ApplicationComponentDirectoryMap_Set_Input>;
  where: ApplicationComponentDirectoryMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateApplicationComponentDirectoryMapByPkArgs = {
  _set?: InputMaybe<ApplicationComponentDirectoryMap_Set_Input>;
  pk_columns: ApplicationComponentDirectoryMap_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateApplicationComponentEventMapArgs = {
  _set?: InputMaybe<ApplicationComponentEventMap_Set_Input>;
  where: ApplicationComponentEventMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateApplicationComponentEventMapByPkArgs = {
  _set?: InputMaybe<ApplicationComponentEventMap_Set_Input>;
  pk_columns: ApplicationComponentEventMap_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateApplicationComponentFunctionMapArgs = {
  _set?: InputMaybe<ApplicationComponentFunctionMap_Set_Input>;
  where: ApplicationComponentFunctionMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateApplicationComponentFunctionMapByPkArgs = {
  _set?: InputMaybe<ApplicationComponentFunctionMap_Set_Input>;
  pk_columns: ApplicationComponentFunctionMap_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateApplicationComponentHierarchyMapArgs = {
  _inc?: InputMaybe<ApplicationComponentHierarchyMap_Inc_Input>;
  _set?: InputMaybe<ApplicationComponentHierarchyMap_Set_Input>;
  where: ApplicationComponentHierarchyMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateApplicationComponentHierarchyMapByPkArgs = {
  _inc?: InputMaybe<ApplicationComponentHierarchyMap_Inc_Input>;
  _set?: InputMaybe<ApplicationComponentHierarchyMap_Set_Input>;
  pk_columns: ApplicationComponentHierarchyMap_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateApplicationComponentInterfaceMapArgs = {
  _set?: InputMaybe<ApplicationComponentInterfaceMap_Set_Input>;
  where: ApplicationComponentInterfaceMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateApplicationComponentInterfaceMapByPkArgs = {
  _set?: InputMaybe<ApplicationComponentInterfaceMap_Set_Input>;
  pk_columns: ApplicationComponentInterfaceMap_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateApplicationComponentProductMapArgs = {
  _set?: InputMaybe<ApplicationComponentProductMap_Set_Input>;
  where: ApplicationComponentProductMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateApplicationComponentProductMapByPkArgs = {
  _set?: InputMaybe<ApplicationComponentProductMap_Set_Input>;
  pk_columns: ApplicationComponentProductMap_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateApplicationComponentStakeholderMapArgs = {
  _set?: InputMaybe<ApplicationComponentStakeholderMap_Set_Input>;
  where: ApplicationComponentStakeholderMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateApplicationComponentStakeholderMapByPkArgs = {
  _set?: InputMaybe<ApplicationComponentStakeholderMap_Set_Input>;
  pk_columns: ApplicationComponentStakeholderMap_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateApplicationComponentSystemSoftwareMapArgs = {
  _set?: InputMaybe<ApplicationComponentSystemSoftwareMap_Set_Input>;
  where: ApplicationComponentSystemSoftwareMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateApplicationComponentSystemSoftwareMapByPkArgs = {
  _set?: InputMaybe<ApplicationComponentSystemSoftwareMap_Set_Input>;
  pk_columns: ApplicationComponentSystemSoftwareMap_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateApplicationComponentTechnologyLogicalNetworkMapArgs = {
  _set?: InputMaybe<ApplicationComponentTechnologyLogicalNetworkMap_Set_Input>;
  where: ApplicationComponentTechnologyLogicalNetworkMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateApplicationComponentTechnologyLogicalNetworkMapByPkArgs = {
  _set?: InputMaybe<ApplicationComponentTechnologyLogicalNetworkMap_Set_Input>;
  pk_columns: ApplicationComponentTechnologyLogicalNetworkMap_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateApplicationComponentTechnologyNodeMapArgs = {
  _set?: InputMaybe<ApplicationComponentTechnologyNodeMap_Set_Input>;
  where: ApplicationComponentTechnologyNodeMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateApplicationComponentTechnologyNodeMapByPkArgs = {
  _set?: InputMaybe<ApplicationComponentTechnologyNodeMap_Set_Input>;
  pk_columns: ApplicationComponentTechnologyNodeMap_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateApplicationFunctionDataObjectMapArgs = {
  _set?: InputMaybe<ApplicationFunctionDataObjectMap_Set_Input>;
  where: ApplicationFunctionDataObjectMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateApplicationFunctionDataObjectMapByPkArgs = {
  _set?: InputMaybe<ApplicationFunctionDataObjectMap_Set_Input>;
  pk_columns: ApplicationFunctionDataObjectMap_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateApplicationFunctionInterfaceMapArgs = {
  _set?: InputMaybe<ApplicationFunctionInterfaceMap_Set_Input>;
  where: ApplicationFunctionInterfaceMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateApplicationFunctionInterfaceMapByPkArgs = {
  _set?: InputMaybe<ApplicationFunctionInterfaceMap_Set_Input>;
  pk_columns: ApplicationFunctionInterfaceMap_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateBusinessActorArgs = {
  _set?: InputMaybe<BusinessActor_Set_Input>;
  where: BusinessActor_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateBusinessActorByPkArgs = {
  _set?: InputMaybe<BusinessActor_Set_Input>;
  pk_columns: BusinessActor_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateBusinessActorRoleMapArgs = {
  _set?: InputMaybe<BusinessActorRoleMap_Set_Input>;
  where: BusinessActorRoleMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateBusinessActorRoleMapByPkArgs = {
  _set?: InputMaybe<BusinessActorRoleMap_Set_Input>;
  pk_columns: BusinessActorRoleMap_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateBusinessProcessFunctionMapArgs = {
  _set?: InputMaybe<BusinessProcessFunctionMap_Set_Input>;
  where: BusinessProcessFunctionMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateBusinessProcessFunctionMapByPkArgs = {
  _set?: InputMaybe<BusinessProcessFunctionMap_Set_Input>;
  pk_columns: BusinessProcessFunctionMap_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateBusinessProcessHierarchyMapArgs = {
  _set?: InputMaybe<BusinessProcessHierarchyMap_Set_Input>;
  where: BusinessProcessHierarchyMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateBusinessProcessHierarchyMapByPkArgs = {
  _set?: InputMaybe<BusinessProcessHierarchyMap_Set_Input>;
  pk_columns: BusinessProcessHierarchyMap_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateBusinessProcessMotivationItemMapArgs = {
  _set?: InputMaybe<BusinessProcessMotivationItemMap_Set_Input>;
  where: BusinessProcessMotivationItemMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateBusinessProcessMotivationItemMapByPkArgs = {
  _set?: InputMaybe<BusinessProcessMotivationItemMap_Set_Input>;
  pk_columns: BusinessProcessMotivationItemMap_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateBusinessProductArgs = {
  _set?: InputMaybe<BusinessProduct_Set_Input>;
  where: BusinessProduct_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateBusinessProductByPkArgs = {
  _set?: InputMaybe<BusinessProduct_Set_Input>;
  pk_columns: BusinessProduct_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateBusinessRoleArgs = {
  _set?: InputMaybe<BusinessRole_Set_Input>;
  where: BusinessRole_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateBusinessRoleByPkArgs = {
  _set?: InputMaybe<BusinessRole_Set_Input>;
  pk_columns: BusinessRole_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateCapabilityArgs = {
  _set?: InputMaybe<Capability_Set_Input>;
  where: Capability_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateCapabilityApplicationComponentAssessmentMapArgs = {
  _set?: InputMaybe<CapabilityApplicationComponentAssessmentMap_Set_Input>;
  where: CapabilityApplicationComponentAssessmentMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateCapabilityApplicationComponentAssessmentMapByPkArgs = {
  _set?: InputMaybe<CapabilityApplicationComponentAssessmentMap_Set_Input>;
  pk_columns: CapabilityApplicationComponentAssessmentMap_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateCapabilityApplicationComponentMapArgs = {
  _set?: InputMaybe<CapabilityApplicationComponentMap_Set_Input>;
  where: CapabilityApplicationComponentMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateCapabilityApplicationComponentMapByPkArgs = {
  _set?: InputMaybe<CapabilityApplicationComponentMap_Set_Input>;
  pk_columns: CapabilityApplicationComponentMap_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateCapabilityBusinessProcessAssessmentMapArgs = {
  _set?: InputMaybe<CapabilityBusinessProcessAssessmentMap_Set_Input>;
  where: CapabilityBusinessProcessAssessmentMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateCapabilityBusinessProcessAssessmentMapByPkArgs = {
  _set?: InputMaybe<CapabilityBusinessProcessAssessmentMap_Set_Input>;
  pk_columns: CapabilityBusinessProcessAssessmentMap_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateCapabilityBusinessProcessMapArgs = {
  _set?: InputMaybe<CapabilityBusinessProcessMap_Set_Input>;
  where: CapabilityBusinessProcessMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateCapabilityBusinessProcessMapByPkArgs = {
  _set?: InputMaybe<CapabilityBusinessProcessMap_Set_Input>;
  pk_columns: CapabilityBusinessProcessMap_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateCapabilityByPkArgs = {
  _set?: InputMaybe<Capability_Set_Input>;
  pk_columns: Capability_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateCapabilityHierarchyMapArgs = {
  _inc?: InputMaybe<CapabilityHierarchyMap_Inc_Input>;
  _set?: InputMaybe<CapabilityHierarchyMap_Set_Input>;
  where: CapabilityHierarchyMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateCapabilityHierarchyMapByPkArgs = {
  _inc?: InputMaybe<CapabilityHierarchyMap_Inc_Input>;
  _set?: InputMaybe<CapabilityHierarchyMap_Set_Input>;
  pk_columns: CapabilityHierarchyMap_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateDataObjectArgs = {
  _set?: InputMaybe<DataObject_Set_Input>;
  where: DataObject_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateDataObjectByPkArgs = {
  _set?: InputMaybe<DataObject_Set_Input>;
  pk_columns: DataObject_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateDirectoryItemsMapArgs = {
  _set?: InputMaybe<DirectoryItemsMap_Set_Input>;
  where: DirectoryItemsMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateDirectoryItemsMapByPkArgs = {
  _set?: InputMaybe<DirectoryItemsMap_Set_Input>;
  pk_columns: DirectoryItemsMap_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateDirectoryObjectArgs = {
  _set?: InputMaybe<DirectoryObject_Set_Input>;
  where: DirectoryObject_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateDirectoryObjectByPkArgs = {
  _set?: InputMaybe<DirectoryObject_Set_Input>;
  pk_columns: DirectoryObject_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateEmployeeArgs = {
  _set?: InputMaybe<Employee_Set_Input>;
  where: Employee_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateEmployeeByPkArgs = {
  _set?: InputMaybe<Employee_Set_Input>;
  pk_columns: Employee_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateEventGenericArgs = {
  _set?: InputMaybe<EventGeneric_Set_Input>;
  where: EventGeneric_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateEventGenericByPkArgs = {
  _set?: InputMaybe<EventGeneric_Set_Input>;
  pk_columns: EventGeneric_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateFlowGenericArgs = {
  _set?: InputMaybe<FlowGeneric_Set_Input>;
  where: FlowGeneric_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateFlowGenericByPkArgs = {
  _set?: InputMaybe<FlowGeneric_Set_Input>;
  pk_columns: FlowGeneric_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateFunctionGenericArgs = {
  _set?: InputMaybe<FunctionGeneric_Set_Input>;
  where: FunctionGeneric_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateFunctionGenericByPkArgs = {
  _set?: InputMaybe<FunctionGeneric_Set_Input>;
  pk_columns: FunctionGeneric_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateInterfaceGenericArgs = {
  _set?: InputMaybe<InterfaceGeneric_Set_Input>;
  where: InterfaceGeneric_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateInterfaceGenericByPkArgs = {
  _set?: InputMaybe<InterfaceGeneric_Set_Input>;
  pk_columns: InterfaceGeneric_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateMotivationElementGenericArgs = {
  _inc?: InputMaybe<MotivationElementGeneric_Inc_Input>;
  _set?: InputMaybe<MotivationElementGeneric_Set_Input>;
  where: MotivationElementGeneric_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateMotivationElementGenericByPkArgs = {
  _inc?: InputMaybe<MotivationElementGeneric_Inc_Input>;
  _set?: InputMaybe<MotivationElementGeneric_Set_Input>;
  pk_columns: MotivationElementGeneric_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateMotivationItemHierarchyMapArgs = {
  _set?: InputMaybe<MotivationItemHierarchyMap_Set_Input>;
  where: MotivationItemHierarchyMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateMotivationItemHierarchyMapByPkArgs = {
  _set?: InputMaybe<MotivationItemHierarchyMap_Set_Input>;
  pk_columns: MotivationItemHierarchyMap_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdatePhysicalLocationArgs = {
  _set?: InputMaybe<PhysicalLocation_Set_Input>;
  where: PhysicalLocation_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdatePhysicalLocationByPkArgs = {
  _set?: InputMaybe<PhysicalLocation_Set_Input>;
  pk_columns: PhysicalLocation_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdatePlateauArgs = {
  _set?: InputMaybe<Plateau_Set_Input>;
  where: Plateau_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdatePlateauByPkArgs = {
  _set?: InputMaybe<Plateau_Set_Input>;
  pk_columns: Plateau_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateProcessGenericArgs = {
  _set?: InputMaybe<ProcessGeneric_Set_Input>;
  where: ProcessGeneric_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateProcessGenericByPkArgs = {
  _set?: InputMaybe<ProcessGeneric_Set_Input>;
  pk_columns: ProcessGeneric_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateServiceGenericArgs = {
  _set?: InputMaybe<ServiceGeneric_Set_Input>;
  where: ServiceGeneric_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateServiceGenericByPkArgs = {
  _set?: InputMaybe<ServiceGeneric_Set_Input>;
  pk_columns: ServiceGeneric_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateSolutionArgs = {
  _set?: InputMaybe<Solution_Set_Input>;
  where: Solution_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateSolutionApplicationComponentMapArgs = {
  _set?: InputMaybe<SolutionApplicationComponentMap_Set_Input>;
  where: SolutionApplicationComponentMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateSolutionApplicationComponentMapByPkArgs = {
  _set?: InputMaybe<SolutionApplicationComponentMap_Set_Input>;
  pk_columns: SolutionApplicationComponentMap_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateSolutionApplicationFunctionMapArgs = {
  _set?: InputMaybe<SolutionApplicationFunctionMap_Set_Input>;
  where: SolutionApplicationFunctionMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateSolutionApplicationFunctionMapByPkArgs = {
  _set?: InputMaybe<SolutionApplicationFunctionMap_Set_Input>;
  pk_columns: SolutionApplicationFunctionMap_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateSolutionByPkArgs = {
  _set?: InputMaybe<Solution_Set_Input>;
  pk_columns: Solution_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateSolutionDataObjectMapArgs = {
  _set?: InputMaybe<SolutionDataObjectMap_Set_Input>;
  where: SolutionDataObjectMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateSolutionDataObjectMapByPkArgs = {
  _set?: InputMaybe<SolutionDataObjectMap_Set_Input>;
  pk_columns: SolutionDataObjectMap_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateSolutionFlowMapArgs = {
  _set?: InputMaybe<SolutionFlowMap_Set_Input>;
  where: SolutionFlowMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateSolutionFlowMapByPkArgs = {
  _set?: InputMaybe<SolutionFlowMap_Set_Input>;
  pk_columns: SolutionFlowMap_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateSolutionMotivationComponentMapArgs = {
  _set?: InputMaybe<SolutionMotivationComponentMap_Set_Input>;
  where: SolutionMotivationComponentMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateSolutionMotivationComponentMapByPkArgs = {
  _set?: InputMaybe<SolutionMotivationComponentMap_Set_Input>;
  pk_columns: SolutionMotivationComponentMap_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateSolutionMotivationElementMapArgs = {
  _set?: InputMaybe<SolutionMotivationElementMap_Set_Input>;
  where: SolutionMotivationElementMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateSolutionMotivationElementMapByPkArgs = {
  _set?: InputMaybe<SolutionMotivationElementMap_Set_Input>;
  pk_columns: SolutionMotivationElementMap_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateSolutionStakeholderMapArgs = {
  _set?: InputMaybe<SolutionStakeholderMap_Set_Input>;
  where: SolutionStakeholderMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateSolutionStakeholderMapByPkArgs = {
  _set?: InputMaybe<SolutionStakeholderMap_Set_Input>;
  pk_columns: SolutionStakeholderMap_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateSolutionTechnologyNodeMapArgs = {
  _set?: InputMaybe<SolutionTechnologyNodeMap_Set_Input>;
  where: SolutionTechnologyNodeMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateSolutionTechnologyNodeMapByPkArgs = {
  _set?: InputMaybe<SolutionTechnologyNodeMap_Set_Input>;
  pk_columns: SolutionTechnologyNodeMap_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateStakeholderArgs = {
  _set?: InputMaybe<Stakeholder_Set_Input>;
  where: Stakeholder_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateStakeholderByPkArgs = {
  _set?: InputMaybe<Stakeholder_Set_Input>;
  pk_columns: Stakeholder_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateSystemSoftwareArgs = {
  _set?: InputMaybe<SystemSoftware_Set_Input>;
  where: SystemSoftware_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateSystemSoftwareByPkArgs = {
  _set?: InputMaybe<SystemSoftware_Set_Input>;
  pk_columns: SystemSoftware_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateTechnologyNetworkArgs = {
  _set?: InputMaybe<TechnologyNetwork_Set_Input>;
  where: TechnologyNetwork_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateTechnologyNetworkByPkArgs = {
  _set?: InputMaybe<TechnologyNetwork_Set_Input>;
  pk_columns: TechnologyNetwork_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateTechnologyNetworkHierarchyMapArgs = {
  _inc?: InputMaybe<TechnologyNetworkHierarchyMap_Inc_Input>;
  _set?: InputMaybe<TechnologyNetworkHierarchyMap_Set_Input>;
  where: TechnologyNetworkHierarchyMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateTechnologyNetworkHierarchyMapByPkArgs = {
  _inc?: InputMaybe<TechnologyNetworkHierarchyMap_Inc_Input>;
  _set?: InputMaybe<TechnologyNetworkHierarchyMap_Set_Input>;
  pk_columns: TechnologyNetworkHierarchyMap_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateTechnologyNodeArgs = {
  _inc?: InputMaybe<TechnologyNode_Inc_Input>;
  _set?: InputMaybe<TechnologyNode_Set_Input>;
  where: TechnologyNode_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateTechnologyNodeByPkArgs = {
  _inc?: InputMaybe<TechnologyNode_Inc_Input>;
  _set?: InputMaybe<TechnologyNode_Set_Input>;
  pk_columns: TechnologyNode_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateTechnologyNodeHierarchyMapArgs = {
  _inc?: InputMaybe<TechnologyNodeHierarchyMap_Inc_Input>;
  _set?: InputMaybe<TechnologyNodeHierarchyMap_Set_Input>;
  where: TechnologyNodeHierarchyMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateTechnologyNodeHierarchyMapByPkArgs = {
  _inc?: InputMaybe<TechnologyNodeHierarchyMap_Inc_Input>;
  _set?: InputMaybe<TechnologyNodeHierarchyMap_Set_Input>;
  pk_columns: TechnologyNodeHierarchyMap_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdateTechnologyNodeSystemSoftwareMapArgs = {
  _set?: InputMaybe<TechnologyNodeSystemSoftwareMap_Set_Input>;
  where: TechnologyNodeSystemSoftwareMap_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdateTechnologyNodeSystemSoftwareMapByPkArgs = {
  _set?: InputMaybe<TechnologyNodeSystemSoftwareMap_Set_Input>;
  pk_columns: TechnologyNodeSystemSoftwareMap_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_ApplicationComponentBusinessActorRoleMap_ManyArgs = {
  updates: Array<ApplicationComponentBusinessActorRoleMap_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ApplicationComponentDataObjectMap_ManyArgs = {
  updates: Array<ApplicationComponentDataObjectMap_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ApplicationComponentDirectoryMap_ManyArgs = {
  updates: Array<ApplicationComponentDirectoryMap_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ApplicationComponentEventMap_ManyArgs = {
  updates: Array<ApplicationComponentEventMap_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ApplicationComponentFunctionMap_ManyArgs = {
  updates: Array<ApplicationComponentFunctionMap_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ApplicationComponentHierarchyMap_ManyArgs = {
  updates: Array<ApplicationComponentHierarchyMap_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ApplicationComponentInterfaceMap_ManyArgs = {
  updates: Array<ApplicationComponentInterfaceMap_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ApplicationComponentProductMap_ManyArgs = {
  updates: Array<ApplicationComponentProductMap_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ApplicationComponentStakeholderMap_ManyArgs = {
  updates: Array<ApplicationComponentStakeholderMap_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ApplicationComponentSystemSoftwareMap_ManyArgs = {
  updates: Array<ApplicationComponentSystemSoftwareMap_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ApplicationComponentTechnologyLogicalNetworkMap_ManyArgs = {
  updates: Array<ApplicationComponentTechnologyLogicalNetworkMap_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ApplicationComponentTechnologyNodeMap_ManyArgs = {
  updates: Array<ApplicationComponentTechnologyNodeMap_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ApplicationComponent_ManyArgs = {
  updates: Array<ApplicationComponent_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ApplicationFunctionDataObjectMap_ManyArgs = {
  updates: Array<ApplicationFunctionDataObjectMap_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ApplicationFunctionInterfaceMap_ManyArgs = {
  updates: Array<ApplicationFunctionInterfaceMap_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_BusinessActorRoleMap_ManyArgs = {
  updates: Array<BusinessActorRoleMap_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_BusinessActor_ManyArgs = {
  updates: Array<BusinessActor_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_BusinessProcessFunctionMap_ManyArgs = {
  updates: Array<BusinessProcessFunctionMap_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_BusinessProcessHierarchyMap_ManyArgs = {
  updates: Array<BusinessProcessHierarchyMap_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_BusinessProcessMotivationItemMap_ManyArgs = {
  updates: Array<BusinessProcessMotivationItemMap_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_BusinessProduct_ManyArgs = {
  updates: Array<BusinessProduct_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_BusinessRole_ManyArgs = {
  updates: Array<BusinessRole_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_CapabilityApplicationComponentAssessmentMap_ManyArgs = {
  updates: Array<CapabilityApplicationComponentAssessmentMap_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_CapabilityApplicationComponentMap_ManyArgs = {
  updates: Array<CapabilityApplicationComponentMap_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_CapabilityBusinessProcessAssessmentMap_ManyArgs = {
  updates: Array<CapabilityBusinessProcessAssessmentMap_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_CapabilityBusinessProcessMap_ManyArgs = {
  updates: Array<CapabilityBusinessProcessMap_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_CapabilityHierarchyMap_ManyArgs = {
  updates: Array<CapabilityHierarchyMap_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Capability_ManyArgs = {
  updates: Array<Capability_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_DataObject_ManyArgs = {
  updates: Array<DataObject_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_DirectoryItemsMap_ManyArgs = {
  updates: Array<DirectoryItemsMap_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_DirectoryObject_ManyArgs = {
  updates: Array<DirectoryObject_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Employee_ManyArgs = {
  updates: Array<Employee_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_EventGeneric_ManyArgs = {
  updates: Array<EventGeneric_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_FlowGeneric_ManyArgs = {
  updates: Array<FlowGeneric_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_FunctionGeneric_ManyArgs = {
  updates: Array<FunctionGeneric_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_InterfaceGeneric_ManyArgs = {
  updates: Array<InterfaceGeneric_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_MotivationElementGeneric_ManyArgs = {
  updates: Array<MotivationElementGeneric_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_MotivationItemHierarchyMap_ManyArgs = {
  updates: Array<MotivationItemHierarchyMap_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_PhysicalLocation_ManyArgs = {
  updates: Array<PhysicalLocation_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Plateau_ManyArgs = {
  updates: Array<Plateau_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ProcessGeneric_ManyArgs = {
  updates: Array<ProcessGeneric_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_ServiceGeneric_ManyArgs = {
  updates: Array<ServiceGeneric_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_SolutionApplicationComponentMap_ManyArgs = {
  updates: Array<SolutionApplicationComponentMap_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_SolutionApplicationFunctionMap_ManyArgs = {
  updates: Array<SolutionApplicationFunctionMap_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_SolutionDataObjectMap_ManyArgs = {
  updates: Array<SolutionDataObjectMap_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_SolutionFlowMap_ManyArgs = {
  updates: Array<SolutionFlowMap_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_SolutionMotivationComponentMap_ManyArgs = {
  updates: Array<SolutionMotivationComponentMap_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_SolutionMotivationElementMap_ManyArgs = {
  updates: Array<SolutionMotivationElementMap_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_SolutionStakeholderMap_ManyArgs = {
  updates: Array<SolutionStakeholderMap_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_SolutionTechnologyNodeMap_ManyArgs = {
  updates: Array<SolutionTechnologyNodeMap_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Solution_ManyArgs = {
  updates: Array<Solution_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_Stakeholder_ManyArgs = {
  updates: Array<Stakeholder_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_SystemSoftware_ManyArgs = {
  updates: Array<SystemSoftware_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_TechnologyNetworkHierarchyMap_ManyArgs = {
  updates: Array<TechnologyNetworkHierarchyMap_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_TechnologyNetwork_ManyArgs = {
  updates: Array<TechnologyNetwork_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_TechnologyNodeHierarchyMap_ManyArgs = {
  updates: Array<TechnologyNodeHierarchyMap_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_TechnologyNodeSystemSoftwareMap_ManyArgs = {
  updates: Array<TechnologyNodeSystemSoftwareMap_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_TechnologyNode_ManyArgs = {
  updates: Array<TechnologyNode_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_MapSolutionConstraintArgs = {
  _set?: InputMaybe<MapSolutionConstraint_Set_Input>;
  where: MapSolutionConstraint_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_MapSolutionConstraint_By_PkArgs = {
  _set?: InputMaybe<MapSolutionConstraint_Set_Input>;
  pk_columns: MapSolutionConstraint_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_MapSolutionConstraint_ManyArgs = {
  updates: Array<MapSolutionConstraint_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_MapTenantUserProfilesArgs = {
  _set?: InputMaybe<MapTenantUserProfiles_Set_Input>;
  where: MapTenantUserProfiles_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_MapTenantUserProfiles_By_PkArgs = {
  _set?: InputMaybe<MapTenantUserProfiles_Set_Input>;
  pk_columns: MapTenantUserProfiles_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_MapTenantUserProfiles_ManyArgs = {
  updates: Array<MapTenantUserProfiles_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_TenantsArgs = {
  _set?: InputMaybe<Tenants_Set_Input>;
  where: Tenants_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Tenants_By_PkArgs = {
  _set?: InputMaybe<Tenants_Set_Input>;
  pk_columns: Tenants_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Tenants_ManyArgs = {
  updates: Array<Tenants_Updates>;
};


/** mutation root */
export type Mutation_RootUpdate_UserProfilesArgs = {
  _set?: InputMaybe<UserProfiles_Set_Input>;
  where: UserProfiles_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_UserProfiles_By_PkArgs = {
  _set?: InputMaybe<UserProfiles_Set_Input>;
  pk_columns: UserProfiles_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_UserProfiles_ManyArgs = {
  updates: Array<UserProfiles_Updates>;
};

/** Boolean expression to compare columns of type "network_abstraction_level_enum". All fields are combined with logical 'AND'. */
export type Network_Abstraction_Level_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['network_abstraction_level_enum']['input']>;
  _gt?: InputMaybe<Scalars['network_abstraction_level_enum']['input']>;
  _gte?: InputMaybe<Scalars['network_abstraction_level_enum']['input']>;
  _in?: InputMaybe<Array<Scalars['network_abstraction_level_enum']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['network_abstraction_level_enum']['input']>;
  _lte?: InputMaybe<Scalars['network_abstraction_level_enum']['input']>;
  _neq?: InputMaybe<Scalars['network_abstraction_level_enum']['input']>;
  _nin?: InputMaybe<Array<Scalars['network_abstraction_level_enum']['input']>>;
};

/** Boolean expression to compare columns of type "network_scope_enum". All fields are combined with logical 'AND'. */
export type Network_Scope_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['network_scope_enum']['input']>;
  _gt?: InputMaybe<Scalars['network_scope_enum']['input']>;
  _gte?: InputMaybe<Scalars['network_scope_enum']['input']>;
  _in?: InputMaybe<Array<Scalars['network_scope_enum']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['network_scope_enum']['input']>;
  _lte?: InputMaybe<Scalars['network_scope_enum']['input']>;
  _neq?: InputMaybe<Scalars['network_scope_enum']['input']>;
  _nin?: InputMaybe<Array<Scalars['network_scope_enum']['input']>>;
};

/** Boolean expression to compare columns of type "node_kind_enum". All fields are combined with logical 'AND'. */
export type Node_Kind_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['node_kind_enum']['input']>;
  _gt?: InputMaybe<Scalars['node_kind_enum']['input']>;
  _gte?: InputMaybe<Scalars['node_kind_enum']['input']>;
  _in?: InputMaybe<Array<Scalars['node_kind_enum']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['node_kind_enum']['input']>;
  _lte?: InputMaybe<Scalars['node_kind_enum']['input']>;
  _neq?: InputMaybe<Scalars['node_kind_enum']['input']>;
  _nin?: InputMaybe<Array<Scalars['node_kind_enum']['input']>>;
};

/** column ordering options */
export enum Order_By {
  /** in ascending order, nulls last */
  Asc = 'asc',
  /** in ascending order, nulls first */
  AscNullsFirst = 'asc_nulls_first',
  /** in ascending order, nulls last */
  AscNullsLast = 'asc_nulls_last',
  /** in descending order, nulls first */
  Desc = 'desc',
  /** in descending order, nulls first */
  DescNullsFirst = 'desc_nulls_first',
  /** in descending order, nulls last */
  DescNullsLast = 'desc_nulls_last'
}

export type Query_Root = {
  __typename?: 'query_root';
  /** fetch data from the table: "components" */
  ApplicationComponent: Array<ApplicationComponent>;
  /** fetch aggregated fields from the table: "components" */
  ApplicationComponentAggregate: ApplicationComponent_Aggregate;
  /** fetch data from the table: "map_application_component_actor_role" */
  ApplicationComponentBusinessActorRoleMap: Array<ApplicationComponentBusinessActorRoleMap>;
  /** fetch aggregated fields from the table: "map_application_component_actor_role" */
  ApplicationComponentBusinessActorRoleMapAggregate: ApplicationComponentBusinessActorRoleMap_Aggregate;
  /** fetch data from the table: "map_application_component_actor_role" using primary key columns */
  ApplicationComponentBusinessActorRoleMapByPk?: Maybe<ApplicationComponentBusinessActorRoleMap>;
  /** fetch data from the table: "components" using primary key columns */
  ApplicationComponentByPk?: Maybe<ApplicationComponent>;
  /** fetch data from the table: "map_application_component_data_object" */
  ApplicationComponentDataObjectMap: Array<ApplicationComponentDataObjectMap>;
  /** fetch aggregated fields from the table: "map_application_component_data_object" */
  ApplicationComponentDataObjectMapAggregate: ApplicationComponentDataObjectMap_Aggregate;
  /** fetch data from the table: "map_application_component_data_object" using primary key columns */
  ApplicationComponentDataObjectMapByPk?: Maybe<ApplicationComponentDataObjectMap>;
  /** fetch data from the table: "map_application_component_directory" */
  ApplicationComponentDirectoryMap: Array<ApplicationComponentDirectoryMap>;
  /** fetch aggregated fields from the table: "map_application_component_directory" */
  ApplicationComponentDirectoryMapAggregate: ApplicationComponentDirectoryMap_Aggregate;
  /** fetch data from the table: "map_application_component_directory" using primary key columns */
  ApplicationComponentDirectoryMapByPk?: Maybe<ApplicationComponentDirectoryMap>;
  /** fetch data from the table: "map_application_component_event" */
  ApplicationComponentEventMap: Array<ApplicationComponentEventMap>;
  /** fetch aggregated fields from the table: "map_application_component_event" */
  ApplicationComponentEventMapAggregate: ApplicationComponentEventMap_Aggregate;
  /** fetch data from the table: "map_application_component_event" using primary key columns */
  ApplicationComponentEventMapByPk?: Maybe<ApplicationComponentEventMap>;
  /** fetch data from the table: "map_application_component_function" */
  ApplicationComponentFunctionMap: Array<ApplicationComponentFunctionMap>;
  /** fetch aggregated fields from the table: "map_application_component_function" */
  ApplicationComponentFunctionMapAggregate: ApplicationComponentFunctionMap_Aggregate;
  /** fetch data from the table: "map_application_component_function" using primary key columns */
  ApplicationComponentFunctionMapByPk?: Maybe<ApplicationComponentFunctionMap>;
  /** fetch data from the table: "map_application_component_hierarchy" */
  ApplicationComponentHierarchyMap: Array<ApplicationComponentHierarchyMap>;
  /** fetch aggregated fields from the table: "map_application_component_hierarchy" */
  ApplicationComponentHierarchyMapAggregate: ApplicationComponentHierarchyMap_Aggregate;
  /** fetch data from the table: "map_application_component_hierarchy" using primary key columns */
  ApplicationComponentHierarchyMapByPk?: Maybe<ApplicationComponentHierarchyMap>;
  /** fetch data from the table: "map_application_component_interface" */
  ApplicationComponentInterfaceMap: Array<ApplicationComponentInterfaceMap>;
  /** fetch aggregated fields from the table: "map_application_component_interface" */
  ApplicationComponentInterfaceMapAggregate: ApplicationComponentInterfaceMap_Aggregate;
  /** fetch data from the table: "map_application_component_interface" using primary key columns */
  ApplicationComponentInterfaceMapByPk?: Maybe<ApplicationComponentInterfaceMap>;
  /** fetch data from the table: "map_application_component_product" */
  ApplicationComponentProductMap: Array<ApplicationComponentProductMap>;
  /** fetch aggregated fields from the table: "map_application_component_product" */
  ApplicationComponentProductMapAggregate: ApplicationComponentProductMap_Aggregate;
  /** fetch data from the table: "map_application_component_product" using primary key columns */
  ApplicationComponentProductMapByPk?: Maybe<ApplicationComponentProductMap>;
  /** fetch data from the table: "map_application_component_stakeholder" */
  ApplicationComponentStakeholderMap: Array<ApplicationComponentStakeholderMap>;
  /** fetch aggregated fields from the table: "map_application_component_stakeholder" */
  ApplicationComponentStakeholderMapAggregate: ApplicationComponentStakeholderMap_Aggregate;
  /** fetch data from the table: "map_application_component_stakeholder" using primary key columns */
  ApplicationComponentStakeholderMapByPk?: Maybe<ApplicationComponentStakeholderMap>;
  /** fetch data from the table: "map_application_component_system_software" */
  ApplicationComponentSystemSoftwareMap: Array<ApplicationComponentSystemSoftwareMap>;
  /** fetch aggregated fields from the table: "map_application_component_system_software" */
  ApplicationComponentSystemSoftwareMapAggregate: ApplicationComponentSystemSoftwareMap_Aggregate;
  /** fetch data from the table: "map_application_component_system_software" using primary key columns */
  ApplicationComponentSystemSoftwareMapByPk?: Maybe<ApplicationComponentSystemSoftwareMap>;
  /** fetch data from the table: "map_application_component_technology_logical_network" */
  ApplicationComponentTechnologyLogicalNetworkMap: Array<ApplicationComponentTechnologyLogicalNetworkMap>;
  /** fetch aggregated fields from the table: "map_application_component_technology_logical_network" */
  ApplicationComponentTechnologyLogicalNetworkMapAggregate: ApplicationComponentTechnologyLogicalNetworkMap_Aggregate;
  /** fetch data from the table: "map_application_component_technology_logical_network" using primary key columns */
  ApplicationComponentTechnologyLogicalNetworkMapByPk?: Maybe<ApplicationComponentTechnologyLogicalNetworkMap>;
  /** fetch data from the table: "map_application_component_technology_node" */
  ApplicationComponentTechnologyNodeMap: Array<ApplicationComponentTechnologyNodeMap>;
  /** fetch aggregated fields from the table: "map_application_component_technology_node" */
  ApplicationComponentTechnologyNodeMapAggregate: ApplicationComponentTechnologyNodeMap_Aggregate;
  /** fetch data from the table: "map_application_component_technology_node" using primary key columns */
  ApplicationComponentTechnologyNodeMapByPk?: Maybe<ApplicationComponentTechnologyNodeMap>;
  /** fetch data from the table: "map_application_function_data_object" */
  ApplicationFunctionDataObjectMap: Array<ApplicationFunctionDataObjectMap>;
  /** fetch aggregated fields from the table: "map_application_function_data_object" */
  ApplicationFunctionDataObjectMapAggregate: ApplicationFunctionDataObjectMap_Aggregate;
  /** fetch data from the table: "map_application_function_data_object" using primary key columns */
  ApplicationFunctionDataObjectMapByPk?: Maybe<ApplicationFunctionDataObjectMap>;
  /** fetch data from the table: "map_application_interface_function" */
  ApplicationFunctionInterfaceMap: Array<ApplicationFunctionInterfaceMap>;
  /** fetch aggregated fields from the table: "map_application_interface_function" */
  ApplicationFunctionInterfaceMapAggregate: ApplicationFunctionInterfaceMap_Aggregate;
  /** fetch data from the table: "map_application_interface_function" using primary key columns */
  ApplicationFunctionInterfaceMapByPk?: Maybe<ApplicationFunctionInterfaceMap>;
  /** fetch data from the table: "actors" */
  BusinessActor: Array<BusinessActor>;
  /** fetch aggregated fields from the table: "actors" */
  BusinessActorAggregate: BusinessActor_Aggregate;
  /** fetch data from the table: "actors" using primary key columns */
  BusinessActorByPk?: Maybe<BusinessActor>;
  /** fetch data from the table: "map_business_actor_role" */
  BusinessActorRoleMap: Array<BusinessActorRoleMap>;
  /** fetch aggregated fields from the table: "map_business_actor_role" */
  BusinessActorRoleMapAggregate: BusinessActorRoleMap_Aggregate;
  /** fetch data from the table: "map_business_actor_role" using primary key columns */
  BusinessActorRoleMapByPk?: Maybe<BusinessActorRoleMap>;
  /** fetch data from the table: "map_business_process_function" */
  BusinessProcessFunctionMap: Array<BusinessProcessFunctionMap>;
  /** fetch aggregated fields from the table: "map_business_process_function" */
  BusinessProcessFunctionMapAggregate: BusinessProcessFunctionMap_Aggregate;
  /** fetch data from the table: "map_business_process_function" using primary key columns */
  BusinessProcessFunctionMapByPk?: Maybe<BusinessProcessFunctionMap>;
  /** fetch data from the table: "map_business_process_hierarchy" */
  BusinessProcessHierarchyMap: Array<BusinessProcessHierarchyMap>;
  /** fetch aggregated fields from the table: "map_business_process_hierarchy" */
  BusinessProcessHierarchyMapAggregate: BusinessProcessHierarchyMap_Aggregate;
  /** fetch data from the table: "map_business_process_hierarchy" using primary key columns */
  BusinessProcessHierarchyMapByPk?: Maybe<BusinessProcessHierarchyMap>;
  /** fetch data from the table: "map_business_process_motivation_item" */
  BusinessProcessMotivationItemMap: Array<BusinessProcessMotivationItemMap>;
  /** fetch aggregated fields from the table: "map_business_process_motivation_item" */
  BusinessProcessMotivationItemMapAggregate: BusinessProcessMotivationItemMap_Aggregate;
  /** fetch data from the table: "map_business_process_motivation_item" using primary key columns */
  BusinessProcessMotivationItemMapByPk?: Maybe<BusinessProcessMotivationItemMap>;
  /** fetch data from the table: "products" */
  BusinessProduct: Array<BusinessProduct>;
  /** fetch aggregated fields from the table: "products" */
  BusinessProductAggregate: BusinessProduct_Aggregate;
  /** fetch data from the table: "products" using primary key columns */
  BusinessProductByPk?: Maybe<BusinessProduct>;
  /** fetch data from the table: "roles" */
  BusinessRole: Array<BusinessRole>;
  /** fetch aggregated fields from the table: "roles" */
  BusinessRoleAggregate: BusinessRole_Aggregate;
  /** fetch data from the table: "roles" using primary key columns */
  BusinessRoleByPk?: Maybe<BusinessRole>;
  /** fetch data from the table: "capabilities" */
  Capability: Array<Capability>;
  /** fetch aggregated fields from the table: "capabilities" */
  CapabilityAggregate: Capability_Aggregate;
  /** fetch data from the table: "map_capability_application_component_assessment" */
  CapabilityApplicationComponentAssessmentMap: Array<CapabilityApplicationComponentAssessmentMap>;
  /** fetch aggregated fields from the table: "map_capability_application_component_assessment" */
  CapabilityApplicationComponentAssessmentMapAggregate: CapabilityApplicationComponentAssessmentMap_Aggregate;
  /** fetch data from the table: "map_capability_application_component_assessment" using primary key columns */
  CapabilityApplicationComponentAssessmentMapByPk?: Maybe<CapabilityApplicationComponentAssessmentMap>;
  /** fetch data from the table: "map_capability_application_component" */
  CapabilityApplicationComponentMap: Array<CapabilityApplicationComponentMap>;
  /** fetch aggregated fields from the table: "map_capability_application_component" */
  CapabilityApplicationComponentMapAggregate: CapabilityApplicationComponentMap_Aggregate;
  /** fetch data from the table: "map_capability_application_component" using primary key columns */
  CapabilityApplicationComponentMapByPk?: Maybe<CapabilityApplicationComponentMap>;
  /** fetch data from the table: "map_capability_business_process_assessment" */
  CapabilityBusinessProcessAssessmentMap: Array<CapabilityBusinessProcessAssessmentMap>;
  /** fetch aggregated fields from the table: "map_capability_business_process_assessment" */
  CapabilityBusinessProcessAssessmentMapAggregate: CapabilityBusinessProcessAssessmentMap_Aggregate;
  /** fetch data from the table: "map_capability_business_process_assessment" using primary key columns */
  CapabilityBusinessProcessAssessmentMapByPk?: Maybe<CapabilityBusinessProcessAssessmentMap>;
  /** fetch data from the table: "map_capability_business_process" */
  CapabilityBusinessProcessMap: Array<CapabilityBusinessProcessMap>;
  /** fetch aggregated fields from the table: "map_capability_business_process" */
  CapabilityBusinessProcessMapAggregate: CapabilityBusinessProcessMap_Aggregate;
  /** fetch data from the table: "map_capability_business_process" using primary key columns */
  CapabilityBusinessProcessMapByPk?: Maybe<CapabilityBusinessProcessMap>;
  /** fetch data from the table: "capabilities" using primary key columns */
  CapabilityByPk?: Maybe<Capability>;
  /** fetch data from the table: "map_capability_hierarchy" */
  CapabilityHierarchyMap: Array<CapabilityHierarchyMap>;
  /** fetch aggregated fields from the table: "map_capability_hierarchy" */
  CapabilityHierarchyMapAggregate: CapabilityHierarchyMap_Aggregate;
  /** fetch data from the table: "map_capability_hierarchy" using primary key columns */
  CapabilityHierarchyMapByPk?: Maybe<CapabilityHierarchyMap>;
  /** fetch data from the table: "data_objects" */
  DataObject: Array<DataObject>;
  /** fetch aggregated fields from the table: "data_objects" */
  DataObjectAggregate: DataObject_Aggregate;
  /** fetch data from the table: "data_objects" using primary key columns */
  DataObjectByPk?: Maybe<DataObject>;
  /** fetch data from the table: "map_directory_items" */
  DirectoryItemsMap: Array<DirectoryItemsMap>;
  /** fetch aggregated fields from the table: "map_directory_items" */
  DirectoryItemsMapAggregate: DirectoryItemsMap_Aggregate;
  /** fetch data from the table: "map_directory_items" using primary key columns */
  DirectoryItemsMapByPk?: Maybe<DirectoryItemsMap>;
  /** fetch data from the table: "directories" */
  DirectoryObject: Array<DirectoryObject>;
  /** fetch aggregated fields from the table: "directories" */
  DirectoryObjectAggregate: DirectoryObject_Aggregate;
  /** fetch data from the table: "directories" using primary key columns */
  DirectoryObjectByPk?: Maybe<DirectoryObject>;
  /** fetch data from the table: "employees" */
  Employee: Array<Employee>;
  /** fetch aggregated fields from the table: "employees" */
  EmployeeAggregate: Employee_Aggregate;
  /** fetch data from the table: "employees" using primary key columns */
  EmployeeByPk?: Maybe<Employee>;
  /** fetch data from the table: "events" */
  EventGeneric: Array<EventGeneric>;
  /** fetch aggregated fields from the table: "events" */
  EventGenericAggregate: EventGeneric_Aggregate;
  /** fetch data from the table: "events" using primary key columns */
  EventGenericByPk?: Maybe<EventGeneric>;
  /** fetch data from the table: "flows" */
  FlowGeneric: Array<FlowGeneric>;
  /** fetch aggregated fields from the table: "flows" */
  FlowGenericAggregate: FlowGeneric_Aggregate;
  /** fetch data from the table: "flows" using primary key columns */
  FlowGenericByPk?: Maybe<FlowGeneric>;
  /** fetch data from the table: "functions" */
  FunctionGeneric: Array<FunctionGeneric>;
  /** fetch aggregated fields from the table: "functions" */
  FunctionGenericAggregate: FunctionGeneric_Aggregate;
  /** fetch data from the table: "functions" using primary key columns */
  FunctionGenericByPk?: Maybe<FunctionGeneric>;
  /** fetch data from the table: "interfaces" */
  InterfaceGeneric: Array<InterfaceGeneric>;
  /** fetch aggregated fields from the table: "interfaces" */
  InterfaceGenericAggregate: InterfaceGeneric_Aggregate;
  /** fetch data from the table: "interfaces" using primary key columns */
  InterfaceGenericByPk?: Maybe<InterfaceGeneric>;
  /** fetch data from the table: "motivations" */
  MotivationElementGeneric: Array<MotivationElementGeneric>;
  /** fetch aggregated fields from the table: "motivations" */
  MotivationElementGenericAggregate: MotivationElementGeneric_Aggregate;
  /** fetch data from the table: "motivations" using primary key columns */
  MotivationElementGenericByPk?: Maybe<MotivationElementGeneric>;
  /** fetch data from the table: "map_motivation_item_hierarchy" */
  MotivationItemHierarchyMap: Array<MotivationItemHierarchyMap>;
  /** fetch aggregated fields from the table: "map_motivation_item_hierarchy" */
  MotivationItemHierarchyMapAggregate: MotivationItemHierarchyMap_Aggregate;
  /** fetch data from the table: "map_motivation_item_hierarchy" using primary key columns */
  MotivationItemHierarchyMapByPk?: Maybe<MotivationItemHierarchyMap>;
  /** fetch data from the table: "locations" */
  PhysicalLocation: Array<PhysicalLocation>;
  /** fetch aggregated fields from the table: "locations" */
  PhysicalLocationAggregate: PhysicalLocation_Aggregate;
  /** fetch data from the table: "locations" using primary key columns */
  PhysicalLocationByPk?: Maybe<PhysicalLocation>;
  /** fetch data from the table: "plateaus" */
  Plateau: Array<Plateau>;
  /** fetch aggregated fields from the table: "plateaus" */
  PlateauAggregate: Plateau_Aggregate;
  /** fetch data from the table: "plateaus" using primary key columns */
  PlateauByPk?: Maybe<Plateau>;
  /** fetch data from the table: "processes" */
  ProcessGeneric: Array<ProcessGeneric>;
  /** fetch aggregated fields from the table: "processes" */
  ProcessGenericAggregate: ProcessGeneric_Aggregate;
  /** fetch data from the table: "processes" using primary key columns */
  ProcessGenericByPk?: Maybe<ProcessGeneric>;
  /** fetch data from the table: "services" */
  ServiceGeneric: Array<ServiceGeneric>;
  /** fetch aggregated fields from the table: "services" */
  ServiceGenericAggregate: ServiceGeneric_Aggregate;
  /** fetch data from the table: "services" using primary key columns */
  ServiceGenericByPk?: Maybe<ServiceGeneric>;
  /** fetch data from the table: "solutions" */
  Solution: Array<Solution>;
  /** fetch aggregated fields from the table: "solutions" */
  SolutionAggregate: Solution_Aggregate;
  /** fetch data from the table: "map_solution_application_component" */
  SolutionApplicationComponentMap: Array<SolutionApplicationComponentMap>;
  /** fetch aggregated fields from the table: "map_solution_application_component" */
  SolutionApplicationComponentMapAggregate: SolutionApplicationComponentMap_Aggregate;
  /** fetch data from the table: "map_solution_application_component" using primary key columns */
  SolutionApplicationComponentMapByPk?: Maybe<SolutionApplicationComponentMap>;
  /** fetch data from the table: "map_solution_application_function" */
  SolutionApplicationFunctionMap: Array<SolutionApplicationFunctionMap>;
  /** fetch aggregated fields from the table: "map_solution_application_function" */
  SolutionApplicationFunctionMapAggregate: SolutionApplicationFunctionMap_Aggregate;
  /** fetch data from the table: "map_solution_application_function" using primary key columns */
  SolutionApplicationFunctionMapByPk?: Maybe<SolutionApplicationFunctionMap>;
  /** fetch data from the table: "solutions" using primary key columns */
  SolutionByPk?: Maybe<Solution>;
  /** fetch data from the table: "map_solution_data_object" */
  SolutionDataObjectMap: Array<SolutionDataObjectMap>;
  /** fetch aggregated fields from the table: "map_solution_data_object" */
  SolutionDataObjectMapAggregate: SolutionDataObjectMap_Aggregate;
  /** fetch data from the table: "map_solution_data_object" using primary key columns */
  SolutionDataObjectMapByPk?: Maybe<SolutionDataObjectMap>;
  /** fetch data from the table: "map_solution_flow" */
  SolutionFlowMap: Array<SolutionFlowMap>;
  /** fetch aggregated fields from the table: "map_solution_flow" */
  SolutionFlowMapAggregate: SolutionFlowMap_Aggregate;
  /** fetch data from the table: "map_solution_flow" using primary key columns */
  SolutionFlowMapByPk?: Maybe<SolutionFlowMap>;
  /** fetch data from the table: "map_solution_motivation_component" */
  SolutionMotivationComponentMap: Array<SolutionMotivationComponentMap>;
  /** fetch aggregated fields from the table: "map_solution_motivation_component" */
  SolutionMotivationComponentMapAggregate: SolutionMotivationComponentMap_Aggregate;
  /** fetch data from the table: "map_solution_motivation_component" using primary key columns */
  SolutionMotivationComponentMapByPk?: Maybe<SolutionMotivationComponentMap>;
  /** fetch data from the table: "map_solution_motivation" */
  SolutionMotivationElementMap: Array<SolutionMotivationElementMap>;
  /** fetch aggregated fields from the table: "map_solution_motivation" */
  SolutionMotivationElementMapAggregate: SolutionMotivationElementMap_Aggregate;
  /** fetch data from the table: "map_solution_motivation" using primary key columns */
  SolutionMotivationElementMapByPk?: Maybe<SolutionMotivationElementMap>;
  /** fetch data from the table: "map_solution_stakeholder" */
  SolutionStakeholderMap: Array<SolutionStakeholderMap>;
  /** fetch aggregated fields from the table: "map_solution_stakeholder" */
  SolutionStakeholderMapAggregate: SolutionStakeholderMap_Aggregate;
  /** fetch data from the table: "map_solution_stakeholder" using primary key columns */
  SolutionStakeholderMapByPk?: Maybe<SolutionStakeholderMap>;
  /** fetch data from the table: "map_solution_technology_node" */
  SolutionTechnologyNodeMap: Array<SolutionTechnologyNodeMap>;
  /** fetch aggregated fields from the table: "map_solution_technology_node" */
  SolutionTechnologyNodeMapAggregate: SolutionTechnologyNodeMap_Aggregate;
  /** fetch data from the table: "map_solution_technology_node" using primary key columns */
  SolutionTechnologyNodeMapByPk?: Maybe<SolutionTechnologyNodeMap>;
  /** fetch data from the table: "stakeholders" */
  Stakeholder: Array<Stakeholder>;
  /** fetch aggregated fields from the table: "stakeholders" */
  StakeholderAggregate: Stakeholder_Aggregate;
  /** fetch data from the table: "stakeholders" using primary key columns */
  StakeholderByPk?: Maybe<Stakeholder>;
  /** fetch data from the table: "system_software" */
  SystemSoftware: Array<SystemSoftware>;
  /** fetch aggregated fields from the table: "system_software" */
  SystemSoftwareAggregate: SystemSoftware_Aggregate;
  /** fetch data from the table: "system_software" using primary key columns */
  SystemSoftwareByPk?: Maybe<SystemSoftware>;
  /** fetch data from the table: "technology_networks" */
  TechnologyNetwork: Array<TechnologyNetwork>;
  /** fetch aggregated fields from the table: "technology_networks" */
  TechnologyNetworkAggregate: TechnologyNetwork_Aggregate;
  /** fetch data from the table: "technology_networks" using primary key columns */
  TechnologyNetworkByPk?: Maybe<TechnologyNetwork>;
  /** fetch data from the table: "map_technology_network_hierarchy" */
  TechnologyNetworkHierarchyMap: Array<TechnologyNetworkHierarchyMap>;
  /** fetch aggregated fields from the table: "map_technology_network_hierarchy" */
  TechnologyNetworkHierarchyMapAggregate: TechnologyNetworkHierarchyMap_Aggregate;
  /** fetch data from the table: "map_technology_network_hierarchy" using primary key columns */
  TechnologyNetworkHierarchyMapByPk?: Maybe<TechnologyNetworkHierarchyMap>;
  /** fetch data from the table: "technology_nodes" */
  TechnologyNode: Array<TechnologyNode>;
  /** fetch aggregated fields from the table: "technology_nodes" */
  TechnologyNodeAggregate: TechnologyNode_Aggregate;
  /** fetch data from the table: "technology_nodes" using primary key columns */
  TechnologyNodeByPk?: Maybe<TechnologyNode>;
  /** fetch data from the table: "map_technology_node_hierarchy" */
  TechnologyNodeHierarchyMap: Array<TechnologyNodeHierarchyMap>;
  /** fetch aggregated fields from the table: "map_technology_node_hierarchy" */
  TechnologyNodeHierarchyMapAggregate: TechnologyNodeHierarchyMap_Aggregate;
  /** fetch data from the table: "map_technology_node_hierarchy" using primary key columns */
  TechnologyNodeHierarchyMapByPk?: Maybe<TechnologyNodeHierarchyMap>;
  /** fetch data from the table: "map_technology_node_system_software" */
  TechnologyNodeSystemSoftwareMap: Array<TechnologyNodeSystemSoftwareMap>;
  /** fetch aggregated fields from the table: "map_technology_node_system_software" */
  TechnologyNodeSystemSoftwareMapAggregate: TechnologyNodeSystemSoftwareMap_Aggregate;
  /** fetch data from the table: "map_technology_node_system_software" using primary key columns */
  TechnologyNodeSystemSoftwareMapByPk?: Maybe<TechnologyNodeSystemSoftwareMap>;
  /** fetch data from the table: "map_solution_constraint" */
  mapSolutionConstraint: Array<MapSolutionConstraint>;
  /** fetch aggregated fields from the table: "map_solution_constraint" */
  mapSolutionConstraint_aggregate: MapSolutionConstraint_Aggregate;
  /** fetch data from the table: "map_solution_constraint" using primary key columns */
  mapSolutionConstraint_by_pk?: Maybe<MapSolutionConstraint>;
  /** fetch data from the table: "map_tenant_user_profiles" */
  mapTenantUserProfiles: Array<MapTenantUserProfiles>;
  /** fetch aggregated fields from the table: "map_tenant_user_profiles" */
  mapTenantUserProfiles_aggregate: MapTenantUserProfiles_Aggregate;
  /** fetch data from the table: "map_tenant_user_profiles" using primary key columns */
  mapTenantUserProfiles_by_pk?: Maybe<MapTenantUserProfiles>;
  /** fetch data from the table: "tenants" */
  tenants: Array<Tenants>;
  /** fetch aggregated fields from the table: "tenants" */
  tenants_aggregate: Tenants_Aggregate;
  /** fetch data from the table: "tenants" using primary key columns */
  tenants_by_pk?: Maybe<Tenants>;
  /** fetch data from the table: "user_profiles" */
  userProfiles: Array<UserProfiles>;
  /** fetch aggregated fields from the table: "user_profiles" */
  userProfiles_aggregate: UserProfiles_Aggregate;
  /** fetch data from the table: "user_profiles" using primary key columns */
  userProfiles_by_pk?: Maybe<UserProfiles>;
};


export type Query_RootApplicationComponentArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponent_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponent_Order_By>>;
  where?: InputMaybe<ApplicationComponent_Bool_Exp>;
};


export type Query_RootApplicationComponentAggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponent_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponent_Order_By>>;
  where?: InputMaybe<ApplicationComponent_Bool_Exp>;
};


export type Query_RootApplicationComponentBusinessActorRoleMapArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentBusinessActorRoleMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentBusinessActorRoleMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentBusinessActorRoleMap_Bool_Exp>;
};


export type Query_RootApplicationComponentBusinessActorRoleMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentBusinessActorRoleMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentBusinessActorRoleMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentBusinessActorRoleMap_Bool_Exp>;
};


export type Query_RootApplicationComponentBusinessActorRoleMapByPkArgs = {
  actorId: Scalars['uuid']['input'];
  componentId: Scalars['uuid']['input'];
  roleId: Scalars['uuid']['input'];
};


export type Query_RootApplicationComponentByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootApplicationComponentDataObjectMapArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentDataObjectMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentDataObjectMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentDataObjectMap_Bool_Exp>;
};


export type Query_RootApplicationComponentDataObjectMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentDataObjectMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentDataObjectMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentDataObjectMap_Bool_Exp>;
};


export type Query_RootApplicationComponentDataObjectMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  dataObjectId: Scalars['uuid']['input'];
};


export type Query_RootApplicationComponentDirectoryMapArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentDirectoryMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentDirectoryMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentDirectoryMap_Bool_Exp>;
};


export type Query_RootApplicationComponentDirectoryMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentDirectoryMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentDirectoryMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentDirectoryMap_Bool_Exp>;
};


export type Query_RootApplicationComponentDirectoryMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  directoryId: Scalars['uuid']['input'];
};


export type Query_RootApplicationComponentEventMapArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentEventMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentEventMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentEventMap_Bool_Exp>;
};


export type Query_RootApplicationComponentEventMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentEventMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentEventMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentEventMap_Bool_Exp>;
};


export type Query_RootApplicationComponentEventMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  eventId: Scalars['uuid']['input'];
};


export type Query_RootApplicationComponentFunctionMapArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentFunctionMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentFunctionMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentFunctionMap_Bool_Exp>;
};


export type Query_RootApplicationComponentFunctionMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentFunctionMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentFunctionMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentFunctionMap_Bool_Exp>;
};


export type Query_RootApplicationComponentFunctionMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  functionId: Scalars['uuid']['input'];
};


export type Query_RootApplicationComponentHierarchyMapArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentHierarchyMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentHierarchyMap_Bool_Exp>;
};


export type Query_RootApplicationComponentHierarchyMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentHierarchyMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentHierarchyMap_Bool_Exp>;
};


export type Query_RootApplicationComponentHierarchyMapByPkArgs = {
  componentChildId: Scalars['uuid']['input'];
  componentParentId: Scalars['uuid']['input'];
};


export type Query_RootApplicationComponentInterfaceMapArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentInterfaceMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentInterfaceMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentInterfaceMap_Bool_Exp>;
};


export type Query_RootApplicationComponentInterfaceMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentInterfaceMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentInterfaceMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentInterfaceMap_Bool_Exp>;
};


export type Query_RootApplicationComponentInterfaceMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  interfaceId: Scalars['uuid']['input'];
};


export type Query_RootApplicationComponentProductMapArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentProductMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentProductMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentProductMap_Bool_Exp>;
};


export type Query_RootApplicationComponentProductMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentProductMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentProductMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentProductMap_Bool_Exp>;
};


export type Query_RootApplicationComponentProductMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  productId: Scalars['uuid']['input'];
};


export type Query_RootApplicationComponentStakeholderMapArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentStakeholderMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentStakeholderMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentStakeholderMap_Bool_Exp>;
};


export type Query_RootApplicationComponentStakeholderMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentStakeholderMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentStakeholderMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentStakeholderMap_Bool_Exp>;
};


export type Query_RootApplicationComponentStakeholderMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  stakeholderId: Scalars['uuid']['input'];
};


export type Query_RootApplicationComponentSystemSoftwareMapArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentSystemSoftwareMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentSystemSoftwareMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentSystemSoftwareMap_Bool_Exp>;
};


export type Query_RootApplicationComponentSystemSoftwareMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentSystemSoftwareMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentSystemSoftwareMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentSystemSoftwareMap_Bool_Exp>;
};


export type Query_RootApplicationComponentSystemSoftwareMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  systemSoftwareId: Scalars['uuid']['input'];
};


export type Query_RootApplicationComponentTechnologyLogicalNetworkMapArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentTechnologyLogicalNetworkMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentTechnologyLogicalNetworkMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentTechnologyLogicalNetworkMap_Bool_Exp>;
};


export type Query_RootApplicationComponentTechnologyLogicalNetworkMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentTechnologyLogicalNetworkMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentTechnologyLogicalNetworkMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentTechnologyLogicalNetworkMap_Bool_Exp>;
};


export type Query_RootApplicationComponentTechnologyLogicalNetworkMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  logicalNetworkId: Scalars['uuid']['input'];
};


export type Query_RootApplicationComponentTechnologyNodeMapArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentTechnologyNodeMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentTechnologyNodeMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentTechnologyNodeMap_Bool_Exp>;
};


export type Query_RootApplicationComponentTechnologyNodeMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentTechnologyNodeMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentTechnologyNodeMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentTechnologyNodeMap_Bool_Exp>;
};


export type Query_RootApplicationComponentTechnologyNodeMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  nodeId: Scalars['uuid']['input'];
};


export type Query_RootApplicationFunctionDataObjectMapArgs = {
  distinct_on?: InputMaybe<Array<ApplicationFunctionDataObjectMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationFunctionDataObjectMap_Order_By>>;
  where?: InputMaybe<ApplicationFunctionDataObjectMap_Bool_Exp>;
};


export type Query_RootApplicationFunctionDataObjectMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationFunctionDataObjectMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationFunctionDataObjectMap_Order_By>>;
  where?: InputMaybe<ApplicationFunctionDataObjectMap_Bool_Exp>;
};


export type Query_RootApplicationFunctionDataObjectMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  dataObjectId: Scalars['uuid']['input'];
  functionId: Scalars['uuid']['input'];
};


export type Query_RootApplicationFunctionInterfaceMapArgs = {
  distinct_on?: InputMaybe<Array<ApplicationFunctionInterfaceMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationFunctionInterfaceMap_Order_By>>;
  where?: InputMaybe<ApplicationFunctionInterfaceMap_Bool_Exp>;
};


export type Query_RootApplicationFunctionInterfaceMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationFunctionInterfaceMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationFunctionInterfaceMap_Order_By>>;
  where?: InputMaybe<ApplicationFunctionInterfaceMap_Bool_Exp>;
};


export type Query_RootApplicationFunctionInterfaceMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  functionId: Scalars['uuid']['input'];
  interfaceId: Scalars['uuid']['input'];
};


export type Query_RootBusinessActorArgs = {
  distinct_on?: InputMaybe<Array<BusinessActor_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessActor_Order_By>>;
  where?: InputMaybe<BusinessActor_Bool_Exp>;
};


export type Query_RootBusinessActorAggregateArgs = {
  distinct_on?: InputMaybe<Array<BusinessActor_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessActor_Order_By>>;
  where?: InputMaybe<BusinessActor_Bool_Exp>;
};


export type Query_RootBusinessActorByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootBusinessActorRoleMapArgs = {
  distinct_on?: InputMaybe<Array<BusinessActorRoleMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessActorRoleMap_Order_By>>;
  where?: InputMaybe<BusinessActorRoleMap_Bool_Exp>;
};


export type Query_RootBusinessActorRoleMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<BusinessActorRoleMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessActorRoleMap_Order_By>>;
  where?: InputMaybe<BusinessActorRoleMap_Bool_Exp>;
};


export type Query_RootBusinessActorRoleMapByPkArgs = {
  actorId: Scalars['uuid']['input'];
  roleId: Scalars['uuid']['input'];
};


export type Query_RootBusinessProcessFunctionMapArgs = {
  distinct_on?: InputMaybe<Array<BusinessProcessFunctionMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessProcessFunctionMap_Order_By>>;
  where?: InputMaybe<BusinessProcessFunctionMap_Bool_Exp>;
};


export type Query_RootBusinessProcessFunctionMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<BusinessProcessFunctionMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessProcessFunctionMap_Order_By>>;
  where?: InputMaybe<BusinessProcessFunctionMap_Bool_Exp>;
};


export type Query_RootBusinessProcessFunctionMapByPkArgs = {
  functionId: Scalars['uuid']['input'];
  processId: Scalars['uuid']['input'];
};


export type Query_RootBusinessProcessHierarchyMapArgs = {
  distinct_on?: InputMaybe<Array<BusinessProcessHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessProcessHierarchyMap_Order_By>>;
  where?: InputMaybe<BusinessProcessHierarchyMap_Bool_Exp>;
};


export type Query_RootBusinessProcessHierarchyMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<BusinessProcessHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessProcessHierarchyMap_Order_By>>;
  where?: InputMaybe<BusinessProcessHierarchyMap_Bool_Exp>;
};


export type Query_RootBusinessProcessHierarchyMapByPkArgs = {
  processChildId: Scalars['uuid']['input'];
  processParentId: Scalars['uuid']['input'];
};


export type Query_RootBusinessProcessMotivationItemMapArgs = {
  distinct_on?: InputMaybe<Array<BusinessProcessMotivationItemMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessProcessMotivationItemMap_Order_By>>;
  where?: InputMaybe<BusinessProcessMotivationItemMap_Bool_Exp>;
};


export type Query_RootBusinessProcessMotivationItemMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<BusinessProcessMotivationItemMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessProcessMotivationItemMap_Order_By>>;
  where?: InputMaybe<BusinessProcessMotivationItemMap_Bool_Exp>;
};


export type Query_RootBusinessProcessMotivationItemMapByPkArgs = {
  motivationId: Scalars['uuid']['input'];
  processId: Scalars['uuid']['input'];
};


export type Query_RootBusinessProductArgs = {
  distinct_on?: InputMaybe<Array<BusinessProduct_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessProduct_Order_By>>;
  where?: InputMaybe<BusinessProduct_Bool_Exp>;
};


export type Query_RootBusinessProductAggregateArgs = {
  distinct_on?: InputMaybe<Array<BusinessProduct_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessProduct_Order_By>>;
  where?: InputMaybe<BusinessProduct_Bool_Exp>;
};


export type Query_RootBusinessProductByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootBusinessRoleArgs = {
  distinct_on?: InputMaybe<Array<BusinessRole_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessRole_Order_By>>;
  where?: InputMaybe<BusinessRole_Bool_Exp>;
};


export type Query_RootBusinessRoleAggregateArgs = {
  distinct_on?: InputMaybe<Array<BusinessRole_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessRole_Order_By>>;
  where?: InputMaybe<BusinessRole_Bool_Exp>;
};


export type Query_RootBusinessRoleByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootCapabilityArgs = {
  distinct_on?: InputMaybe<Array<Capability_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Capability_Order_By>>;
  where?: InputMaybe<Capability_Bool_Exp>;
};


export type Query_RootCapabilityAggregateArgs = {
  distinct_on?: InputMaybe<Array<Capability_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Capability_Order_By>>;
  where?: InputMaybe<Capability_Bool_Exp>;
};


export type Query_RootCapabilityApplicationComponentAssessmentMapArgs = {
  distinct_on?: InputMaybe<Array<CapabilityApplicationComponentAssessmentMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CapabilityApplicationComponentAssessmentMap_Order_By>>;
  where?: InputMaybe<CapabilityApplicationComponentAssessmentMap_Bool_Exp>;
};


export type Query_RootCapabilityApplicationComponentAssessmentMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<CapabilityApplicationComponentAssessmentMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CapabilityApplicationComponentAssessmentMap_Order_By>>;
  where?: InputMaybe<CapabilityApplicationComponentAssessmentMap_Bool_Exp>;
};


export type Query_RootCapabilityApplicationComponentAssessmentMapByPkArgs = {
  assessmentId: Scalars['uuid']['input'];
  capabilityId: Scalars['uuid']['input'];
  componentId: Scalars['uuid']['input'];
};


export type Query_RootCapabilityApplicationComponentMapArgs = {
  distinct_on?: InputMaybe<Array<CapabilityApplicationComponentMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CapabilityApplicationComponentMap_Order_By>>;
  where?: InputMaybe<CapabilityApplicationComponentMap_Bool_Exp>;
};


export type Query_RootCapabilityApplicationComponentMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<CapabilityApplicationComponentMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CapabilityApplicationComponentMap_Order_By>>;
  where?: InputMaybe<CapabilityApplicationComponentMap_Bool_Exp>;
};


export type Query_RootCapabilityApplicationComponentMapByPkArgs = {
  capabilityId: Scalars['uuid']['input'];
  componentId: Scalars['uuid']['input'];
};


export type Query_RootCapabilityBusinessProcessAssessmentMapArgs = {
  distinct_on?: InputMaybe<Array<CapabilityBusinessProcessAssessmentMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CapabilityBusinessProcessAssessmentMap_Order_By>>;
  where?: InputMaybe<CapabilityBusinessProcessAssessmentMap_Bool_Exp>;
};


export type Query_RootCapabilityBusinessProcessAssessmentMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<CapabilityBusinessProcessAssessmentMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CapabilityBusinessProcessAssessmentMap_Order_By>>;
  where?: InputMaybe<CapabilityBusinessProcessAssessmentMap_Bool_Exp>;
};


export type Query_RootCapabilityBusinessProcessAssessmentMapByPkArgs = {
  assessmentId: Scalars['uuid']['input'];
  capabilityId: Scalars['uuid']['input'];
  processId: Scalars['uuid']['input'];
};


export type Query_RootCapabilityBusinessProcessMapArgs = {
  distinct_on?: InputMaybe<Array<CapabilityBusinessProcessMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CapabilityBusinessProcessMap_Order_By>>;
  where?: InputMaybe<CapabilityBusinessProcessMap_Bool_Exp>;
};


export type Query_RootCapabilityBusinessProcessMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<CapabilityBusinessProcessMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CapabilityBusinessProcessMap_Order_By>>;
  where?: InputMaybe<CapabilityBusinessProcessMap_Bool_Exp>;
};


export type Query_RootCapabilityBusinessProcessMapByPkArgs = {
  capabilityId: Scalars['uuid']['input'];
  processId: Scalars['uuid']['input'];
};


export type Query_RootCapabilityByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootCapabilityHierarchyMapArgs = {
  distinct_on?: InputMaybe<Array<CapabilityHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CapabilityHierarchyMap_Order_By>>;
  where?: InputMaybe<CapabilityHierarchyMap_Bool_Exp>;
};


export type Query_RootCapabilityHierarchyMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<CapabilityHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CapabilityHierarchyMap_Order_By>>;
  where?: InputMaybe<CapabilityHierarchyMap_Bool_Exp>;
};


export type Query_RootCapabilityHierarchyMapByPkArgs = {
  childId: Scalars['uuid']['input'];
  parentId: Scalars['uuid']['input'];
};


export type Query_RootDataObjectArgs = {
  distinct_on?: InputMaybe<Array<DataObject_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<DataObject_Order_By>>;
  where?: InputMaybe<DataObject_Bool_Exp>;
};


export type Query_RootDataObjectAggregateArgs = {
  distinct_on?: InputMaybe<Array<DataObject_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<DataObject_Order_By>>;
  where?: InputMaybe<DataObject_Bool_Exp>;
};


export type Query_RootDataObjectByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootDirectoryItemsMapArgs = {
  distinct_on?: InputMaybe<Array<DirectoryItemsMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<DirectoryItemsMap_Order_By>>;
  where?: InputMaybe<DirectoryItemsMap_Bool_Exp>;
};


export type Query_RootDirectoryItemsMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<DirectoryItemsMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<DirectoryItemsMap_Order_By>>;
  where?: InputMaybe<DirectoryItemsMap_Bool_Exp>;
};


export type Query_RootDirectoryItemsMapByPkArgs = {
  sourceId: Scalars['uuid']['input'];
  targetId: Scalars['uuid']['input'];
};


export type Query_RootDirectoryObjectArgs = {
  distinct_on?: InputMaybe<Array<DirectoryObject_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<DirectoryObject_Order_By>>;
  where?: InputMaybe<DirectoryObject_Bool_Exp>;
};


export type Query_RootDirectoryObjectAggregateArgs = {
  distinct_on?: InputMaybe<Array<DirectoryObject_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<DirectoryObject_Order_By>>;
  where?: InputMaybe<DirectoryObject_Bool_Exp>;
};


export type Query_RootDirectoryObjectByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootEmployeeArgs = {
  distinct_on?: InputMaybe<Array<Employee_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Employee_Order_By>>;
  where?: InputMaybe<Employee_Bool_Exp>;
};


export type Query_RootEmployeeAggregateArgs = {
  distinct_on?: InputMaybe<Array<Employee_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Employee_Order_By>>;
  where?: InputMaybe<Employee_Bool_Exp>;
};


export type Query_RootEmployeeByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootEventGenericArgs = {
  distinct_on?: InputMaybe<Array<EventGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<EventGeneric_Order_By>>;
  where?: InputMaybe<EventGeneric_Bool_Exp>;
};


export type Query_RootEventGenericAggregateArgs = {
  distinct_on?: InputMaybe<Array<EventGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<EventGeneric_Order_By>>;
  where?: InputMaybe<EventGeneric_Bool_Exp>;
};


export type Query_RootEventGenericByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootFlowGenericArgs = {
  distinct_on?: InputMaybe<Array<FlowGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FlowGeneric_Order_By>>;
  where?: InputMaybe<FlowGeneric_Bool_Exp>;
};


export type Query_RootFlowGenericAggregateArgs = {
  distinct_on?: InputMaybe<Array<FlowGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FlowGeneric_Order_By>>;
  where?: InputMaybe<FlowGeneric_Bool_Exp>;
};


export type Query_RootFlowGenericByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootFunctionGenericArgs = {
  distinct_on?: InputMaybe<Array<FunctionGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FunctionGeneric_Order_By>>;
  where?: InputMaybe<FunctionGeneric_Bool_Exp>;
};


export type Query_RootFunctionGenericAggregateArgs = {
  distinct_on?: InputMaybe<Array<FunctionGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FunctionGeneric_Order_By>>;
  where?: InputMaybe<FunctionGeneric_Bool_Exp>;
};


export type Query_RootFunctionGenericByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootInterfaceGenericArgs = {
  distinct_on?: InputMaybe<Array<InterfaceGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<InterfaceGeneric_Order_By>>;
  where?: InputMaybe<InterfaceGeneric_Bool_Exp>;
};


export type Query_RootInterfaceGenericAggregateArgs = {
  distinct_on?: InputMaybe<Array<InterfaceGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<InterfaceGeneric_Order_By>>;
  where?: InputMaybe<InterfaceGeneric_Bool_Exp>;
};


export type Query_RootInterfaceGenericByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootMotivationElementGenericArgs = {
  distinct_on?: InputMaybe<Array<MotivationElementGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MotivationElementGeneric_Order_By>>;
  where?: InputMaybe<MotivationElementGeneric_Bool_Exp>;
};


export type Query_RootMotivationElementGenericAggregateArgs = {
  distinct_on?: InputMaybe<Array<MotivationElementGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MotivationElementGeneric_Order_By>>;
  where?: InputMaybe<MotivationElementGeneric_Bool_Exp>;
};


export type Query_RootMotivationElementGenericByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootMotivationItemHierarchyMapArgs = {
  distinct_on?: InputMaybe<Array<MotivationItemHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MotivationItemHierarchyMap_Order_By>>;
  where?: InputMaybe<MotivationItemHierarchyMap_Bool_Exp>;
};


export type Query_RootMotivationItemHierarchyMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<MotivationItemHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MotivationItemHierarchyMap_Order_By>>;
  where?: InputMaybe<MotivationItemHierarchyMap_Bool_Exp>;
};


export type Query_RootMotivationItemHierarchyMapByPkArgs = {
  childId: Scalars['uuid']['input'];
  parentId: Scalars['uuid']['input'];
};


export type Query_RootPhysicalLocationArgs = {
  distinct_on?: InputMaybe<Array<PhysicalLocation_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PhysicalLocation_Order_By>>;
  where?: InputMaybe<PhysicalLocation_Bool_Exp>;
};


export type Query_RootPhysicalLocationAggregateArgs = {
  distinct_on?: InputMaybe<Array<PhysicalLocation_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PhysicalLocation_Order_By>>;
  where?: InputMaybe<PhysicalLocation_Bool_Exp>;
};


export type Query_RootPhysicalLocationByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootPlateauArgs = {
  distinct_on?: InputMaybe<Array<Plateau_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Plateau_Order_By>>;
  where?: InputMaybe<Plateau_Bool_Exp>;
};


export type Query_RootPlateauAggregateArgs = {
  distinct_on?: InputMaybe<Array<Plateau_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Plateau_Order_By>>;
  where?: InputMaybe<Plateau_Bool_Exp>;
};


export type Query_RootPlateauByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootProcessGenericArgs = {
  distinct_on?: InputMaybe<Array<ProcessGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ProcessGeneric_Order_By>>;
  where?: InputMaybe<ProcessGeneric_Bool_Exp>;
};


export type Query_RootProcessGenericAggregateArgs = {
  distinct_on?: InputMaybe<Array<ProcessGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ProcessGeneric_Order_By>>;
  where?: InputMaybe<ProcessGeneric_Bool_Exp>;
};


export type Query_RootProcessGenericByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootServiceGenericArgs = {
  distinct_on?: InputMaybe<Array<ServiceGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ServiceGeneric_Order_By>>;
  where?: InputMaybe<ServiceGeneric_Bool_Exp>;
};


export type Query_RootServiceGenericAggregateArgs = {
  distinct_on?: InputMaybe<Array<ServiceGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ServiceGeneric_Order_By>>;
  where?: InputMaybe<ServiceGeneric_Bool_Exp>;
};


export type Query_RootServiceGenericByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootSolutionArgs = {
  distinct_on?: InputMaybe<Array<Solution_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Solution_Order_By>>;
  where?: InputMaybe<Solution_Bool_Exp>;
};


export type Query_RootSolutionAggregateArgs = {
  distinct_on?: InputMaybe<Array<Solution_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Solution_Order_By>>;
  where?: InputMaybe<Solution_Bool_Exp>;
};


export type Query_RootSolutionApplicationComponentMapArgs = {
  distinct_on?: InputMaybe<Array<SolutionApplicationComponentMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionApplicationComponentMap_Order_By>>;
  where?: InputMaybe<SolutionApplicationComponentMap_Bool_Exp>;
};


export type Query_RootSolutionApplicationComponentMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<SolutionApplicationComponentMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionApplicationComponentMap_Order_By>>;
  where?: InputMaybe<SolutionApplicationComponentMap_Bool_Exp>;
};


export type Query_RootSolutionApplicationComponentMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  solutionId: Scalars['uuid']['input'];
};


export type Query_RootSolutionApplicationFunctionMapArgs = {
  distinct_on?: InputMaybe<Array<SolutionApplicationFunctionMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionApplicationFunctionMap_Order_By>>;
  where?: InputMaybe<SolutionApplicationFunctionMap_Bool_Exp>;
};


export type Query_RootSolutionApplicationFunctionMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<SolutionApplicationFunctionMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionApplicationFunctionMap_Order_By>>;
  where?: InputMaybe<SolutionApplicationFunctionMap_Bool_Exp>;
};


export type Query_RootSolutionApplicationFunctionMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  functionId: Scalars['uuid']['input'];
  solutionId: Scalars['uuid']['input'];
};


export type Query_RootSolutionByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootSolutionDataObjectMapArgs = {
  distinct_on?: InputMaybe<Array<SolutionDataObjectMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionDataObjectMap_Order_By>>;
  where?: InputMaybe<SolutionDataObjectMap_Bool_Exp>;
};


export type Query_RootSolutionDataObjectMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<SolutionDataObjectMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionDataObjectMap_Order_By>>;
  where?: InputMaybe<SolutionDataObjectMap_Bool_Exp>;
};


export type Query_RootSolutionDataObjectMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  dataObjectId: Scalars['uuid']['input'];
  solutionId: Scalars['uuid']['input'];
};


export type Query_RootSolutionFlowMapArgs = {
  distinct_on?: InputMaybe<Array<SolutionFlowMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionFlowMap_Order_By>>;
  where?: InputMaybe<SolutionFlowMap_Bool_Exp>;
};


export type Query_RootSolutionFlowMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<SolutionFlowMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionFlowMap_Order_By>>;
  where?: InputMaybe<SolutionFlowMap_Bool_Exp>;
};


export type Query_RootSolutionFlowMapByPkArgs = {
  flowId: Scalars['uuid']['input'];
  solutionId: Scalars['uuid']['input'];
};


export type Query_RootSolutionMotivationComponentMapArgs = {
  distinct_on?: InputMaybe<Array<SolutionMotivationComponentMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionMotivationComponentMap_Order_By>>;
  where?: InputMaybe<SolutionMotivationComponentMap_Bool_Exp>;
};


export type Query_RootSolutionMotivationComponentMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<SolutionMotivationComponentMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionMotivationComponentMap_Order_By>>;
  where?: InputMaybe<SolutionMotivationComponentMap_Bool_Exp>;
};


export type Query_RootSolutionMotivationComponentMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  motivationId: Scalars['uuid']['input'];
  solutionId: Scalars['uuid']['input'];
};


export type Query_RootSolutionMotivationElementMapArgs = {
  distinct_on?: InputMaybe<Array<SolutionMotivationElementMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionMotivationElementMap_Order_By>>;
  where?: InputMaybe<SolutionMotivationElementMap_Bool_Exp>;
};


export type Query_RootSolutionMotivationElementMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<SolutionMotivationElementMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionMotivationElementMap_Order_By>>;
  where?: InputMaybe<SolutionMotivationElementMap_Bool_Exp>;
};


export type Query_RootSolutionMotivationElementMapByPkArgs = {
  motivationId: Scalars['uuid']['input'];
  solutionId: Scalars['uuid']['input'];
};


export type Query_RootSolutionStakeholderMapArgs = {
  distinct_on?: InputMaybe<Array<SolutionStakeholderMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionStakeholderMap_Order_By>>;
  where?: InputMaybe<SolutionStakeholderMap_Bool_Exp>;
};


export type Query_RootSolutionStakeholderMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<SolutionStakeholderMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionStakeholderMap_Order_By>>;
  where?: InputMaybe<SolutionStakeholderMap_Bool_Exp>;
};


export type Query_RootSolutionStakeholderMapByPkArgs = {
  solutionId: Scalars['uuid']['input'];
  stakeholderId: Scalars['uuid']['input'];
};


export type Query_RootSolutionTechnologyNodeMapArgs = {
  distinct_on?: InputMaybe<Array<SolutionTechnologyNodeMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionTechnologyNodeMap_Order_By>>;
  where?: InputMaybe<SolutionTechnologyNodeMap_Bool_Exp>;
};


export type Query_RootSolutionTechnologyNodeMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<SolutionTechnologyNodeMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionTechnologyNodeMap_Order_By>>;
  where?: InputMaybe<SolutionTechnologyNodeMap_Bool_Exp>;
};


export type Query_RootSolutionTechnologyNodeMapByPkArgs = {
  nodeId: Scalars['uuid']['input'];
  solutionId: Scalars['uuid']['input'];
};


export type Query_RootStakeholderArgs = {
  distinct_on?: InputMaybe<Array<Stakeholder_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Stakeholder_Order_By>>;
  where?: InputMaybe<Stakeholder_Bool_Exp>;
};


export type Query_RootStakeholderAggregateArgs = {
  distinct_on?: InputMaybe<Array<Stakeholder_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Stakeholder_Order_By>>;
  where?: InputMaybe<Stakeholder_Bool_Exp>;
};


export type Query_RootStakeholderByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootSystemSoftwareArgs = {
  distinct_on?: InputMaybe<Array<SystemSoftware_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SystemSoftware_Order_By>>;
  where?: InputMaybe<SystemSoftware_Bool_Exp>;
};


export type Query_RootSystemSoftwareAggregateArgs = {
  distinct_on?: InputMaybe<Array<SystemSoftware_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SystemSoftware_Order_By>>;
  where?: InputMaybe<SystemSoftware_Bool_Exp>;
};


export type Query_RootSystemSoftwareByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootTechnologyNetworkArgs = {
  distinct_on?: InputMaybe<Array<TechnologyNetwork_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TechnologyNetwork_Order_By>>;
  where?: InputMaybe<TechnologyNetwork_Bool_Exp>;
};


export type Query_RootTechnologyNetworkAggregateArgs = {
  distinct_on?: InputMaybe<Array<TechnologyNetwork_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TechnologyNetwork_Order_By>>;
  where?: InputMaybe<TechnologyNetwork_Bool_Exp>;
};


export type Query_RootTechnologyNetworkByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootTechnologyNetworkHierarchyMapArgs = {
  distinct_on?: InputMaybe<Array<TechnologyNetworkHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TechnologyNetworkHierarchyMap_Order_By>>;
  where?: InputMaybe<TechnologyNetworkHierarchyMap_Bool_Exp>;
};


export type Query_RootTechnologyNetworkHierarchyMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<TechnologyNetworkHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TechnologyNetworkHierarchyMap_Order_By>>;
  where?: InputMaybe<TechnologyNetworkHierarchyMap_Bool_Exp>;
};


export type Query_RootTechnologyNetworkHierarchyMapByPkArgs = {
  networkChildId: Scalars['uuid']['input'];
  networkParentId: Scalars['uuid']['input'];
};


export type Query_RootTechnologyNodeArgs = {
  distinct_on?: InputMaybe<Array<TechnologyNode_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TechnologyNode_Order_By>>;
  where?: InputMaybe<TechnologyNode_Bool_Exp>;
};


export type Query_RootTechnologyNodeAggregateArgs = {
  distinct_on?: InputMaybe<Array<TechnologyNode_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TechnologyNode_Order_By>>;
  where?: InputMaybe<TechnologyNode_Bool_Exp>;
};


export type Query_RootTechnologyNodeByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootTechnologyNodeHierarchyMapArgs = {
  distinct_on?: InputMaybe<Array<TechnologyNodeHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TechnologyNodeHierarchyMap_Order_By>>;
  where?: InputMaybe<TechnologyNodeHierarchyMap_Bool_Exp>;
};


export type Query_RootTechnologyNodeHierarchyMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<TechnologyNodeHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TechnologyNodeHierarchyMap_Order_By>>;
  where?: InputMaybe<TechnologyNodeHierarchyMap_Bool_Exp>;
};


export type Query_RootTechnologyNodeHierarchyMapByPkArgs = {
  nodeChildId: Scalars['uuid']['input'];
  nodeParentId: Scalars['uuid']['input'];
};


export type Query_RootTechnologyNodeSystemSoftwareMapArgs = {
  distinct_on?: InputMaybe<Array<TechnologyNodeSystemSoftwareMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TechnologyNodeSystemSoftwareMap_Order_By>>;
  where?: InputMaybe<TechnologyNodeSystemSoftwareMap_Bool_Exp>;
};


export type Query_RootTechnologyNodeSystemSoftwareMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<TechnologyNodeSystemSoftwareMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TechnologyNodeSystemSoftwareMap_Order_By>>;
  where?: InputMaybe<TechnologyNodeSystemSoftwareMap_Bool_Exp>;
};


export type Query_RootTechnologyNodeSystemSoftwareMapByPkArgs = {
  nodeId: Scalars['uuid']['input'];
  systemSoftwareId: Scalars['uuid']['input'];
};


export type Query_RootMapSolutionConstraintArgs = {
  distinct_on?: InputMaybe<Array<MapSolutionConstraint_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MapSolutionConstraint_Order_By>>;
  where?: InputMaybe<MapSolutionConstraint_Bool_Exp>;
};


export type Query_RootMapSolutionConstraint_AggregateArgs = {
  distinct_on?: InputMaybe<Array<MapSolutionConstraint_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MapSolutionConstraint_Order_By>>;
  where?: InputMaybe<MapSolutionConstraint_Bool_Exp>;
};


export type Query_RootMapSolutionConstraint_By_PkArgs = {
  constraintId: Scalars['uuid']['input'];
  solutionId: Scalars['uuid']['input'];
};


export type Query_RootMapTenantUserProfilesArgs = {
  distinct_on?: InputMaybe<Array<MapTenantUserProfiles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MapTenantUserProfiles_Order_By>>;
  where?: InputMaybe<MapTenantUserProfiles_Bool_Exp>;
};


export type Query_RootMapTenantUserProfiles_AggregateArgs = {
  distinct_on?: InputMaybe<Array<MapTenantUserProfiles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MapTenantUserProfiles_Order_By>>;
  where?: InputMaybe<MapTenantUserProfiles_Bool_Exp>;
};


export type Query_RootMapTenantUserProfiles_By_PkArgs = {
  userId: Scalars['uuid']['input'];
};


export type Query_RootTenantsArgs = {
  distinct_on?: InputMaybe<Array<Tenants_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tenants_Order_By>>;
  where?: InputMaybe<Tenants_Bool_Exp>;
};


export type Query_RootTenants_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Tenants_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tenants_Order_By>>;
  where?: InputMaybe<Tenants_Bool_Exp>;
};


export type Query_RootTenants_By_PkArgs = {
  id: Scalars['uuid']['input'];
};


export type Query_RootUserProfilesArgs = {
  distinct_on?: InputMaybe<Array<UserProfiles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UserProfiles_Order_By>>;
  where?: InputMaybe<UserProfiles_Bool_Exp>;
};


export type Query_RootUserProfiles_AggregateArgs = {
  distinct_on?: InputMaybe<Array<UserProfiles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UserProfiles_Order_By>>;
  where?: InputMaybe<UserProfiles_Bool_Exp>;
};


export type Query_RootUserProfiles_By_PkArgs = {
  id: Scalars['uuid']['input'];
};

/** Boolean expression to compare columns of type "risk_category_enum". All fields are combined with logical 'AND'. */
export type Risk_Category_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['risk_category_enum']['input']>;
  _gt?: InputMaybe<Scalars['risk_category_enum']['input']>;
  _gte?: InputMaybe<Scalars['risk_category_enum']['input']>;
  _in?: InputMaybe<Array<Scalars['risk_category_enum']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['risk_category_enum']['input']>;
  _lte?: InputMaybe<Scalars['risk_category_enum']['input']>;
  _neq?: InputMaybe<Scalars['risk_category_enum']['input']>;
  _nin?: InputMaybe<Array<Scalars['risk_category_enum']['input']>>;
};

/** Boolean expression to compare columns of type "risk_status_enum". All fields are combined with logical 'AND'. */
export type Risk_Status_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['risk_status_enum']['input']>;
  _gt?: InputMaybe<Scalars['risk_status_enum']['input']>;
  _gte?: InputMaybe<Scalars['risk_status_enum']['input']>;
  _in?: InputMaybe<Array<Scalars['risk_status_enum']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['risk_status_enum']['input']>;
  _lte?: InputMaybe<Scalars['risk_status_enum']['input']>;
  _neq?: InputMaybe<Scalars['risk_status_enum']['input']>;
  _nin?: InputMaybe<Array<Scalars['risk_status_enum']['input']>>;
};

/** Boolean expression to compare columns of type "smallint". All fields are combined with logical 'AND'. */
export type Smallint_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['smallint']['input']>;
  _gt?: InputMaybe<Scalars['smallint']['input']>;
  _gte?: InputMaybe<Scalars['smallint']['input']>;
  _in?: InputMaybe<Array<Scalars['smallint']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['smallint']['input']>;
  _lte?: InputMaybe<Scalars['smallint']['input']>;
  _neq?: InputMaybe<Scalars['smallint']['input']>;
  _nin?: InputMaybe<Array<Scalars['smallint']['input']>>;
};

/** Boolean expression to compare columns of type "solution_implementation_status_enum". All fields are combined with logical 'AND'. */
export type Solution_Implementation_Status_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['solution_implementation_status_enum']['input']>;
  _gt?: InputMaybe<Scalars['solution_implementation_status_enum']['input']>;
  _gte?: InputMaybe<Scalars['solution_implementation_status_enum']['input']>;
  _in?: InputMaybe<Array<Scalars['solution_implementation_status_enum']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['solution_implementation_status_enum']['input']>;
  _lte?: InputMaybe<Scalars['solution_implementation_status_enum']['input']>;
  _neq?: InputMaybe<Scalars['solution_implementation_status_enum']['input']>;
  _nin?: InputMaybe<Array<Scalars['solution_implementation_status_enum']['input']>>;
};

/** Boolean expression to compare columns of type "solution_item_impact_type_enum". All fields are combined with logical 'AND'. */
export type Solution_Item_Impact_Type_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['solution_item_impact_type_enum']['input']>;
  _gt?: InputMaybe<Scalars['solution_item_impact_type_enum']['input']>;
  _gte?: InputMaybe<Scalars['solution_item_impact_type_enum']['input']>;
  _in?: InputMaybe<Array<Scalars['solution_item_impact_type_enum']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['solution_item_impact_type_enum']['input']>;
  _lte?: InputMaybe<Scalars['solution_item_impact_type_enum']['input']>;
  _neq?: InputMaybe<Scalars['solution_item_impact_type_enum']['input']>;
  _nin?: InputMaybe<Array<Scalars['solution_item_impact_type_enum']['input']>>;
};

/** Boolean expression to compare columns of type "solution_life_cycle_enum". All fields are combined with logical 'AND'. */
export type Solution_Life_Cycle_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['solution_life_cycle_enum']['input']>;
  _gt?: InputMaybe<Scalars['solution_life_cycle_enum']['input']>;
  _gte?: InputMaybe<Scalars['solution_life_cycle_enum']['input']>;
  _in?: InputMaybe<Array<Scalars['solution_life_cycle_enum']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['solution_life_cycle_enum']['input']>;
  _lte?: InputMaybe<Scalars['solution_life_cycle_enum']['input']>;
  _neq?: InputMaybe<Scalars['solution_life_cycle_enum']['input']>;
  _nin?: InputMaybe<Array<Scalars['solution_life_cycle_enum']['input']>>;
};

/** Boolean expression to compare columns of type "stakeholder_role_enum". All fields are combined with logical 'AND'. */
export type Stakeholder_Role_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['stakeholder_role_enum']['input']>;
  _gt?: InputMaybe<Scalars['stakeholder_role_enum']['input']>;
  _gte?: InputMaybe<Scalars['stakeholder_role_enum']['input']>;
  _in?: InputMaybe<Array<Scalars['stakeholder_role_enum']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['stakeholder_role_enum']['input']>;
  _lte?: InputMaybe<Scalars['stakeholder_role_enum']['input']>;
  _neq?: InputMaybe<Scalars['stakeholder_role_enum']['input']>;
  _nin?: InputMaybe<Array<Scalars['stakeholder_role_enum']['input']>>;
};

export type Subscription_Root = {
  __typename?: 'subscription_root';
  /** fetch data from the table: "components" */
  ApplicationComponent: Array<ApplicationComponent>;
  /** fetch aggregated fields from the table: "components" */
  ApplicationComponentAggregate: ApplicationComponent_Aggregate;
  /** fetch data from the table: "map_application_component_actor_role" */
  ApplicationComponentBusinessActorRoleMap: Array<ApplicationComponentBusinessActorRoleMap>;
  /** fetch aggregated fields from the table: "map_application_component_actor_role" */
  ApplicationComponentBusinessActorRoleMapAggregate: ApplicationComponentBusinessActorRoleMap_Aggregate;
  /** fetch data from the table: "map_application_component_actor_role" using primary key columns */
  ApplicationComponentBusinessActorRoleMapByPk?: Maybe<ApplicationComponentBusinessActorRoleMap>;
  /** fetch data from the table in a streaming manner: "map_application_component_actor_role" */
  ApplicationComponentBusinessActorRoleMap_stream: Array<ApplicationComponentBusinessActorRoleMap>;
  /** fetch data from the table: "components" using primary key columns */
  ApplicationComponentByPk?: Maybe<ApplicationComponent>;
  /** fetch data from the table: "map_application_component_data_object" */
  ApplicationComponentDataObjectMap: Array<ApplicationComponentDataObjectMap>;
  /** fetch aggregated fields from the table: "map_application_component_data_object" */
  ApplicationComponentDataObjectMapAggregate: ApplicationComponentDataObjectMap_Aggregate;
  /** fetch data from the table: "map_application_component_data_object" using primary key columns */
  ApplicationComponentDataObjectMapByPk?: Maybe<ApplicationComponentDataObjectMap>;
  /** fetch data from the table in a streaming manner: "map_application_component_data_object" */
  ApplicationComponentDataObjectMap_stream: Array<ApplicationComponentDataObjectMap>;
  /** fetch data from the table: "map_application_component_directory" */
  ApplicationComponentDirectoryMap: Array<ApplicationComponentDirectoryMap>;
  /** fetch aggregated fields from the table: "map_application_component_directory" */
  ApplicationComponentDirectoryMapAggregate: ApplicationComponentDirectoryMap_Aggregate;
  /** fetch data from the table: "map_application_component_directory" using primary key columns */
  ApplicationComponentDirectoryMapByPk?: Maybe<ApplicationComponentDirectoryMap>;
  /** fetch data from the table in a streaming manner: "map_application_component_directory" */
  ApplicationComponentDirectoryMap_stream: Array<ApplicationComponentDirectoryMap>;
  /** fetch data from the table: "map_application_component_event" */
  ApplicationComponentEventMap: Array<ApplicationComponentEventMap>;
  /** fetch aggregated fields from the table: "map_application_component_event" */
  ApplicationComponentEventMapAggregate: ApplicationComponentEventMap_Aggregate;
  /** fetch data from the table: "map_application_component_event" using primary key columns */
  ApplicationComponentEventMapByPk?: Maybe<ApplicationComponentEventMap>;
  /** fetch data from the table in a streaming manner: "map_application_component_event" */
  ApplicationComponentEventMap_stream: Array<ApplicationComponentEventMap>;
  /** fetch data from the table: "map_application_component_function" */
  ApplicationComponentFunctionMap: Array<ApplicationComponentFunctionMap>;
  /** fetch aggregated fields from the table: "map_application_component_function" */
  ApplicationComponentFunctionMapAggregate: ApplicationComponentFunctionMap_Aggregate;
  /** fetch data from the table: "map_application_component_function" using primary key columns */
  ApplicationComponentFunctionMapByPk?: Maybe<ApplicationComponentFunctionMap>;
  /** fetch data from the table in a streaming manner: "map_application_component_function" */
  ApplicationComponentFunctionMap_stream: Array<ApplicationComponentFunctionMap>;
  /** fetch data from the table: "map_application_component_hierarchy" */
  ApplicationComponentHierarchyMap: Array<ApplicationComponentHierarchyMap>;
  /** fetch aggregated fields from the table: "map_application_component_hierarchy" */
  ApplicationComponentHierarchyMapAggregate: ApplicationComponentHierarchyMap_Aggregate;
  /** fetch data from the table: "map_application_component_hierarchy" using primary key columns */
  ApplicationComponentHierarchyMapByPk?: Maybe<ApplicationComponentHierarchyMap>;
  /** fetch data from the table in a streaming manner: "map_application_component_hierarchy" */
  ApplicationComponentHierarchyMap_stream: Array<ApplicationComponentHierarchyMap>;
  /** fetch data from the table: "map_application_component_interface" */
  ApplicationComponentInterfaceMap: Array<ApplicationComponentInterfaceMap>;
  /** fetch aggregated fields from the table: "map_application_component_interface" */
  ApplicationComponentInterfaceMapAggregate: ApplicationComponentInterfaceMap_Aggregate;
  /** fetch data from the table: "map_application_component_interface" using primary key columns */
  ApplicationComponentInterfaceMapByPk?: Maybe<ApplicationComponentInterfaceMap>;
  /** fetch data from the table in a streaming manner: "map_application_component_interface" */
  ApplicationComponentInterfaceMap_stream: Array<ApplicationComponentInterfaceMap>;
  /** fetch data from the table: "map_application_component_product" */
  ApplicationComponentProductMap: Array<ApplicationComponentProductMap>;
  /** fetch aggregated fields from the table: "map_application_component_product" */
  ApplicationComponentProductMapAggregate: ApplicationComponentProductMap_Aggregate;
  /** fetch data from the table: "map_application_component_product" using primary key columns */
  ApplicationComponentProductMapByPk?: Maybe<ApplicationComponentProductMap>;
  /** fetch data from the table in a streaming manner: "map_application_component_product" */
  ApplicationComponentProductMap_stream: Array<ApplicationComponentProductMap>;
  /** fetch data from the table: "map_application_component_stakeholder" */
  ApplicationComponentStakeholderMap: Array<ApplicationComponentStakeholderMap>;
  /** fetch aggregated fields from the table: "map_application_component_stakeholder" */
  ApplicationComponentStakeholderMapAggregate: ApplicationComponentStakeholderMap_Aggregate;
  /** fetch data from the table: "map_application_component_stakeholder" using primary key columns */
  ApplicationComponentStakeholderMapByPk?: Maybe<ApplicationComponentStakeholderMap>;
  /** fetch data from the table in a streaming manner: "map_application_component_stakeholder" */
  ApplicationComponentStakeholderMap_stream: Array<ApplicationComponentStakeholderMap>;
  /** fetch data from the table: "map_application_component_system_software" */
  ApplicationComponentSystemSoftwareMap: Array<ApplicationComponentSystemSoftwareMap>;
  /** fetch aggregated fields from the table: "map_application_component_system_software" */
  ApplicationComponentSystemSoftwareMapAggregate: ApplicationComponentSystemSoftwareMap_Aggregate;
  /** fetch data from the table: "map_application_component_system_software" using primary key columns */
  ApplicationComponentSystemSoftwareMapByPk?: Maybe<ApplicationComponentSystemSoftwareMap>;
  /** fetch data from the table in a streaming manner: "map_application_component_system_software" */
  ApplicationComponentSystemSoftwareMap_stream: Array<ApplicationComponentSystemSoftwareMap>;
  /** fetch data from the table: "map_application_component_technology_logical_network" */
  ApplicationComponentTechnologyLogicalNetworkMap: Array<ApplicationComponentTechnologyLogicalNetworkMap>;
  /** fetch aggregated fields from the table: "map_application_component_technology_logical_network" */
  ApplicationComponentTechnologyLogicalNetworkMapAggregate: ApplicationComponentTechnologyLogicalNetworkMap_Aggregate;
  /** fetch data from the table: "map_application_component_technology_logical_network" using primary key columns */
  ApplicationComponentTechnologyLogicalNetworkMapByPk?: Maybe<ApplicationComponentTechnologyLogicalNetworkMap>;
  /** fetch data from the table in a streaming manner: "map_application_component_technology_logical_network" */
  ApplicationComponentTechnologyLogicalNetworkMap_stream: Array<ApplicationComponentTechnologyLogicalNetworkMap>;
  /** fetch data from the table: "map_application_component_technology_node" */
  ApplicationComponentTechnologyNodeMap: Array<ApplicationComponentTechnologyNodeMap>;
  /** fetch aggregated fields from the table: "map_application_component_technology_node" */
  ApplicationComponentTechnologyNodeMapAggregate: ApplicationComponentTechnologyNodeMap_Aggregate;
  /** fetch data from the table: "map_application_component_technology_node" using primary key columns */
  ApplicationComponentTechnologyNodeMapByPk?: Maybe<ApplicationComponentTechnologyNodeMap>;
  /** fetch data from the table in a streaming manner: "map_application_component_technology_node" */
  ApplicationComponentTechnologyNodeMap_stream: Array<ApplicationComponentTechnologyNodeMap>;
  /** fetch data from the table in a streaming manner: "components" */
  ApplicationComponent_stream: Array<ApplicationComponent>;
  /** fetch data from the table: "map_application_function_data_object" */
  ApplicationFunctionDataObjectMap: Array<ApplicationFunctionDataObjectMap>;
  /** fetch aggregated fields from the table: "map_application_function_data_object" */
  ApplicationFunctionDataObjectMapAggregate: ApplicationFunctionDataObjectMap_Aggregate;
  /** fetch data from the table: "map_application_function_data_object" using primary key columns */
  ApplicationFunctionDataObjectMapByPk?: Maybe<ApplicationFunctionDataObjectMap>;
  /** fetch data from the table in a streaming manner: "map_application_function_data_object" */
  ApplicationFunctionDataObjectMap_stream: Array<ApplicationFunctionDataObjectMap>;
  /** fetch data from the table: "map_application_interface_function" */
  ApplicationFunctionInterfaceMap: Array<ApplicationFunctionInterfaceMap>;
  /** fetch aggregated fields from the table: "map_application_interface_function" */
  ApplicationFunctionInterfaceMapAggregate: ApplicationFunctionInterfaceMap_Aggregate;
  /** fetch data from the table: "map_application_interface_function" using primary key columns */
  ApplicationFunctionInterfaceMapByPk?: Maybe<ApplicationFunctionInterfaceMap>;
  /** fetch data from the table in a streaming manner: "map_application_interface_function" */
  ApplicationFunctionInterfaceMap_stream: Array<ApplicationFunctionInterfaceMap>;
  /** fetch data from the table: "actors" */
  BusinessActor: Array<BusinessActor>;
  /** fetch aggregated fields from the table: "actors" */
  BusinessActorAggregate: BusinessActor_Aggregate;
  /** fetch data from the table: "actors" using primary key columns */
  BusinessActorByPk?: Maybe<BusinessActor>;
  /** fetch data from the table: "map_business_actor_role" */
  BusinessActorRoleMap: Array<BusinessActorRoleMap>;
  /** fetch aggregated fields from the table: "map_business_actor_role" */
  BusinessActorRoleMapAggregate: BusinessActorRoleMap_Aggregate;
  /** fetch data from the table: "map_business_actor_role" using primary key columns */
  BusinessActorRoleMapByPk?: Maybe<BusinessActorRoleMap>;
  /** fetch data from the table in a streaming manner: "map_business_actor_role" */
  BusinessActorRoleMap_stream: Array<BusinessActorRoleMap>;
  /** fetch data from the table in a streaming manner: "actors" */
  BusinessActor_stream: Array<BusinessActor>;
  /** fetch data from the table: "map_business_process_function" */
  BusinessProcessFunctionMap: Array<BusinessProcessFunctionMap>;
  /** fetch aggregated fields from the table: "map_business_process_function" */
  BusinessProcessFunctionMapAggregate: BusinessProcessFunctionMap_Aggregate;
  /** fetch data from the table: "map_business_process_function" using primary key columns */
  BusinessProcessFunctionMapByPk?: Maybe<BusinessProcessFunctionMap>;
  /** fetch data from the table in a streaming manner: "map_business_process_function" */
  BusinessProcessFunctionMap_stream: Array<BusinessProcessFunctionMap>;
  /** fetch data from the table: "map_business_process_hierarchy" */
  BusinessProcessHierarchyMap: Array<BusinessProcessHierarchyMap>;
  /** fetch aggregated fields from the table: "map_business_process_hierarchy" */
  BusinessProcessHierarchyMapAggregate: BusinessProcessHierarchyMap_Aggregate;
  /** fetch data from the table: "map_business_process_hierarchy" using primary key columns */
  BusinessProcessHierarchyMapByPk?: Maybe<BusinessProcessHierarchyMap>;
  /** fetch data from the table in a streaming manner: "map_business_process_hierarchy" */
  BusinessProcessHierarchyMap_stream: Array<BusinessProcessHierarchyMap>;
  /** fetch data from the table: "map_business_process_motivation_item" */
  BusinessProcessMotivationItemMap: Array<BusinessProcessMotivationItemMap>;
  /** fetch aggregated fields from the table: "map_business_process_motivation_item" */
  BusinessProcessMotivationItemMapAggregate: BusinessProcessMotivationItemMap_Aggregate;
  /** fetch data from the table: "map_business_process_motivation_item" using primary key columns */
  BusinessProcessMotivationItemMapByPk?: Maybe<BusinessProcessMotivationItemMap>;
  /** fetch data from the table in a streaming manner: "map_business_process_motivation_item" */
  BusinessProcessMotivationItemMap_stream: Array<BusinessProcessMotivationItemMap>;
  /** fetch data from the table: "products" */
  BusinessProduct: Array<BusinessProduct>;
  /** fetch aggregated fields from the table: "products" */
  BusinessProductAggregate: BusinessProduct_Aggregate;
  /** fetch data from the table: "products" using primary key columns */
  BusinessProductByPk?: Maybe<BusinessProduct>;
  /** fetch data from the table in a streaming manner: "products" */
  BusinessProduct_stream: Array<BusinessProduct>;
  /** fetch data from the table: "roles" */
  BusinessRole: Array<BusinessRole>;
  /** fetch aggregated fields from the table: "roles" */
  BusinessRoleAggregate: BusinessRole_Aggregate;
  /** fetch data from the table: "roles" using primary key columns */
  BusinessRoleByPk?: Maybe<BusinessRole>;
  /** fetch data from the table in a streaming manner: "roles" */
  BusinessRole_stream: Array<BusinessRole>;
  /** fetch data from the table: "capabilities" */
  Capability: Array<Capability>;
  /** fetch aggregated fields from the table: "capabilities" */
  CapabilityAggregate: Capability_Aggregate;
  /** fetch data from the table: "map_capability_application_component_assessment" */
  CapabilityApplicationComponentAssessmentMap: Array<CapabilityApplicationComponentAssessmentMap>;
  /** fetch aggregated fields from the table: "map_capability_application_component_assessment" */
  CapabilityApplicationComponentAssessmentMapAggregate: CapabilityApplicationComponentAssessmentMap_Aggregate;
  /** fetch data from the table: "map_capability_application_component_assessment" using primary key columns */
  CapabilityApplicationComponentAssessmentMapByPk?: Maybe<CapabilityApplicationComponentAssessmentMap>;
  /** fetch data from the table in a streaming manner: "map_capability_application_component_assessment" */
  CapabilityApplicationComponentAssessmentMap_stream: Array<CapabilityApplicationComponentAssessmentMap>;
  /** fetch data from the table: "map_capability_application_component" */
  CapabilityApplicationComponentMap: Array<CapabilityApplicationComponentMap>;
  /** fetch aggregated fields from the table: "map_capability_application_component" */
  CapabilityApplicationComponentMapAggregate: CapabilityApplicationComponentMap_Aggregate;
  /** fetch data from the table: "map_capability_application_component" using primary key columns */
  CapabilityApplicationComponentMapByPk?: Maybe<CapabilityApplicationComponentMap>;
  /** fetch data from the table in a streaming manner: "map_capability_application_component" */
  CapabilityApplicationComponentMap_stream: Array<CapabilityApplicationComponentMap>;
  /** fetch data from the table: "map_capability_business_process_assessment" */
  CapabilityBusinessProcessAssessmentMap: Array<CapabilityBusinessProcessAssessmentMap>;
  /** fetch aggregated fields from the table: "map_capability_business_process_assessment" */
  CapabilityBusinessProcessAssessmentMapAggregate: CapabilityBusinessProcessAssessmentMap_Aggregate;
  /** fetch data from the table: "map_capability_business_process_assessment" using primary key columns */
  CapabilityBusinessProcessAssessmentMapByPk?: Maybe<CapabilityBusinessProcessAssessmentMap>;
  /** fetch data from the table in a streaming manner: "map_capability_business_process_assessment" */
  CapabilityBusinessProcessAssessmentMap_stream: Array<CapabilityBusinessProcessAssessmentMap>;
  /** fetch data from the table: "map_capability_business_process" */
  CapabilityBusinessProcessMap: Array<CapabilityBusinessProcessMap>;
  /** fetch aggregated fields from the table: "map_capability_business_process" */
  CapabilityBusinessProcessMapAggregate: CapabilityBusinessProcessMap_Aggregate;
  /** fetch data from the table: "map_capability_business_process" using primary key columns */
  CapabilityBusinessProcessMapByPk?: Maybe<CapabilityBusinessProcessMap>;
  /** fetch data from the table in a streaming manner: "map_capability_business_process" */
  CapabilityBusinessProcessMap_stream: Array<CapabilityBusinessProcessMap>;
  /** fetch data from the table: "capabilities" using primary key columns */
  CapabilityByPk?: Maybe<Capability>;
  /** fetch data from the table: "map_capability_hierarchy" */
  CapabilityHierarchyMap: Array<CapabilityHierarchyMap>;
  /** fetch aggregated fields from the table: "map_capability_hierarchy" */
  CapabilityHierarchyMapAggregate: CapabilityHierarchyMap_Aggregate;
  /** fetch data from the table: "map_capability_hierarchy" using primary key columns */
  CapabilityHierarchyMapByPk?: Maybe<CapabilityHierarchyMap>;
  /** fetch data from the table in a streaming manner: "map_capability_hierarchy" */
  CapabilityHierarchyMap_stream: Array<CapabilityHierarchyMap>;
  /** fetch data from the table in a streaming manner: "capabilities" */
  Capability_stream: Array<Capability>;
  /** fetch data from the table: "data_objects" */
  DataObject: Array<DataObject>;
  /** fetch aggregated fields from the table: "data_objects" */
  DataObjectAggregate: DataObject_Aggregate;
  /** fetch data from the table: "data_objects" using primary key columns */
  DataObjectByPk?: Maybe<DataObject>;
  /** fetch data from the table in a streaming manner: "data_objects" */
  DataObject_stream: Array<DataObject>;
  /** fetch data from the table: "map_directory_items" */
  DirectoryItemsMap: Array<DirectoryItemsMap>;
  /** fetch aggregated fields from the table: "map_directory_items" */
  DirectoryItemsMapAggregate: DirectoryItemsMap_Aggregate;
  /** fetch data from the table: "map_directory_items" using primary key columns */
  DirectoryItemsMapByPk?: Maybe<DirectoryItemsMap>;
  /** fetch data from the table in a streaming manner: "map_directory_items" */
  DirectoryItemsMap_stream: Array<DirectoryItemsMap>;
  /** fetch data from the table: "directories" */
  DirectoryObject: Array<DirectoryObject>;
  /** fetch aggregated fields from the table: "directories" */
  DirectoryObjectAggregate: DirectoryObject_Aggregate;
  /** fetch data from the table: "directories" using primary key columns */
  DirectoryObjectByPk?: Maybe<DirectoryObject>;
  /** fetch data from the table in a streaming manner: "directories" */
  DirectoryObject_stream: Array<DirectoryObject>;
  /** fetch data from the table: "employees" */
  Employee: Array<Employee>;
  /** fetch aggregated fields from the table: "employees" */
  EmployeeAggregate: Employee_Aggregate;
  /** fetch data from the table: "employees" using primary key columns */
  EmployeeByPk?: Maybe<Employee>;
  /** fetch data from the table in a streaming manner: "employees" */
  Employee_stream: Array<Employee>;
  /** fetch data from the table: "events" */
  EventGeneric: Array<EventGeneric>;
  /** fetch aggregated fields from the table: "events" */
  EventGenericAggregate: EventGeneric_Aggregate;
  /** fetch data from the table: "events" using primary key columns */
  EventGenericByPk?: Maybe<EventGeneric>;
  /** fetch data from the table in a streaming manner: "events" */
  EventGeneric_stream: Array<EventGeneric>;
  /** fetch data from the table: "flows" */
  FlowGeneric: Array<FlowGeneric>;
  /** fetch aggregated fields from the table: "flows" */
  FlowGenericAggregate: FlowGeneric_Aggregate;
  /** fetch data from the table: "flows" using primary key columns */
  FlowGenericByPk?: Maybe<FlowGeneric>;
  /** fetch data from the table in a streaming manner: "flows" */
  FlowGeneric_stream: Array<FlowGeneric>;
  /** fetch data from the table: "functions" */
  FunctionGeneric: Array<FunctionGeneric>;
  /** fetch aggregated fields from the table: "functions" */
  FunctionGenericAggregate: FunctionGeneric_Aggregate;
  /** fetch data from the table: "functions" using primary key columns */
  FunctionGenericByPk?: Maybe<FunctionGeneric>;
  /** fetch data from the table in a streaming manner: "functions" */
  FunctionGeneric_stream: Array<FunctionGeneric>;
  /** fetch data from the table: "interfaces" */
  InterfaceGeneric: Array<InterfaceGeneric>;
  /** fetch aggregated fields from the table: "interfaces" */
  InterfaceGenericAggregate: InterfaceGeneric_Aggregate;
  /** fetch data from the table: "interfaces" using primary key columns */
  InterfaceGenericByPk?: Maybe<InterfaceGeneric>;
  /** fetch data from the table in a streaming manner: "interfaces" */
  InterfaceGeneric_stream: Array<InterfaceGeneric>;
  /** fetch data from the table: "motivations" */
  MotivationElementGeneric: Array<MotivationElementGeneric>;
  /** fetch aggregated fields from the table: "motivations" */
  MotivationElementGenericAggregate: MotivationElementGeneric_Aggregate;
  /** fetch data from the table: "motivations" using primary key columns */
  MotivationElementGenericByPk?: Maybe<MotivationElementGeneric>;
  /** fetch data from the table in a streaming manner: "motivations" */
  MotivationElementGeneric_stream: Array<MotivationElementGeneric>;
  /** fetch data from the table: "map_motivation_item_hierarchy" */
  MotivationItemHierarchyMap: Array<MotivationItemHierarchyMap>;
  /** fetch aggregated fields from the table: "map_motivation_item_hierarchy" */
  MotivationItemHierarchyMapAggregate: MotivationItemHierarchyMap_Aggregate;
  /** fetch data from the table: "map_motivation_item_hierarchy" using primary key columns */
  MotivationItemHierarchyMapByPk?: Maybe<MotivationItemHierarchyMap>;
  /** fetch data from the table in a streaming manner: "map_motivation_item_hierarchy" */
  MotivationItemHierarchyMap_stream: Array<MotivationItemHierarchyMap>;
  /** fetch data from the table: "locations" */
  PhysicalLocation: Array<PhysicalLocation>;
  /** fetch aggregated fields from the table: "locations" */
  PhysicalLocationAggregate: PhysicalLocation_Aggregate;
  /** fetch data from the table: "locations" using primary key columns */
  PhysicalLocationByPk?: Maybe<PhysicalLocation>;
  /** fetch data from the table in a streaming manner: "locations" */
  PhysicalLocation_stream: Array<PhysicalLocation>;
  /** fetch data from the table: "plateaus" */
  Plateau: Array<Plateau>;
  /** fetch aggregated fields from the table: "plateaus" */
  PlateauAggregate: Plateau_Aggregate;
  /** fetch data from the table: "plateaus" using primary key columns */
  PlateauByPk?: Maybe<Plateau>;
  /** fetch data from the table in a streaming manner: "plateaus" */
  Plateau_stream: Array<Plateau>;
  /** fetch data from the table: "processes" */
  ProcessGeneric: Array<ProcessGeneric>;
  /** fetch aggregated fields from the table: "processes" */
  ProcessGenericAggregate: ProcessGeneric_Aggregate;
  /** fetch data from the table: "processes" using primary key columns */
  ProcessGenericByPk?: Maybe<ProcessGeneric>;
  /** fetch data from the table in a streaming manner: "processes" */
  ProcessGeneric_stream: Array<ProcessGeneric>;
  /** fetch data from the table: "services" */
  ServiceGeneric: Array<ServiceGeneric>;
  /** fetch aggregated fields from the table: "services" */
  ServiceGenericAggregate: ServiceGeneric_Aggregate;
  /** fetch data from the table: "services" using primary key columns */
  ServiceGenericByPk?: Maybe<ServiceGeneric>;
  /** fetch data from the table in a streaming manner: "services" */
  ServiceGeneric_stream: Array<ServiceGeneric>;
  /** fetch data from the table: "solutions" */
  Solution: Array<Solution>;
  /** fetch aggregated fields from the table: "solutions" */
  SolutionAggregate: Solution_Aggregate;
  /** fetch data from the table: "map_solution_application_component" */
  SolutionApplicationComponentMap: Array<SolutionApplicationComponentMap>;
  /** fetch aggregated fields from the table: "map_solution_application_component" */
  SolutionApplicationComponentMapAggregate: SolutionApplicationComponentMap_Aggregate;
  /** fetch data from the table: "map_solution_application_component" using primary key columns */
  SolutionApplicationComponentMapByPk?: Maybe<SolutionApplicationComponentMap>;
  /** fetch data from the table in a streaming manner: "map_solution_application_component" */
  SolutionApplicationComponentMap_stream: Array<SolutionApplicationComponentMap>;
  /** fetch data from the table: "map_solution_application_function" */
  SolutionApplicationFunctionMap: Array<SolutionApplicationFunctionMap>;
  /** fetch aggregated fields from the table: "map_solution_application_function" */
  SolutionApplicationFunctionMapAggregate: SolutionApplicationFunctionMap_Aggregate;
  /** fetch data from the table: "map_solution_application_function" using primary key columns */
  SolutionApplicationFunctionMapByPk?: Maybe<SolutionApplicationFunctionMap>;
  /** fetch data from the table in a streaming manner: "map_solution_application_function" */
  SolutionApplicationFunctionMap_stream: Array<SolutionApplicationFunctionMap>;
  /** fetch data from the table: "solutions" using primary key columns */
  SolutionByPk?: Maybe<Solution>;
  /** fetch data from the table: "map_solution_data_object" */
  SolutionDataObjectMap: Array<SolutionDataObjectMap>;
  /** fetch aggregated fields from the table: "map_solution_data_object" */
  SolutionDataObjectMapAggregate: SolutionDataObjectMap_Aggregate;
  /** fetch data from the table: "map_solution_data_object" using primary key columns */
  SolutionDataObjectMapByPk?: Maybe<SolutionDataObjectMap>;
  /** fetch data from the table in a streaming manner: "map_solution_data_object" */
  SolutionDataObjectMap_stream: Array<SolutionDataObjectMap>;
  /** fetch data from the table: "map_solution_flow" */
  SolutionFlowMap: Array<SolutionFlowMap>;
  /** fetch aggregated fields from the table: "map_solution_flow" */
  SolutionFlowMapAggregate: SolutionFlowMap_Aggregate;
  /** fetch data from the table: "map_solution_flow" using primary key columns */
  SolutionFlowMapByPk?: Maybe<SolutionFlowMap>;
  /** fetch data from the table in a streaming manner: "map_solution_flow" */
  SolutionFlowMap_stream: Array<SolutionFlowMap>;
  /** fetch data from the table: "map_solution_motivation_component" */
  SolutionMotivationComponentMap: Array<SolutionMotivationComponentMap>;
  /** fetch aggregated fields from the table: "map_solution_motivation_component" */
  SolutionMotivationComponentMapAggregate: SolutionMotivationComponentMap_Aggregate;
  /** fetch data from the table: "map_solution_motivation_component" using primary key columns */
  SolutionMotivationComponentMapByPk?: Maybe<SolutionMotivationComponentMap>;
  /** fetch data from the table in a streaming manner: "map_solution_motivation_component" */
  SolutionMotivationComponentMap_stream: Array<SolutionMotivationComponentMap>;
  /** fetch data from the table: "map_solution_motivation" */
  SolutionMotivationElementMap: Array<SolutionMotivationElementMap>;
  /** fetch aggregated fields from the table: "map_solution_motivation" */
  SolutionMotivationElementMapAggregate: SolutionMotivationElementMap_Aggregate;
  /** fetch data from the table: "map_solution_motivation" using primary key columns */
  SolutionMotivationElementMapByPk?: Maybe<SolutionMotivationElementMap>;
  /** fetch data from the table in a streaming manner: "map_solution_motivation" */
  SolutionMotivationElementMap_stream: Array<SolutionMotivationElementMap>;
  /** fetch data from the table: "map_solution_stakeholder" */
  SolutionStakeholderMap: Array<SolutionStakeholderMap>;
  /** fetch aggregated fields from the table: "map_solution_stakeholder" */
  SolutionStakeholderMapAggregate: SolutionStakeholderMap_Aggregate;
  /** fetch data from the table: "map_solution_stakeholder" using primary key columns */
  SolutionStakeholderMapByPk?: Maybe<SolutionStakeholderMap>;
  /** fetch data from the table in a streaming manner: "map_solution_stakeholder" */
  SolutionStakeholderMap_stream: Array<SolutionStakeholderMap>;
  /** fetch data from the table: "map_solution_technology_node" */
  SolutionTechnologyNodeMap: Array<SolutionTechnologyNodeMap>;
  /** fetch aggregated fields from the table: "map_solution_technology_node" */
  SolutionTechnologyNodeMapAggregate: SolutionTechnologyNodeMap_Aggregate;
  /** fetch data from the table: "map_solution_technology_node" using primary key columns */
  SolutionTechnologyNodeMapByPk?: Maybe<SolutionTechnologyNodeMap>;
  /** fetch data from the table in a streaming manner: "map_solution_technology_node" */
  SolutionTechnologyNodeMap_stream: Array<SolutionTechnologyNodeMap>;
  /** fetch data from the table in a streaming manner: "solutions" */
  Solution_stream: Array<Solution>;
  /** fetch data from the table: "stakeholders" */
  Stakeholder: Array<Stakeholder>;
  /** fetch aggregated fields from the table: "stakeholders" */
  StakeholderAggregate: Stakeholder_Aggregate;
  /** fetch data from the table: "stakeholders" using primary key columns */
  StakeholderByPk?: Maybe<Stakeholder>;
  /** fetch data from the table in a streaming manner: "stakeholders" */
  Stakeholder_stream: Array<Stakeholder>;
  /** fetch data from the table: "system_software" */
  SystemSoftware: Array<SystemSoftware>;
  /** fetch aggregated fields from the table: "system_software" */
  SystemSoftwareAggregate: SystemSoftware_Aggregate;
  /** fetch data from the table: "system_software" using primary key columns */
  SystemSoftwareByPk?: Maybe<SystemSoftware>;
  /** fetch data from the table in a streaming manner: "system_software" */
  SystemSoftware_stream: Array<SystemSoftware>;
  /** fetch data from the table: "technology_networks" */
  TechnologyNetwork: Array<TechnologyNetwork>;
  /** fetch aggregated fields from the table: "technology_networks" */
  TechnologyNetworkAggregate: TechnologyNetwork_Aggregate;
  /** fetch data from the table: "technology_networks" using primary key columns */
  TechnologyNetworkByPk?: Maybe<TechnologyNetwork>;
  /** fetch data from the table: "map_technology_network_hierarchy" */
  TechnologyNetworkHierarchyMap: Array<TechnologyNetworkHierarchyMap>;
  /** fetch aggregated fields from the table: "map_technology_network_hierarchy" */
  TechnologyNetworkHierarchyMapAggregate: TechnologyNetworkHierarchyMap_Aggregate;
  /** fetch data from the table: "map_technology_network_hierarchy" using primary key columns */
  TechnologyNetworkHierarchyMapByPk?: Maybe<TechnologyNetworkHierarchyMap>;
  /** fetch data from the table in a streaming manner: "map_technology_network_hierarchy" */
  TechnologyNetworkHierarchyMap_stream: Array<TechnologyNetworkHierarchyMap>;
  /** fetch data from the table in a streaming manner: "technology_networks" */
  TechnologyNetwork_stream: Array<TechnologyNetwork>;
  /** fetch data from the table: "technology_nodes" */
  TechnologyNode: Array<TechnologyNode>;
  /** fetch aggregated fields from the table: "technology_nodes" */
  TechnologyNodeAggregate: TechnologyNode_Aggregate;
  /** fetch data from the table: "technology_nodes" using primary key columns */
  TechnologyNodeByPk?: Maybe<TechnologyNode>;
  /** fetch data from the table: "map_technology_node_hierarchy" */
  TechnologyNodeHierarchyMap: Array<TechnologyNodeHierarchyMap>;
  /** fetch aggregated fields from the table: "map_technology_node_hierarchy" */
  TechnologyNodeHierarchyMapAggregate: TechnologyNodeHierarchyMap_Aggregate;
  /** fetch data from the table: "map_technology_node_hierarchy" using primary key columns */
  TechnologyNodeHierarchyMapByPk?: Maybe<TechnologyNodeHierarchyMap>;
  /** fetch data from the table in a streaming manner: "map_technology_node_hierarchy" */
  TechnologyNodeHierarchyMap_stream: Array<TechnologyNodeHierarchyMap>;
  /** fetch data from the table: "map_technology_node_system_software" */
  TechnologyNodeSystemSoftwareMap: Array<TechnologyNodeSystemSoftwareMap>;
  /** fetch aggregated fields from the table: "map_technology_node_system_software" */
  TechnologyNodeSystemSoftwareMapAggregate: TechnologyNodeSystemSoftwareMap_Aggregate;
  /** fetch data from the table: "map_technology_node_system_software" using primary key columns */
  TechnologyNodeSystemSoftwareMapByPk?: Maybe<TechnologyNodeSystemSoftwareMap>;
  /** fetch data from the table in a streaming manner: "map_technology_node_system_software" */
  TechnologyNodeSystemSoftwareMap_stream: Array<TechnologyNodeSystemSoftwareMap>;
  /** fetch data from the table in a streaming manner: "technology_nodes" */
  TechnologyNode_stream: Array<TechnologyNode>;
  /** fetch data from the table: "map_solution_constraint" */
  mapSolutionConstraint: Array<MapSolutionConstraint>;
  /** fetch aggregated fields from the table: "map_solution_constraint" */
  mapSolutionConstraint_aggregate: MapSolutionConstraint_Aggregate;
  /** fetch data from the table: "map_solution_constraint" using primary key columns */
  mapSolutionConstraint_by_pk?: Maybe<MapSolutionConstraint>;
  /** fetch data from the table in a streaming manner: "map_solution_constraint" */
  mapSolutionConstraint_stream: Array<MapSolutionConstraint>;
  /** fetch data from the table: "map_tenant_user_profiles" */
  mapTenantUserProfiles: Array<MapTenantUserProfiles>;
  /** fetch aggregated fields from the table: "map_tenant_user_profiles" */
  mapTenantUserProfiles_aggregate: MapTenantUserProfiles_Aggregate;
  /** fetch data from the table: "map_tenant_user_profiles" using primary key columns */
  mapTenantUserProfiles_by_pk?: Maybe<MapTenantUserProfiles>;
  /** fetch data from the table in a streaming manner: "map_tenant_user_profiles" */
  mapTenantUserProfiles_stream: Array<MapTenantUserProfiles>;
  /** fetch data from the table: "tenants" */
  tenants: Array<Tenants>;
  /** fetch aggregated fields from the table: "tenants" */
  tenants_aggregate: Tenants_Aggregate;
  /** fetch data from the table: "tenants" using primary key columns */
  tenants_by_pk?: Maybe<Tenants>;
  /** fetch data from the table in a streaming manner: "tenants" */
  tenants_stream: Array<Tenants>;
  /** fetch data from the table: "user_profiles" */
  userProfiles: Array<UserProfiles>;
  /** fetch aggregated fields from the table: "user_profiles" */
  userProfiles_aggregate: UserProfiles_Aggregate;
  /** fetch data from the table: "user_profiles" using primary key columns */
  userProfiles_by_pk?: Maybe<UserProfiles>;
  /** fetch data from the table in a streaming manner: "user_profiles" */
  userProfiles_stream: Array<UserProfiles>;
};


export type Subscription_RootApplicationComponentArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponent_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponent_Order_By>>;
  where?: InputMaybe<ApplicationComponent_Bool_Exp>;
};


export type Subscription_RootApplicationComponentAggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponent_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponent_Order_By>>;
  where?: InputMaybe<ApplicationComponent_Bool_Exp>;
};


export type Subscription_RootApplicationComponentBusinessActorRoleMapArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentBusinessActorRoleMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentBusinessActorRoleMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentBusinessActorRoleMap_Bool_Exp>;
};


export type Subscription_RootApplicationComponentBusinessActorRoleMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentBusinessActorRoleMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentBusinessActorRoleMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentBusinessActorRoleMap_Bool_Exp>;
};


export type Subscription_RootApplicationComponentBusinessActorRoleMapByPkArgs = {
  actorId: Scalars['uuid']['input'];
  componentId: Scalars['uuid']['input'];
  roleId: Scalars['uuid']['input'];
};


export type Subscription_RootApplicationComponentBusinessActorRoleMap_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ApplicationComponentBusinessActorRoleMap_Stream_Cursor_Input>>;
  where?: InputMaybe<ApplicationComponentBusinessActorRoleMap_Bool_Exp>;
};


export type Subscription_RootApplicationComponentByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootApplicationComponentDataObjectMapArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentDataObjectMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentDataObjectMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentDataObjectMap_Bool_Exp>;
};


export type Subscription_RootApplicationComponentDataObjectMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentDataObjectMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentDataObjectMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentDataObjectMap_Bool_Exp>;
};


export type Subscription_RootApplicationComponentDataObjectMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  dataObjectId: Scalars['uuid']['input'];
};


export type Subscription_RootApplicationComponentDataObjectMap_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ApplicationComponentDataObjectMap_Stream_Cursor_Input>>;
  where?: InputMaybe<ApplicationComponentDataObjectMap_Bool_Exp>;
};


export type Subscription_RootApplicationComponentDirectoryMapArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentDirectoryMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentDirectoryMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentDirectoryMap_Bool_Exp>;
};


export type Subscription_RootApplicationComponentDirectoryMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentDirectoryMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentDirectoryMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentDirectoryMap_Bool_Exp>;
};


export type Subscription_RootApplicationComponentDirectoryMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  directoryId: Scalars['uuid']['input'];
};


export type Subscription_RootApplicationComponentDirectoryMap_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ApplicationComponentDirectoryMap_Stream_Cursor_Input>>;
  where?: InputMaybe<ApplicationComponentDirectoryMap_Bool_Exp>;
};


export type Subscription_RootApplicationComponentEventMapArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentEventMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentEventMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentEventMap_Bool_Exp>;
};


export type Subscription_RootApplicationComponentEventMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentEventMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentEventMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentEventMap_Bool_Exp>;
};


export type Subscription_RootApplicationComponentEventMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  eventId: Scalars['uuid']['input'];
};


export type Subscription_RootApplicationComponentEventMap_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ApplicationComponentEventMap_Stream_Cursor_Input>>;
  where?: InputMaybe<ApplicationComponentEventMap_Bool_Exp>;
};


export type Subscription_RootApplicationComponentFunctionMapArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentFunctionMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentFunctionMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentFunctionMap_Bool_Exp>;
};


export type Subscription_RootApplicationComponentFunctionMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentFunctionMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentFunctionMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentFunctionMap_Bool_Exp>;
};


export type Subscription_RootApplicationComponentFunctionMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  functionId: Scalars['uuid']['input'];
};


export type Subscription_RootApplicationComponentFunctionMap_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ApplicationComponentFunctionMap_Stream_Cursor_Input>>;
  where?: InputMaybe<ApplicationComponentFunctionMap_Bool_Exp>;
};


export type Subscription_RootApplicationComponentHierarchyMapArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentHierarchyMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentHierarchyMap_Bool_Exp>;
};


export type Subscription_RootApplicationComponentHierarchyMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentHierarchyMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentHierarchyMap_Bool_Exp>;
};


export type Subscription_RootApplicationComponentHierarchyMapByPkArgs = {
  componentChildId: Scalars['uuid']['input'];
  componentParentId: Scalars['uuid']['input'];
};


export type Subscription_RootApplicationComponentHierarchyMap_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ApplicationComponentHierarchyMap_Stream_Cursor_Input>>;
  where?: InputMaybe<ApplicationComponentHierarchyMap_Bool_Exp>;
};


export type Subscription_RootApplicationComponentInterfaceMapArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentInterfaceMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentInterfaceMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentInterfaceMap_Bool_Exp>;
};


export type Subscription_RootApplicationComponentInterfaceMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentInterfaceMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentInterfaceMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentInterfaceMap_Bool_Exp>;
};


export type Subscription_RootApplicationComponentInterfaceMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  interfaceId: Scalars['uuid']['input'];
};


export type Subscription_RootApplicationComponentInterfaceMap_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ApplicationComponentInterfaceMap_Stream_Cursor_Input>>;
  where?: InputMaybe<ApplicationComponentInterfaceMap_Bool_Exp>;
};


export type Subscription_RootApplicationComponentProductMapArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentProductMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentProductMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentProductMap_Bool_Exp>;
};


export type Subscription_RootApplicationComponentProductMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentProductMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentProductMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentProductMap_Bool_Exp>;
};


export type Subscription_RootApplicationComponentProductMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  productId: Scalars['uuid']['input'];
};


export type Subscription_RootApplicationComponentProductMap_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ApplicationComponentProductMap_Stream_Cursor_Input>>;
  where?: InputMaybe<ApplicationComponentProductMap_Bool_Exp>;
};


export type Subscription_RootApplicationComponentStakeholderMapArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentStakeholderMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentStakeholderMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentStakeholderMap_Bool_Exp>;
};


export type Subscription_RootApplicationComponentStakeholderMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentStakeholderMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentStakeholderMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentStakeholderMap_Bool_Exp>;
};


export type Subscription_RootApplicationComponentStakeholderMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  stakeholderId: Scalars['uuid']['input'];
};


export type Subscription_RootApplicationComponentStakeholderMap_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ApplicationComponentStakeholderMap_Stream_Cursor_Input>>;
  where?: InputMaybe<ApplicationComponentStakeholderMap_Bool_Exp>;
};


export type Subscription_RootApplicationComponentSystemSoftwareMapArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentSystemSoftwareMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentSystemSoftwareMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentSystemSoftwareMap_Bool_Exp>;
};


export type Subscription_RootApplicationComponentSystemSoftwareMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentSystemSoftwareMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentSystemSoftwareMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentSystemSoftwareMap_Bool_Exp>;
};


export type Subscription_RootApplicationComponentSystemSoftwareMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  systemSoftwareId: Scalars['uuid']['input'];
};


export type Subscription_RootApplicationComponentSystemSoftwareMap_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ApplicationComponentSystemSoftwareMap_Stream_Cursor_Input>>;
  where?: InputMaybe<ApplicationComponentSystemSoftwareMap_Bool_Exp>;
};


export type Subscription_RootApplicationComponentTechnologyLogicalNetworkMapArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentTechnologyLogicalNetworkMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentTechnologyLogicalNetworkMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentTechnologyLogicalNetworkMap_Bool_Exp>;
};


export type Subscription_RootApplicationComponentTechnologyLogicalNetworkMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentTechnologyLogicalNetworkMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentTechnologyLogicalNetworkMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentTechnologyLogicalNetworkMap_Bool_Exp>;
};


export type Subscription_RootApplicationComponentTechnologyLogicalNetworkMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  logicalNetworkId: Scalars['uuid']['input'];
};


export type Subscription_RootApplicationComponentTechnologyLogicalNetworkMap_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ApplicationComponentTechnologyLogicalNetworkMap_Stream_Cursor_Input>>;
  where?: InputMaybe<ApplicationComponentTechnologyLogicalNetworkMap_Bool_Exp>;
};


export type Subscription_RootApplicationComponentTechnologyNodeMapArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentTechnologyNodeMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentTechnologyNodeMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentTechnologyNodeMap_Bool_Exp>;
};


export type Subscription_RootApplicationComponentTechnologyNodeMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationComponentTechnologyNodeMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationComponentTechnologyNodeMap_Order_By>>;
  where?: InputMaybe<ApplicationComponentTechnologyNodeMap_Bool_Exp>;
};


export type Subscription_RootApplicationComponentTechnologyNodeMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  nodeId: Scalars['uuid']['input'];
};


export type Subscription_RootApplicationComponentTechnologyNodeMap_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ApplicationComponentTechnologyNodeMap_Stream_Cursor_Input>>;
  where?: InputMaybe<ApplicationComponentTechnologyNodeMap_Bool_Exp>;
};


export type Subscription_RootApplicationComponent_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ApplicationComponent_Stream_Cursor_Input>>;
  where?: InputMaybe<ApplicationComponent_Bool_Exp>;
};


export type Subscription_RootApplicationFunctionDataObjectMapArgs = {
  distinct_on?: InputMaybe<Array<ApplicationFunctionDataObjectMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationFunctionDataObjectMap_Order_By>>;
  where?: InputMaybe<ApplicationFunctionDataObjectMap_Bool_Exp>;
};


export type Subscription_RootApplicationFunctionDataObjectMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationFunctionDataObjectMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationFunctionDataObjectMap_Order_By>>;
  where?: InputMaybe<ApplicationFunctionDataObjectMap_Bool_Exp>;
};


export type Subscription_RootApplicationFunctionDataObjectMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  dataObjectId: Scalars['uuid']['input'];
  functionId: Scalars['uuid']['input'];
};


export type Subscription_RootApplicationFunctionDataObjectMap_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ApplicationFunctionDataObjectMap_Stream_Cursor_Input>>;
  where?: InputMaybe<ApplicationFunctionDataObjectMap_Bool_Exp>;
};


export type Subscription_RootApplicationFunctionInterfaceMapArgs = {
  distinct_on?: InputMaybe<Array<ApplicationFunctionInterfaceMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationFunctionInterfaceMap_Order_By>>;
  where?: InputMaybe<ApplicationFunctionInterfaceMap_Bool_Exp>;
};


export type Subscription_RootApplicationFunctionInterfaceMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<ApplicationFunctionInterfaceMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ApplicationFunctionInterfaceMap_Order_By>>;
  where?: InputMaybe<ApplicationFunctionInterfaceMap_Bool_Exp>;
};


export type Subscription_RootApplicationFunctionInterfaceMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  functionId: Scalars['uuid']['input'];
  interfaceId: Scalars['uuid']['input'];
};


export type Subscription_RootApplicationFunctionInterfaceMap_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ApplicationFunctionInterfaceMap_Stream_Cursor_Input>>;
  where?: InputMaybe<ApplicationFunctionInterfaceMap_Bool_Exp>;
};


export type Subscription_RootBusinessActorArgs = {
  distinct_on?: InputMaybe<Array<BusinessActor_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessActor_Order_By>>;
  where?: InputMaybe<BusinessActor_Bool_Exp>;
};


export type Subscription_RootBusinessActorAggregateArgs = {
  distinct_on?: InputMaybe<Array<BusinessActor_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessActor_Order_By>>;
  where?: InputMaybe<BusinessActor_Bool_Exp>;
};


export type Subscription_RootBusinessActorByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootBusinessActorRoleMapArgs = {
  distinct_on?: InputMaybe<Array<BusinessActorRoleMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessActorRoleMap_Order_By>>;
  where?: InputMaybe<BusinessActorRoleMap_Bool_Exp>;
};


export type Subscription_RootBusinessActorRoleMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<BusinessActorRoleMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessActorRoleMap_Order_By>>;
  where?: InputMaybe<BusinessActorRoleMap_Bool_Exp>;
};


export type Subscription_RootBusinessActorRoleMapByPkArgs = {
  actorId: Scalars['uuid']['input'];
  roleId: Scalars['uuid']['input'];
};


export type Subscription_RootBusinessActorRoleMap_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<BusinessActorRoleMap_Stream_Cursor_Input>>;
  where?: InputMaybe<BusinessActorRoleMap_Bool_Exp>;
};


export type Subscription_RootBusinessActor_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<BusinessActor_Stream_Cursor_Input>>;
  where?: InputMaybe<BusinessActor_Bool_Exp>;
};


export type Subscription_RootBusinessProcessFunctionMapArgs = {
  distinct_on?: InputMaybe<Array<BusinessProcessFunctionMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessProcessFunctionMap_Order_By>>;
  where?: InputMaybe<BusinessProcessFunctionMap_Bool_Exp>;
};


export type Subscription_RootBusinessProcessFunctionMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<BusinessProcessFunctionMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessProcessFunctionMap_Order_By>>;
  where?: InputMaybe<BusinessProcessFunctionMap_Bool_Exp>;
};


export type Subscription_RootBusinessProcessFunctionMapByPkArgs = {
  functionId: Scalars['uuid']['input'];
  processId: Scalars['uuid']['input'];
};


export type Subscription_RootBusinessProcessFunctionMap_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<BusinessProcessFunctionMap_Stream_Cursor_Input>>;
  where?: InputMaybe<BusinessProcessFunctionMap_Bool_Exp>;
};


export type Subscription_RootBusinessProcessHierarchyMapArgs = {
  distinct_on?: InputMaybe<Array<BusinessProcessHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessProcessHierarchyMap_Order_By>>;
  where?: InputMaybe<BusinessProcessHierarchyMap_Bool_Exp>;
};


export type Subscription_RootBusinessProcessHierarchyMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<BusinessProcessHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessProcessHierarchyMap_Order_By>>;
  where?: InputMaybe<BusinessProcessHierarchyMap_Bool_Exp>;
};


export type Subscription_RootBusinessProcessHierarchyMapByPkArgs = {
  processChildId: Scalars['uuid']['input'];
  processParentId: Scalars['uuid']['input'];
};


export type Subscription_RootBusinessProcessHierarchyMap_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<BusinessProcessHierarchyMap_Stream_Cursor_Input>>;
  where?: InputMaybe<BusinessProcessHierarchyMap_Bool_Exp>;
};


export type Subscription_RootBusinessProcessMotivationItemMapArgs = {
  distinct_on?: InputMaybe<Array<BusinessProcessMotivationItemMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessProcessMotivationItemMap_Order_By>>;
  where?: InputMaybe<BusinessProcessMotivationItemMap_Bool_Exp>;
};


export type Subscription_RootBusinessProcessMotivationItemMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<BusinessProcessMotivationItemMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessProcessMotivationItemMap_Order_By>>;
  where?: InputMaybe<BusinessProcessMotivationItemMap_Bool_Exp>;
};


export type Subscription_RootBusinessProcessMotivationItemMapByPkArgs = {
  motivationId: Scalars['uuid']['input'];
  processId: Scalars['uuid']['input'];
};


export type Subscription_RootBusinessProcessMotivationItemMap_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<BusinessProcessMotivationItemMap_Stream_Cursor_Input>>;
  where?: InputMaybe<BusinessProcessMotivationItemMap_Bool_Exp>;
};


export type Subscription_RootBusinessProductArgs = {
  distinct_on?: InputMaybe<Array<BusinessProduct_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessProduct_Order_By>>;
  where?: InputMaybe<BusinessProduct_Bool_Exp>;
};


export type Subscription_RootBusinessProductAggregateArgs = {
  distinct_on?: InputMaybe<Array<BusinessProduct_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessProduct_Order_By>>;
  where?: InputMaybe<BusinessProduct_Bool_Exp>;
};


export type Subscription_RootBusinessProductByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootBusinessProduct_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<BusinessProduct_Stream_Cursor_Input>>;
  where?: InputMaybe<BusinessProduct_Bool_Exp>;
};


export type Subscription_RootBusinessRoleArgs = {
  distinct_on?: InputMaybe<Array<BusinessRole_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessRole_Order_By>>;
  where?: InputMaybe<BusinessRole_Bool_Exp>;
};


export type Subscription_RootBusinessRoleAggregateArgs = {
  distinct_on?: InputMaybe<Array<BusinessRole_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<BusinessRole_Order_By>>;
  where?: InputMaybe<BusinessRole_Bool_Exp>;
};


export type Subscription_RootBusinessRoleByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootBusinessRole_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<BusinessRole_Stream_Cursor_Input>>;
  where?: InputMaybe<BusinessRole_Bool_Exp>;
};


export type Subscription_RootCapabilityArgs = {
  distinct_on?: InputMaybe<Array<Capability_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Capability_Order_By>>;
  where?: InputMaybe<Capability_Bool_Exp>;
};


export type Subscription_RootCapabilityAggregateArgs = {
  distinct_on?: InputMaybe<Array<Capability_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Capability_Order_By>>;
  where?: InputMaybe<Capability_Bool_Exp>;
};


export type Subscription_RootCapabilityApplicationComponentAssessmentMapArgs = {
  distinct_on?: InputMaybe<Array<CapabilityApplicationComponentAssessmentMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CapabilityApplicationComponentAssessmentMap_Order_By>>;
  where?: InputMaybe<CapabilityApplicationComponentAssessmentMap_Bool_Exp>;
};


export type Subscription_RootCapabilityApplicationComponentAssessmentMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<CapabilityApplicationComponentAssessmentMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CapabilityApplicationComponentAssessmentMap_Order_By>>;
  where?: InputMaybe<CapabilityApplicationComponentAssessmentMap_Bool_Exp>;
};


export type Subscription_RootCapabilityApplicationComponentAssessmentMapByPkArgs = {
  assessmentId: Scalars['uuid']['input'];
  capabilityId: Scalars['uuid']['input'];
  componentId: Scalars['uuid']['input'];
};


export type Subscription_RootCapabilityApplicationComponentAssessmentMap_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<CapabilityApplicationComponentAssessmentMap_Stream_Cursor_Input>>;
  where?: InputMaybe<CapabilityApplicationComponentAssessmentMap_Bool_Exp>;
};


export type Subscription_RootCapabilityApplicationComponentMapArgs = {
  distinct_on?: InputMaybe<Array<CapabilityApplicationComponentMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CapabilityApplicationComponentMap_Order_By>>;
  where?: InputMaybe<CapabilityApplicationComponentMap_Bool_Exp>;
};


export type Subscription_RootCapabilityApplicationComponentMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<CapabilityApplicationComponentMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CapabilityApplicationComponentMap_Order_By>>;
  where?: InputMaybe<CapabilityApplicationComponentMap_Bool_Exp>;
};


export type Subscription_RootCapabilityApplicationComponentMapByPkArgs = {
  capabilityId: Scalars['uuid']['input'];
  componentId: Scalars['uuid']['input'];
};


export type Subscription_RootCapabilityApplicationComponentMap_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<CapabilityApplicationComponentMap_Stream_Cursor_Input>>;
  where?: InputMaybe<CapabilityApplicationComponentMap_Bool_Exp>;
};


export type Subscription_RootCapabilityBusinessProcessAssessmentMapArgs = {
  distinct_on?: InputMaybe<Array<CapabilityBusinessProcessAssessmentMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CapabilityBusinessProcessAssessmentMap_Order_By>>;
  where?: InputMaybe<CapabilityBusinessProcessAssessmentMap_Bool_Exp>;
};


export type Subscription_RootCapabilityBusinessProcessAssessmentMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<CapabilityBusinessProcessAssessmentMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CapabilityBusinessProcessAssessmentMap_Order_By>>;
  where?: InputMaybe<CapabilityBusinessProcessAssessmentMap_Bool_Exp>;
};


export type Subscription_RootCapabilityBusinessProcessAssessmentMapByPkArgs = {
  assessmentId: Scalars['uuid']['input'];
  capabilityId: Scalars['uuid']['input'];
  processId: Scalars['uuid']['input'];
};


export type Subscription_RootCapabilityBusinessProcessAssessmentMap_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<CapabilityBusinessProcessAssessmentMap_Stream_Cursor_Input>>;
  where?: InputMaybe<CapabilityBusinessProcessAssessmentMap_Bool_Exp>;
};


export type Subscription_RootCapabilityBusinessProcessMapArgs = {
  distinct_on?: InputMaybe<Array<CapabilityBusinessProcessMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CapabilityBusinessProcessMap_Order_By>>;
  where?: InputMaybe<CapabilityBusinessProcessMap_Bool_Exp>;
};


export type Subscription_RootCapabilityBusinessProcessMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<CapabilityBusinessProcessMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CapabilityBusinessProcessMap_Order_By>>;
  where?: InputMaybe<CapabilityBusinessProcessMap_Bool_Exp>;
};


export type Subscription_RootCapabilityBusinessProcessMapByPkArgs = {
  capabilityId: Scalars['uuid']['input'];
  processId: Scalars['uuid']['input'];
};


export type Subscription_RootCapabilityBusinessProcessMap_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<CapabilityBusinessProcessMap_Stream_Cursor_Input>>;
  where?: InputMaybe<CapabilityBusinessProcessMap_Bool_Exp>;
};


export type Subscription_RootCapabilityByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootCapabilityHierarchyMapArgs = {
  distinct_on?: InputMaybe<Array<CapabilityHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CapabilityHierarchyMap_Order_By>>;
  where?: InputMaybe<CapabilityHierarchyMap_Bool_Exp>;
};


export type Subscription_RootCapabilityHierarchyMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<CapabilityHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<CapabilityHierarchyMap_Order_By>>;
  where?: InputMaybe<CapabilityHierarchyMap_Bool_Exp>;
};


export type Subscription_RootCapabilityHierarchyMapByPkArgs = {
  childId: Scalars['uuid']['input'];
  parentId: Scalars['uuid']['input'];
};


export type Subscription_RootCapabilityHierarchyMap_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<CapabilityHierarchyMap_Stream_Cursor_Input>>;
  where?: InputMaybe<CapabilityHierarchyMap_Bool_Exp>;
};


export type Subscription_RootCapability_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Capability_Stream_Cursor_Input>>;
  where?: InputMaybe<Capability_Bool_Exp>;
};


export type Subscription_RootDataObjectArgs = {
  distinct_on?: InputMaybe<Array<DataObject_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<DataObject_Order_By>>;
  where?: InputMaybe<DataObject_Bool_Exp>;
};


export type Subscription_RootDataObjectAggregateArgs = {
  distinct_on?: InputMaybe<Array<DataObject_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<DataObject_Order_By>>;
  where?: InputMaybe<DataObject_Bool_Exp>;
};


export type Subscription_RootDataObjectByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootDataObject_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<DataObject_Stream_Cursor_Input>>;
  where?: InputMaybe<DataObject_Bool_Exp>;
};


export type Subscription_RootDirectoryItemsMapArgs = {
  distinct_on?: InputMaybe<Array<DirectoryItemsMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<DirectoryItemsMap_Order_By>>;
  where?: InputMaybe<DirectoryItemsMap_Bool_Exp>;
};


export type Subscription_RootDirectoryItemsMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<DirectoryItemsMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<DirectoryItemsMap_Order_By>>;
  where?: InputMaybe<DirectoryItemsMap_Bool_Exp>;
};


export type Subscription_RootDirectoryItemsMapByPkArgs = {
  sourceId: Scalars['uuid']['input'];
  targetId: Scalars['uuid']['input'];
};


export type Subscription_RootDirectoryItemsMap_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<DirectoryItemsMap_Stream_Cursor_Input>>;
  where?: InputMaybe<DirectoryItemsMap_Bool_Exp>;
};


export type Subscription_RootDirectoryObjectArgs = {
  distinct_on?: InputMaybe<Array<DirectoryObject_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<DirectoryObject_Order_By>>;
  where?: InputMaybe<DirectoryObject_Bool_Exp>;
};


export type Subscription_RootDirectoryObjectAggregateArgs = {
  distinct_on?: InputMaybe<Array<DirectoryObject_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<DirectoryObject_Order_By>>;
  where?: InputMaybe<DirectoryObject_Bool_Exp>;
};


export type Subscription_RootDirectoryObjectByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootDirectoryObject_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<DirectoryObject_Stream_Cursor_Input>>;
  where?: InputMaybe<DirectoryObject_Bool_Exp>;
};


export type Subscription_RootEmployeeArgs = {
  distinct_on?: InputMaybe<Array<Employee_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Employee_Order_By>>;
  where?: InputMaybe<Employee_Bool_Exp>;
};


export type Subscription_RootEmployeeAggregateArgs = {
  distinct_on?: InputMaybe<Array<Employee_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Employee_Order_By>>;
  where?: InputMaybe<Employee_Bool_Exp>;
};


export type Subscription_RootEmployeeByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootEmployee_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Employee_Stream_Cursor_Input>>;
  where?: InputMaybe<Employee_Bool_Exp>;
};


export type Subscription_RootEventGenericArgs = {
  distinct_on?: InputMaybe<Array<EventGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<EventGeneric_Order_By>>;
  where?: InputMaybe<EventGeneric_Bool_Exp>;
};


export type Subscription_RootEventGenericAggregateArgs = {
  distinct_on?: InputMaybe<Array<EventGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<EventGeneric_Order_By>>;
  where?: InputMaybe<EventGeneric_Bool_Exp>;
};


export type Subscription_RootEventGenericByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootEventGeneric_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<EventGeneric_Stream_Cursor_Input>>;
  where?: InputMaybe<EventGeneric_Bool_Exp>;
};


export type Subscription_RootFlowGenericArgs = {
  distinct_on?: InputMaybe<Array<FlowGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FlowGeneric_Order_By>>;
  where?: InputMaybe<FlowGeneric_Bool_Exp>;
};


export type Subscription_RootFlowGenericAggregateArgs = {
  distinct_on?: InputMaybe<Array<FlowGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FlowGeneric_Order_By>>;
  where?: InputMaybe<FlowGeneric_Bool_Exp>;
};


export type Subscription_RootFlowGenericByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootFlowGeneric_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<FlowGeneric_Stream_Cursor_Input>>;
  where?: InputMaybe<FlowGeneric_Bool_Exp>;
};


export type Subscription_RootFunctionGenericArgs = {
  distinct_on?: InputMaybe<Array<FunctionGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FunctionGeneric_Order_By>>;
  where?: InputMaybe<FunctionGeneric_Bool_Exp>;
};


export type Subscription_RootFunctionGenericAggregateArgs = {
  distinct_on?: InputMaybe<Array<FunctionGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<FunctionGeneric_Order_By>>;
  where?: InputMaybe<FunctionGeneric_Bool_Exp>;
};


export type Subscription_RootFunctionGenericByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootFunctionGeneric_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<FunctionGeneric_Stream_Cursor_Input>>;
  where?: InputMaybe<FunctionGeneric_Bool_Exp>;
};


export type Subscription_RootInterfaceGenericArgs = {
  distinct_on?: InputMaybe<Array<InterfaceGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<InterfaceGeneric_Order_By>>;
  where?: InputMaybe<InterfaceGeneric_Bool_Exp>;
};


export type Subscription_RootInterfaceGenericAggregateArgs = {
  distinct_on?: InputMaybe<Array<InterfaceGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<InterfaceGeneric_Order_By>>;
  where?: InputMaybe<InterfaceGeneric_Bool_Exp>;
};


export type Subscription_RootInterfaceGenericByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootInterfaceGeneric_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<InterfaceGeneric_Stream_Cursor_Input>>;
  where?: InputMaybe<InterfaceGeneric_Bool_Exp>;
};


export type Subscription_RootMotivationElementGenericArgs = {
  distinct_on?: InputMaybe<Array<MotivationElementGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MotivationElementGeneric_Order_By>>;
  where?: InputMaybe<MotivationElementGeneric_Bool_Exp>;
};


export type Subscription_RootMotivationElementGenericAggregateArgs = {
  distinct_on?: InputMaybe<Array<MotivationElementGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MotivationElementGeneric_Order_By>>;
  where?: InputMaybe<MotivationElementGeneric_Bool_Exp>;
};


export type Subscription_RootMotivationElementGenericByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootMotivationElementGeneric_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<MotivationElementGeneric_Stream_Cursor_Input>>;
  where?: InputMaybe<MotivationElementGeneric_Bool_Exp>;
};


export type Subscription_RootMotivationItemHierarchyMapArgs = {
  distinct_on?: InputMaybe<Array<MotivationItemHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MotivationItemHierarchyMap_Order_By>>;
  where?: InputMaybe<MotivationItemHierarchyMap_Bool_Exp>;
};


export type Subscription_RootMotivationItemHierarchyMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<MotivationItemHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MotivationItemHierarchyMap_Order_By>>;
  where?: InputMaybe<MotivationItemHierarchyMap_Bool_Exp>;
};


export type Subscription_RootMotivationItemHierarchyMapByPkArgs = {
  childId: Scalars['uuid']['input'];
  parentId: Scalars['uuid']['input'];
};


export type Subscription_RootMotivationItemHierarchyMap_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<MotivationItemHierarchyMap_Stream_Cursor_Input>>;
  where?: InputMaybe<MotivationItemHierarchyMap_Bool_Exp>;
};


export type Subscription_RootPhysicalLocationArgs = {
  distinct_on?: InputMaybe<Array<PhysicalLocation_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PhysicalLocation_Order_By>>;
  where?: InputMaybe<PhysicalLocation_Bool_Exp>;
};


export type Subscription_RootPhysicalLocationAggregateArgs = {
  distinct_on?: InputMaybe<Array<PhysicalLocation_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<PhysicalLocation_Order_By>>;
  where?: InputMaybe<PhysicalLocation_Bool_Exp>;
};


export type Subscription_RootPhysicalLocationByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootPhysicalLocation_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<PhysicalLocation_Stream_Cursor_Input>>;
  where?: InputMaybe<PhysicalLocation_Bool_Exp>;
};


export type Subscription_RootPlateauArgs = {
  distinct_on?: InputMaybe<Array<Plateau_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Plateau_Order_By>>;
  where?: InputMaybe<Plateau_Bool_Exp>;
};


export type Subscription_RootPlateauAggregateArgs = {
  distinct_on?: InputMaybe<Array<Plateau_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Plateau_Order_By>>;
  where?: InputMaybe<Plateau_Bool_Exp>;
};


export type Subscription_RootPlateauByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootPlateau_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Plateau_Stream_Cursor_Input>>;
  where?: InputMaybe<Plateau_Bool_Exp>;
};


export type Subscription_RootProcessGenericArgs = {
  distinct_on?: InputMaybe<Array<ProcessGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ProcessGeneric_Order_By>>;
  where?: InputMaybe<ProcessGeneric_Bool_Exp>;
};


export type Subscription_RootProcessGenericAggregateArgs = {
  distinct_on?: InputMaybe<Array<ProcessGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ProcessGeneric_Order_By>>;
  where?: InputMaybe<ProcessGeneric_Bool_Exp>;
};


export type Subscription_RootProcessGenericByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootProcessGeneric_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ProcessGeneric_Stream_Cursor_Input>>;
  where?: InputMaybe<ProcessGeneric_Bool_Exp>;
};


export type Subscription_RootServiceGenericArgs = {
  distinct_on?: InputMaybe<Array<ServiceGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ServiceGeneric_Order_By>>;
  where?: InputMaybe<ServiceGeneric_Bool_Exp>;
};


export type Subscription_RootServiceGenericAggregateArgs = {
  distinct_on?: InputMaybe<Array<ServiceGeneric_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<ServiceGeneric_Order_By>>;
  where?: InputMaybe<ServiceGeneric_Bool_Exp>;
};


export type Subscription_RootServiceGenericByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootServiceGeneric_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<ServiceGeneric_Stream_Cursor_Input>>;
  where?: InputMaybe<ServiceGeneric_Bool_Exp>;
};


export type Subscription_RootSolutionArgs = {
  distinct_on?: InputMaybe<Array<Solution_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Solution_Order_By>>;
  where?: InputMaybe<Solution_Bool_Exp>;
};


export type Subscription_RootSolutionAggregateArgs = {
  distinct_on?: InputMaybe<Array<Solution_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Solution_Order_By>>;
  where?: InputMaybe<Solution_Bool_Exp>;
};


export type Subscription_RootSolutionApplicationComponentMapArgs = {
  distinct_on?: InputMaybe<Array<SolutionApplicationComponentMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionApplicationComponentMap_Order_By>>;
  where?: InputMaybe<SolutionApplicationComponentMap_Bool_Exp>;
};


export type Subscription_RootSolutionApplicationComponentMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<SolutionApplicationComponentMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionApplicationComponentMap_Order_By>>;
  where?: InputMaybe<SolutionApplicationComponentMap_Bool_Exp>;
};


export type Subscription_RootSolutionApplicationComponentMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  solutionId: Scalars['uuid']['input'];
};


export type Subscription_RootSolutionApplicationComponentMap_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<SolutionApplicationComponentMap_Stream_Cursor_Input>>;
  where?: InputMaybe<SolutionApplicationComponentMap_Bool_Exp>;
};


export type Subscription_RootSolutionApplicationFunctionMapArgs = {
  distinct_on?: InputMaybe<Array<SolutionApplicationFunctionMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionApplicationFunctionMap_Order_By>>;
  where?: InputMaybe<SolutionApplicationFunctionMap_Bool_Exp>;
};


export type Subscription_RootSolutionApplicationFunctionMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<SolutionApplicationFunctionMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionApplicationFunctionMap_Order_By>>;
  where?: InputMaybe<SolutionApplicationFunctionMap_Bool_Exp>;
};


export type Subscription_RootSolutionApplicationFunctionMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  functionId: Scalars['uuid']['input'];
  solutionId: Scalars['uuid']['input'];
};


export type Subscription_RootSolutionApplicationFunctionMap_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<SolutionApplicationFunctionMap_Stream_Cursor_Input>>;
  where?: InputMaybe<SolutionApplicationFunctionMap_Bool_Exp>;
};


export type Subscription_RootSolutionByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootSolutionDataObjectMapArgs = {
  distinct_on?: InputMaybe<Array<SolutionDataObjectMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionDataObjectMap_Order_By>>;
  where?: InputMaybe<SolutionDataObjectMap_Bool_Exp>;
};


export type Subscription_RootSolutionDataObjectMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<SolutionDataObjectMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionDataObjectMap_Order_By>>;
  where?: InputMaybe<SolutionDataObjectMap_Bool_Exp>;
};


export type Subscription_RootSolutionDataObjectMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  dataObjectId: Scalars['uuid']['input'];
  solutionId: Scalars['uuid']['input'];
};


export type Subscription_RootSolutionDataObjectMap_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<SolutionDataObjectMap_Stream_Cursor_Input>>;
  where?: InputMaybe<SolutionDataObjectMap_Bool_Exp>;
};


export type Subscription_RootSolutionFlowMapArgs = {
  distinct_on?: InputMaybe<Array<SolutionFlowMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionFlowMap_Order_By>>;
  where?: InputMaybe<SolutionFlowMap_Bool_Exp>;
};


export type Subscription_RootSolutionFlowMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<SolutionFlowMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionFlowMap_Order_By>>;
  where?: InputMaybe<SolutionFlowMap_Bool_Exp>;
};


export type Subscription_RootSolutionFlowMapByPkArgs = {
  flowId: Scalars['uuid']['input'];
  solutionId: Scalars['uuid']['input'];
};


export type Subscription_RootSolutionFlowMap_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<SolutionFlowMap_Stream_Cursor_Input>>;
  where?: InputMaybe<SolutionFlowMap_Bool_Exp>;
};


export type Subscription_RootSolutionMotivationComponentMapArgs = {
  distinct_on?: InputMaybe<Array<SolutionMotivationComponentMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionMotivationComponentMap_Order_By>>;
  where?: InputMaybe<SolutionMotivationComponentMap_Bool_Exp>;
};


export type Subscription_RootSolutionMotivationComponentMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<SolutionMotivationComponentMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionMotivationComponentMap_Order_By>>;
  where?: InputMaybe<SolutionMotivationComponentMap_Bool_Exp>;
};


export type Subscription_RootSolutionMotivationComponentMapByPkArgs = {
  componentId: Scalars['uuid']['input'];
  motivationId: Scalars['uuid']['input'];
  solutionId: Scalars['uuid']['input'];
};


export type Subscription_RootSolutionMotivationComponentMap_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<SolutionMotivationComponentMap_Stream_Cursor_Input>>;
  where?: InputMaybe<SolutionMotivationComponentMap_Bool_Exp>;
};


export type Subscription_RootSolutionMotivationElementMapArgs = {
  distinct_on?: InputMaybe<Array<SolutionMotivationElementMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionMotivationElementMap_Order_By>>;
  where?: InputMaybe<SolutionMotivationElementMap_Bool_Exp>;
};


export type Subscription_RootSolutionMotivationElementMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<SolutionMotivationElementMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionMotivationElementMap_Order_By>>;
  where?: InputMaybe<SolutionMotivationElementMap_Bool_Exp>;
};


export type Subscription_RootSolutionMotivationElementMapByPkArgs = {
  motivationId: Scalars['uuid']['input'];
  solutionId: Scalars['uuid']['input'];
};


export type Subscription_RootSolutionMotivationElementMap_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<SolutionMotivationElementMap_Stream_Cursor_Input>>;
  where?: InputMaybe<SolutionMotivationElementMap_Bool_Exp>;
};


export type Subscription_RootSolutionStakeholderMapArgs = {
  distinct_on?: InputMaybe<Array<SolutionStakeholderMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionStakeholderMap_Order_By>>;
  where?: InputMaybe<SolutionStakeholderMap_Bool_Exp>;
};


export type Subscription_RootSolutionStakeholderMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<SolutionStakeholderMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionStakeholderMap_Order_By>>;
  where?: InputMaybe<SolutionStakeholderMap_Bool_Exp>;
};


export type Subscription_RootSolutionStakeholderMapByPkArgs = {
  solutionId: Scalars['uuid']['input'];
  stakeholderId: Scalars['uuid']['input'];
};


export type Subscription_RootSolutionStakeholderMap_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<SolutionStakeholderMap_Stream_Cursor_Input>>;
  where?: InputMaybe<SolutionStakeholderMap_Bool_Exp>;
};


export type Subscription_RootSolutionTechnologyNodeMapArgs = {
  distinct_on?: InputMaybe<Array<SolutionTechnologyNodeMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionTechnologyNodeMap_Order_By>>;
  where?: InputMaybe<SolutionTechnologyNodeMap_Bool_Exp>;
};


export type Subscription_RootSolutionTechnologyNodeMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<SolutionTechnologyNodeMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SolutionTechnologyNodeMap_Order_By>>;
  where?: InputMaybe<SolutionTechnologyNodeMap_Bool_Exp>;
};


export type Subscription_RootSolutionTechnologyNodeMapByPkArgs = {
  nodeId: Scalars['uuid']['input'];
  solutionId: Scalars['uuid']['input'];
};


export type Subscription_RootSolutionTechnologyNodeMap_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<SolutionTechnologyNodeMap_Stream_Cursor_Input>>;
  where?: InputMaybe<SolutionTechnologyNodeMap_Bool_Exp>;
};


export type Subscription_RootSolution_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Solution_Stream_Cursor_Input>>;
  where?: InputMaybe<Solution_Bool_Exp>;
};


export type Subscription_RootStakeholderArgs = {
  distinct_on?: InputMaybe<Array<Stakeholder_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Stakeholder_Order_By>>;
  where?: InputMaybe<Stakeholder_Bool_Exp>;
};


export type Subscription_RootStakeholderAggregateArgs = {
  distinct_on?: InputMaybe<Array<Stakeholder_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Stakeholder_Order_By>>;
  where?: InputMaybe<Stakeholder_Bool_Exp>;
};


export type Subscription_RootStakeholderByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootStakeholder_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Stakeholder_Stream_Cursor_Input>>;
  where?: InputMaybe<Stakeholder_Bool_Exp>;
};


export type Subscription_RootSystemSoftwareArgs = {
  distinct_on?: InputMaybe<Array<SystemSoftware_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SystemSoftware_Order_By>>;
  where?: InputMaybe<SystemSoftware_Bool_Exp>;
};


export type Subscription_RootSystemSoftwareAggregateArgs = {
  distinct_on?: InputMaybe<Array<SystemSoftware_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<SystemSoftware_Order_By>>;
  where?: InputMaybe<SystemSoftware_Bool_Exp>;
};


export type Subscription_RootSystemSoftwareByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootSystemSoftware_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<SystemSoftware_Stream_Cursor_Input>>;
  where?: InputMaybe<SystemSoftware_Bool_Exp>;
};


export type Subscription_RootTechnologyNetworkArgs = {
  distinct_on?: InputMaybe<Array<TechnologyNetwork_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TechnologyNetwork_Order_By>>;
  where?: InputMaybe<TechnologyNetwork_Bool_Exp>;
};


export type Subscription_RootTechnologyNetworkAggregateArgs = {
  distinct_on?: InputMaybe<Array<TechnologyNetwork_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TechnologyNetwork_Order_By>>;
  where?: InputMaybe<TechnologyNetwork_Bool_Exp>;
};


export type Subscription_RootTechnologyNetworkByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootTechnologyNetworkHierarchyMapArgs = {
  distinct_on?: InputMaybe<Array<TechnologyNetworkHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TechnologyNetworkHierarchyMap_Order_By>>;
  where?: InputMaybe<TechnologyNetworkHierarchyMap_Bool_Exp>;
};


export type Subscription_RootTechnologyNetworkHierarchyMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<TechnologyNetworkHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TechnologyNetworkHierarchyMap_Order_By>>;
  where?: InputMaybe<TechnologyNetworkHierarchyMap_Bool_Exp>;
};


export type Subscription_RootTechnologyNetworkHierarchyMapByPkArgs = {
  networkChildId: Scalars['uuid']['input'];
  networkParentId: Scalars['uuid']['input'];
};


export type Subscription_RootTechnologyNetworkHierarchyMap_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<TechnologyNetworkHierarchyMap_Stream_Cursor_Input>>;
  where?: InputMaybe<TechnologyNetworkHierarchyMap_Bool_Exp>;
};


export type Subscription_RootTechnologyNetwork_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<TechnologyNetwork_Stream_Cursor_Input>>;
  where?: InputMaybe<TechnologyNetwork_Bool_Exp>;
};


export type Subscription_RootTechnologyNodeArgs = {
  distinct_on?: InputMaybe<Array<TechnologyNode_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TechnologyNode_Order_By>>;
  where?: InputMaybe<TechnologyNode_Bool_Exp>;
};


export type Subscription_RootTechnologyNodeAggregateArgs = {
  distinct_on?: InputMaybe<Array<TechnologyNode_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TechnologyNode_Order_By>>;
  where?: InputMaybe<TechnologyNode_Bool_Exp>;
};


export type Subscription_RootTechnologyNodeByPkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootTechnologyNodeHierarchyMapArgs = {
  distinct_on?: InputMaybe<Array<TechnologyNodeHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TechnologyNodeHierarchyMap_Order_By>>;
  where?: InputMaybe<TechnologyNodeHierarchyMap_Bool_Exp>;
};


export type Subscription_RootTechnologyNodeHierarchyMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<TechnologyNodeHierarchyMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TechnologyNodeHierarchyMap_Order_By>>;
  where?: InputMaybe<TechnologyNodeHierarchyMap_Bool_Exp>;
};


export type Subscription_RootTechnologyNodeHierarchyMapByPkArgs = {
  nodeChildId: Scalars['uuid']['input'];
  nodeParentId: Scalars['uuid']['input'];
};


export type Subscription_RootTechnologyNodeHierarchyMap_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<TechnologyNodeHierarchyMap_Stream_Cursor_Input>>;
  where?: InputMaybe<TechnologyNodeHierarchyMap_Bool_Exp>;
};


export type Subscription_RootTechnologyNodeSystemSoftwareMapArgs = {
  distinct_on?: InputMaybe<Array<TechnologyNodeSystemSoftwareMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TechnologyNodeSystemSoftwareMap_Order_By>>;
  where?: InputMaybe<TechnologyNodeSystemSoftwareMap_Bool_Exp>;
};


export type Subscription_RootTechnologyNodeSystemSoftwareMapAggregateArgs = {
  distinct_on?: InputMaybe<Array<TechnologyNodeSystemSoftwareMap_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<TechnologyNodeSystemSoftwareMap_Order_By>>;
  where?: InputMaybe<TechnologyNodeSystemSoftwareMap_Bool_Exp>;
};


export type Subscription_RootTechnologyNodeSystemSoftwareMapByPkArgs = {
  nodeId: Scalars['uuid']['input'];
  systemSoftwareId: Scalars['uuid']['input'];
};


export type Subscription_RootTechnologyNodeSystemSoftwareMap_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<TechnologyNodeSystemSoftwareMap_Stream_Cursor_Input>>;
  where?: InputMaybe<TechnologyNodeSystemSoftwareMap_Bool_Exp>;
};


export type Subscription_RootTechnologyNode_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<TechnologyNode_Stream_Cursor_Input>>;
  where?: InputMaybe<TechnologyNode_Bool_Exp>;
};


export type Subscription_RootMapSolutionConstraintArgs = {
  distinct_on?: InputMaybe<Array<MapSolutionConstraint_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MapSolutionConstraint_Order_By>>;
  where?: InputMaybe<MapSolutionConstraint_Bool_Exp>;
};


export type Subscription_RootMapSolutionConstraint_AggregateArgs = {
  distinct_on?: InputMaybe<Array<MapSolutionConstraint_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MapSolutionConstraint_Order_By>>;
  where?: InputMaybe<MapSolutionConstraint_Bool_Exp>;
};


export type Subscription_RootMapSolutionConstraint_By_PkArgs = {
  constraintId: Scalars['uuid']['input'];
  solutionId: Scalars['uuid']['input'];
};


export type Subscription_RootMapSolutionConstraint_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<MapSolutionConstraint_Stream_Cursor_Input>>;
  where?: InputMaybe<MapSolutionConstraint_Bool_Exp>;
};


export type Subscription_RootMapTenantUserProfilesArgs = {
  distinct_on?: InputMaybe<Array<MapTenantUserProfiles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MapTenantUserProfiles_Order_By>>;
  where?: InputMaybe<MapTenantUserProfiles_Bool_Exp>;
};


export type Subscription_RootMapTenantUserProfiles_AggregateArgs = {
  distinct_on?: InputMaybe<Array<MapTenantUserProfiles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<MapTenantUserProfiles_Order_By>>;
  where?: InputMaybe<MapTenantUserProfiles_Bool_Exp>;
};


export type Subscription_RootMapTenantUserProfiles_By_PkArgs = {
  userId: Scalars['uuid']['input'];
};


export type Subscription_RootMapTenantUserProfiles_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<MapTenantUserProfiles_Stream_Cursor_Input>>;
  where?: InputMaybe<MapTenantUserProfiles_Bool_Exp>;
};


export type Subscription_RootTenantsArgs = {
  distinct_on?: InputMaybe<Array<Tenants_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tenants_Order_By>>;
  where?: InputMaybe<Tenants_Bool_Exp>;
};


export type Subscription_RootTenants_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Tenants_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<Tenants_Order_By>>;
  where?: InputMaybe<Tenants_Bool_Exp>;
};


export type Subscription_RootTenants_By_PkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootTenants_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<Tenants_Stream_Cursor_Input>>;
  where?: InputMaybe<Tenants_Bool_Exp>;
};


export type Subscription_RootUserProfilesArgs = {
  distinct_on?: InputMaybe<Array<UserProfiles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UserProfiles_Order_By>>;
  where?: InputMaybe<UserProfiles_Bool_Exp>;
};


export type Subscription_RootUserProfiles_AggregateArgs = {
  distinct_on?: InputMaybe<Array<UserProfiles_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']['input']>;
  offset?: InputMaybe<Scalars['Int']['input']>;
  order_by?: InputMaybe<Array<UserProfiles_Order_By>>;
  where?: InputMaybe<UserProfiles_Bool_Exp>;
};


export type Subscription_RootUserProfiles_By_PkArgs = {
  id: Scalars['uuid']['input'];
};


export type Subscription_RootUserProfiles_StreamArgs = {
  batch_size: Scalars['Int']['input'];
  cursor: Array<InputMaybe<UserProfiles_Stream_Cursor_Input>>;
  where?: InputMaybe<UserProfiles_Bool_Exp>;
};

/** Boolean expression to compare columns of type "system_architecture_kind_enum". All fields are combined with logical 'AND'. */
export type System_Architecture_Kind_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['system_architecture_kind_enum']['input']>;
  _gt?: InputMaybe<Scalars['system_architecture_kind_enum']['input']>;
  _gte?: InputMaybe<Scalars['system_architecture_kind_enum']['input']>;
  _in?: InputMaybe<Array<Scalars['system_architecture_kind_enum']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['system_architecture_kind_enum']['input']>;
  _lte?: InputMaybe<Scalars['system_architecture_kind_enum']['input']>;
  _neq?: InputMaybe<Scalars['system_architecture_kind_enum']['input']>;
  _nin?: InputMaybe<Array<Scalars['system_architecture_kind_enum']['input']>>;
};

/** Boolean expression to compare columns of type "system_software_kind_enum". All fields are combined with logical 'AND'. */
export type System_Software_Kind_Enum_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['system_software_kind_enum']['input']>;
  _gt?: InputMaybe<Scalars['system_software_kind_enum']['input']>;
  _gte?: InputMaybe<Scalars['system_software_kind_enum']['input']>;
  _in?: InputMaybe<Array<Scalars['system_software_kind_enum']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['system_software_kind_enum']['input']>;
  _lte?: InputMaybe<Scalars['system_software_kind_enum']['input']>;
  _neq?: InputMaybe<Scalars['system_software_kind_enum']['input']>;
  _nin?: InputMaybe<Array<Scalars['system_software_kind_enum']['input']>>;
};

/** columns and relationships of "tenants" */
export type Tenants = {
  __typename?: 'tenants';
  code: Scalars['String']['output'];
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id: Scalars['uuid']['output'];
  name: Scalars['String']['output'];
  /** An object relationship */
  owner: UserProfiles;
  ownerId: Scalars['uuid']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "tenants" */
export type Tenants_Aggregate = {
  __typename?: 'tenants_aggregate';
  aggregate?: Maybe<Tenants_Aggregate_Fields>;
  nodes: Array<Tenants>;
};

/** aggregate fields of "tenants" */
export type Tenants_Aggregate_Fields = {
  __typename?: 'tenants_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<Tenants_Max_Fields>;
  min?: Maybe<Tenants_Min_Fields>;
};


/** aggregate fields of "tenants" */
export type Tenants_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Tenants_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "tenants". All fields are combined with a logical 'AND'. */
export type Tenants_Bool_Exp = {
  _and?: InputMaybe<Array<Tenants_Bool_Exp>>;
  _not?: InputMaybe<Tenants_Bool_Exp>;
  _or?: InputMaybe<Array<Tenants_Bool_Exp>>;
  code?: InputMaybe<String_Comparison_Exp>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  owner?: InputMaybe<UserProfiles_Bool_Exp>;
  ownerId?: InputMaybe<Uuid_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "tenants" */
export enum Tenants_Constraint {
  /** unique or primary key constraint on columns "code" */
  TenantsCodeUnique = 'tenants_code_unique',
  /** unique or primary key constraint on columns "id" */
  TenantsPkey = 'tenants_pkey'
}

/** input type for inserting data into table "tenants" */
export type Tenants_Insert_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  owner?: InputMaybe<UserProfiles_Obj_Rel_Insert_Input>;
  ownerId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type Tenants_Max_Fields = {
  __typename?: 'tenants_max_fields';
  code?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  ownerId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type Tenants_Min_Fields = {
  __typename?: 'tenants_min_fields';
  code?: Maybe<Scalars['String']['output']>;
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  description?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  name?: Maybe<Scalars['String']['output']>;
  ownerId?: Maybe<Scalars['uuid']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "tenants" */
export type Tenants_Mutation_Response = {
  __typename?: 'tenants_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<Tenants>;
};

/** on_conflict condition type for table "tenants" */
export type Tenants_On_Conflict = {
  constraint: Tenants_Constraint;
  update_columns?: Array<Tenants_Update_Column>;
  where?: InputMaybe<Tenants_Bool_Exp>;
};

/** Ordering options when selecting data from "tenants". */
export type Tenants_Order_By = {
  code?: InputMaybe<Order_By>;
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  owner?: InputMaybe<UserProfiles_Order_By>;
  ownerId?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: tenants */
export type Tenants_Pk_Columns_Input = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "tenants" */
export enum Tenants_Select_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  OwnerId = 'ownerId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "tenants" */
export type Tenants_Set_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "tenants" */
export type Tenants_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: Tenants_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type Tenants_Stream_Cursor_Value_Input = {
  code?: InputMaybe<Scalars['String']['input']>;
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  description?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  name?: InputMaybe<Scalars['String']['input']>;
  ownerId?: InputMaybe<Scalars['uuid']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "tenants" */
export enum Tenants_Update_Column {
  /** column name */
  Code = 'code',
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  OwnerId = 'ownerId',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type Tenants_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<Tenants_Set_Input>;
  /** filter the rows which have to be updated */
  where: Tenants_Bool_Exp;
};

/** Boolean expression to compare columns of type "timestamptz". All fields are combined with logical 'AND'. */
export type Timestamptz_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['timestamptz']['input']>;
  _gt?: InputMaybe<Scalars['timestamptz']['input']>;
  _gte?: InputMaybe<Scalars['timestamptz']['input']>;
  _in?: InputMaybe<Array<Scalars['timestamptz']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['timestamptz']['input']>;
  _lte?: InputMaybe<Scalars['timestamptz']['input']>;
  _neq?: InputMaybe<Scalars['timestamptz']['input']>;
  _nin?: InputMaybe<Array<Scalars['timestamptz']['input']>>;
};

/** columns and relationships of "user_profiles" */
export type UserProfiles = {
  __typename?: 'userProfiles';
  createdAt: Scalars['timestamptz']['output'];
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  department: Scalars['String']['output'];
  email: Scalars['String']['output'];
  firstName: Scalars['String']['output'];
  id: Scalars['uuid']['output'];
  lastName: Scalars['String']['output'];
  middleName?: Maybe<Scalars['String']['output']>;
  phone?: Maybe<Scalars['String']['output']>;
  position: Scalars['String']['output'];
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregated selection of "user_profiles" */
export type UserProfiles_Aggregate = {
  __typename?: 'userProfiles_aggregate';
  aggregate?: Maybe<UserProfiles_Aggregate_Fields>;
  nodes: Array<UserProfiles>;
};

/** aggregate fields of "user_profiles" */
export type UserProfiles_Aggregate_Fields = {
  __typename?: 'userProfiles_aggregate_fields';
  count: Scalars['Int']['output'];
  max?: Maybe<UserProfiles_Max_Fields>;
  min?: Maybe<UserProfiles_Min_Fields>;
};


/** aggregate fields of "user_profiles" */
export type UserProfiles_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<UserProfiles_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']['input']>;
};

/** Boolean expression to filter rows from the table "user_profiles". All fields are combined with a logical 'AND'. */
export type UserProfiles_Bool_Exp = {
  _and?: InputMaybe<Array<UserProfiles_Bool_Exp>>;
  _not?: InputMaybe<UserProfiles_Bool_Exp>;
  _or?: InputMaybe<Array<UserProfiles_Bool_Exp>>;
  createdAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  createdBy?: InputMaybe<Uuid_Comparison_Exp>;
  deletedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  deletedBy?: InputMaybe<Uuid_Comparison_Exp>;
  department?: InputMaybe<String_Comparison_Exp>;
  email?: InputMaybe<String_Comparison_Exp>;
  firstName?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Uuid_Comparison_Exp>;
  lastName?: InputMaybe<String_Comparison_Exp>;
  middleName?: InputMaybe<String_Comparison_Exp>;
  phone?: InputMaybe<String_Comparison_Exp>;
  position?: InputMaybe<String_Comparison_Exp>;
  updatedAt?: InputMaybe<Timestamptz_Comparison_Exp>;
  updatedBy?: InputMaybe<Uuid_Comparison_Exp>;
};

/** unique or primary key constraints on table "user_profiles" */
export enum UserProfiles_Constraint {
  /** unique or primary key constraint on columns "email" */
  UserProfilesEmailUnique = 'user_profiles_email_unique',
  /** unique or primary key constraint on columns "id" */
  UserProfilesPkey = 'user_profiles_pkey'
}

/** input type for inserting data into table "user_profiles" */
export type UserProfiles_Insert_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  department?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  middleName?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** aggregate max on columns */
export type UserProfiles_Max_Fields = {
  __typename?: 'userProfiles_max_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  department?: Maybe<Scalars['String']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  firstName?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastName?: Maybe<Scalars['String']['output']>;
  middleName?: Maybe<Scalars['String']['output']>;
  phone?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** aggregate min on columns */
export type UserProfiles_Min_Fields = {
  __typename?: 'userProfiles_min_fields';
  createdAt?: Maybe<Scalars['timestamptz']['output']>;
  createdBy?: Maybe<Scalars['uuid']['output']>;
  deletedAt?: Maybe<Scalars['timestamptz']['output']>;
  deletedBy?: Maybe<Scalars['uuid']['output']>;
  department?: Maybe<Scalars['String']['output']>;
  email?: Maybe<Scalars['String']['output']>;
  firstName?: Maybe<Scalars['String']['output']>;
  id?: Maybe<Scalars['uuid']['output']>;
  lastName?: Maybe<Scalars['String']['output']>;
  middleName?: Maybe<Scalars['String']['output']>;
  phone?: Maybe<Scalars['String']['output']>;
  position?: Maybe<Scalars['String']['output']>;
  updatedAt?: Maybe<Scalars['timestamptz']['output']>;
  updatedBy?: Maybe<Scalars['uuid']['output']>;
};

/** response of any mutation on the table "user_profiles" */
export type UserProfiles_Mutation_Response = {
  __typename?: 'userProfiles_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int']['output'];
  /** data from the rows affected by the mutation */
  returning: Array<UserProfiles>;
};

/** input type for inserting object relation for remote table "user_profiles" */
export type UserProfiles_Obj_Rel_Insert_Input = {
  data: UserProfiles_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<UserProfiles_On_Conflict>;
};

/** on_conflict condition type for table "user_profiles" */
export type UserProfiles_On_Conflict = {
  constraint: UserProfiles_Constraint;
  update_columns?: Array<UserProfiles_Update_Column>;
  where?: InputMaybe<UserProfiles_Bool_Exp>;
};

/** Ordering options when selecting data from "user_profiles". */
export type UserProfiles_Order_By = {
  createdAt?: InputMaybe<Order_By>;
  createdBy?: InputMaybe<Order_By>;
  deletedAt?: InputMaybe<Order_By>;
  deletedBy?: InputMaybe<Order_By>;
  department?: InputMaybe<Order_By>;
  email?: InputMaybe<Order_By>;
  firstName?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  lastName?: InputMaybe<Order_By>;
  middleName?: InputMaybe<Order_By>;
  phone?: InputMaybe<Order_By>;
  position?: InputMaybe<Order_By>;
  updatedAt?: InputMaybe<Order_By>;
  updatedBy?: InputMaybe<Order_By>;
};

/** primary key columns input for table: user_profiles */
export type UserProfiles_Pk_Columns_Input = {
  id: Scalars['uuid']['input'];
};

/** select columns of table "user_profiles" */
export enum UserProfiles_Select_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Department = 'department',
  /** column name */
  Email = 'email',
  /** column name */
  FirstName = 'firstName',
  /** column name */
  Id = 'id',
  /** column name */
  LastName = 'lastName',
  /** column name */
  MiddleName = 'middleName',
  /** column name */
  Phone = 'phone',
  /** column name */
  Position = 'position',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

/** input type for updating data in table "user_profiles" */
export type UserProfiles_Set_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  department?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  middleName?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** Streaming cursor of the table "userProfiles" */
export type UserProfiles_Stream_Cursor_Input = {
  /** Stream column input with initial value */
  initial_value: UserProfiles_Stream_Cursor_Value_Input;
  /** cursor ordering */
  ordering?: InputMaybe<Cursor_Ordering>;
};

/** Initial value of the column from where the streaming should start */
export type UserProfiles_Stream_Cursor_Value_Input = {
  createdAt?: InputMaybe<Scalars['timestamptz']['input']>;
  createdBy?: InputMaybe<Scalars['uuid']['input']>;
  deletedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  deletedBy?: InputMaybe<Scalars['uuid']['input']>;
  department?: InputMaybe<Scalars['String']['input']>;
  email?: InputMaybe<Scalars['String']['input']>;
  firstName?: InputMaybe<Scalars['String']['input']>;
  id?: InputMaybe<Scalars['uuid']['input']>;
  lastName?: InputMaybe<Scalars['String']['input']>;
  middleName?: InputMaybe<Scalars['String']['input']>;
  phone?: InputMaybe<Scalars['String']['input']>;
  position?: InputMaybe<Scalars['String']['input']>;
  updatedAt?: InputMaybe<Scalars['timestamptz']['input']>;
  updatedBy?: InputMaybe<Scalars['uuid']['input']>;
};

/** update columns of table "user_profiles" */
export enum UserProfiles_Update_Column {
  /** column name */
  CreatedAt = 'createdAt',
  /** column name */
  CreatedBy = 'createdBy',
  /** column name */
  DeletedAt = 'deletedAt',
  /** column name */
  DeletedBy = 'deletedBy',
  /** column name */
  Department = 'department',
  /** column name */
  Email = 'email',
  /** column name */
  FirstName = 'firstName',
  /** column name */
  Id = 'id',
  /** column name */
  LastName = 'lastName',
  /** column name */
  MiddleName = 'middleName',
  /** column name */
  Phone = 'phone',
  /** column name */
  Position = 'position',
  /** column name */
  UpdatedAt = 'updatedAt',
  /** column name */
  UpdatedBy = 'updatedBy'
}

export type UserProfiles_Updates = {
  /** sets the columns of the filtered rows to the given values */
  _set?: InputMaybe<UserProfiles_Set_Input>;
  /** filter the rows which have to be updated */
  where: UserProfiles_Bool_Exp;
};

/** Boolean expression to compare columns of type "uuid". All fields are combined with logical 'AND'. */
export type Uuid_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['uuid']['input']>;
  _gt?: InputMaybe<Scalars['uuid']['input']>;
  _gte?: InputMaybe<Scalars['uuid']['input']>;
  _in?: InputMaybe<Array<Scalars['uuid']['input']>>;
  _is_null?: InputMaybe<Scalars['Boolean']['input']>;
  _lt?: InputMaybe<Scalars['uuid']['input']>;
  _lte?: InputMaybe<Scalars['uuid']['input']>;
  _neq?: InputMaybe<Scalars['uuid']['input']>;
  _nin?: InputMaybe<Array<Scalars['uuid']['input']>>;
};

export type GetComponentFullQueryVariables = Exact<{
  id: Scalars['uuid']['input'];
}>;


export type GetComponentFullQuery = { __typename?: 'query_root', component?: { __typename?: 'ApplicationComponent', id: any, code: string, name: string, description?: string | null, createdAt: any, createdBy?: any | null, updatedAt?: any | null, updatedBy?: any | null, state?: { __typename?: 'DirectoryObject', id: any, name: string, color?: string | null } | null } | null, functions: Array<{ __typename?: 'ApplicationComponentFunctionMap', function: { __typename?: 'FunctionGeneric', id: any, code: string, name: string, description?: string | null } }>, dataObjects: Array<{ __typename?: 'ApplicationComponentDataObjectMap', dataObject: { __typename?: 'DataObject', id: any, code: string, name: string, description?: string | null } }>, interfaces: Array<{ __typename?: 'ApplicationComponentInterfaceMap', interface: { __typename?: 'InterfaceGeneric', id: any, code: string, name: string, description?: string | null } }>, events: Array<{ __typename?: 'ApplicationComponentEventMap', event: { __typename?: 'EventGeneric', id: any, code: string, name: string, description?: string | null } }>, systemSoftware: Array<{ __typename?: 'ApplicationComponentSystemSoftwareMap', kind: any, systemSoftware: { __typename?: 'SystemSoftware', id: any, code: string, name: string } }>, technologyNodes: Array<{ __typename?: 'ApplicationComponentTechnologyNodeMap', node: { __typename?: 'TechnologyNode', id: any, code: string, name: string } }>, technologyNetworks: Array<{ __typename?: 'ApplicationComponentTechnologyLogicalNetworkMap', logicalNetwork: { __typename?: 'TechnologyNetwork', id: any, code: string, name: string } }>, parentComponents: Array<{ __typename?: 'ApplicationComponentHierarchyMap', componentParent: { __typename?: 'ApplicationComponent', id: any, code: string, name: string, description?: string | null } }>, childComponents: Array<{ __typename?: 'ApplicationComponentHierarchyMap', componentChild: { __typename?: 'ApplicationComponent', id: any, code: string, name: string, description?: string | null } }>, incomingFlows: Array<{ __typename?: 'FlowGeneric', id: any, code: string, name: string, description?: string | null, sourceComponent?: { __typename?: 'ApplicationComponent', id: any, code: string, name: string } | null, targetComponent?: { __typename?: 'ApplicationComponent', id: any, code: string, name: string } | null }>, outgoingFlows: Array<{ __typename?: 'FlowGeneric', id: any, code: string, name: string, description?: string | null, sourceComponent?: { __typename?: 'ApplicationComponent', id: any, code: string, name: string } | null, targetComponent?: { __typename?: 'ApplicationComponent', id: any, code: string, name: string } | null }>, stakeholders: Array<{ __typename?: 'ApplicationComponentStakeholderMap', role: any, stakeholder: { __typename?: 'Stakeholder', id: any, code: string, name: string, description?: string | null } }> };

export type GetComponentsQueryVariables = Exact<{
  where: ApplicationComponent_Bool_Exp;
  limit: Scalars['Int']['input'];
  offset: Scalars['Int']['input'];
}>;


export type GetComponentsQuery = { __typename?: 'query_root', ApplicationComponent: Array<{ __typename?: 'ApplicationComponent', id: any, code: string, name: string, description?: string | null, createdAt: any, createdBy?: any | null, updatedAt?: any | null, updatedBy?: any | null, state?: { __typename?: 'DirectoryObject', id: any, code: string, name: string, color?: string | null } | null, functions: Array<{ __typename?: 'ApplicationComponentFunctionMap', function: { __typename?: 'FunctionGeneric', id: any, code: string, name: string } }>, products: Array<{ __typename?: 'ApplicationComponentProductMap', product: { __typename?: 'BusinessProduct', id: any, code: string, name: string } }>, interfaces: Array<{ __typename?: 'ApplicationComponentInterfaceMap', interface: { __typename?: 'InterfaceGeneric', id: any, code: string, name: string } }>, criticalLevel?: { __typename?: 'DirectoryObject', id: any, code: string, name: string } | null, failoverType?: { __typename?: 'DirectoryObject', id: any, code: string, name: string } | null, licenseType?: { __typename?: 'DirectoryObject', code: string, id: any, name: string } | null, monitoringLevel?: { __typename?: 'DirectoryObject', code: string, id: any, name: string } | null, recoveryTime?: { __typename?: 'DirectoryObject', id: any, code: string, name: string } | null, redundancyType?: { __typename?: 'DirectoryObject', id: any, code: string, name: string, color?: string | null } | null, scalingType?: { __typename?: 'DirectoryObject', id: any, code: string, name: string, color?: string | null } | null, style?: { __typename?: 'DirectoryObject', id: any, code: string, name: string } | null, systemSoftware: Array<{ __typename?: 'ApplicationComponentSystemSoftwareMap', kind: any, systemSoftware: { __typename?: 'SystemSoftware', id: any, code: string, kind: any, licenseType?: { __typename?: 'DirectoryObject', code: string, color?: string | null, id: any, name: string } | null } }> }>, ApplicationComponentAggregate: { __typename?: 'ApplicationComponent_aggregate', aggregate?: { __typename?: 'ApplicationComponent_aggregate_fields', count: number } | null } };

export type GetApplicationFunctionByPkQueryVariables = Exact<{
  id: Scalars['uuid']['input'];
}>;


export type GetApplicationFunctionByPkQuery = { __typename?: 'query_root', FunctionGenericByPk?: { __typename?: 'FunctionGeneric', id: any, code: string, name: string, description?: string | null, createdAt: any, createdBy?: any | null, updatedAt?: any | null, updatedBy?: any | null } | null };

export type GetApplicationFunctionsQueryVariables = Exact<{
  where: FunctionGeneric_Bool_Exp;
  limit: Scalars['Int']['input'];
  offset: Scalars['Int']['input'];
}>;


export type GetApplicationFunctionsQuery = { __typename?: 'query_root', FunctionGeneric: Array<{ __typename?: 'FunctionGeneric', id: any, code: string, name: string, description?: string | null, createdAt: any, createdBy?: any | null, updatedAt?: any | null, updatedBy?: any | null }>, FunctionGenericAggregate: { __typename?: 'FunctionGeneric_aggregate', aggregate?: { __typename?: 'FunctionGeneric_aggregate_fields', count: number } | null } };

export type GetFunctionsByIdsQueryVariables = Exact<{
  ids: Array<Scalars['uuid']['input']> | Scalars['uuid']['input'];
}>;


export type GetFunctionsByIdsQuery = { __typename?: 'query_root', FunctionGeneric: Array<{ __typename?: 'FunctionGeneric', id: any, code: string, name: string, description?: string | null }> };

export type GetDataObjectByPkQueryVariables = Exact<{
  id: Scalars['uuid']['input'];
}>;


export type GetDataObjectByPkQuery = { __typename?: 'query_root', DataObjectByPk?: { __typename?: 'DataObject', id: any, code: string, name: string, description?: string | null, createdAt: any, createdBy?: any | null, updatedAt?: any | null, updatedBy?: any | null } | null };

export type GetDataObjectFullQueryVariables = Exact<{
  id: Scalars['uuid']['input'];
}>;


export type GetDataObjectFullQuery = { __typename?: 'query_root', dataObject?: { __typename?: 'DataObject', id: any, code: string, name: string, description?: string | null, createdAt: any, createdBy?: any | null, updatedAt?: any | null, updatedBy?: any | null } | null, componentMaps: Array<{ __typename?: 'ApplicationComponentDataObjectMap', component: { __typename?: 'ApplicationComponent', id: any, code: string, name: string, description?: string | null } }>, functionMaps: Array<{ __typename?: 'ApplicationFunctionDataObjectMap', functionId: any, accessKind: any, componentId: any, component: { __typename?: 'ApplicationComponent', id: any, code: string, name: string } }> };

export type GetDataObjectsQueryVariables = Exact<{
  where: DataObject_Bool_Exp;
  limit: Scalars['Int']['input'];
  offset: Scalars['Int']['input'];
}>;


export type GetDataObjectsQuery = { __typename?: 'query_root', DataObject: Array<{ __typename?: 'DataObject', id: any, code: string, name: string, description?: string | null, createdAt: any, createdBy?: any | null, updatedAt?: any | null, updatedBy?: any | null }>, DataObjectAggregate: { __typename?: 'DataObject_aggregate', aggregate?: { __typename?: 'DataObject_aggregate_fields', count: number } | null } };

export type GetAllDirectoriesQueryVariables = Exact<{ [key: string]: never; }>;


export type GetAllDirectoriesQuery = { __typename?: 'query_root', DirectoryObject: Array<{ __typename?: 'DirectoryObject', id: any, kind: any, code: string, name: string }> };

export type GetDirectoryCountQueryVariables = Exact<{
  kind: Scalars['directory_kind_enum']['input'];
}>;


export type GetDirectoryCountQuery = { __typename?: 'query_root', DirectoryObjectAggregate: { __typename?: 'DirectoryObject_aggregate', aggregate?: { __typename?: 'DirectoryObject_aggregate_fields', count: number } | null } };

export type GetDirectoryItemByPkQueryVariables = Exact<{
  id: Scalars['uuid']['input'];
}>;


export type GetDirectoryItemByPkQuery = { __typename?: 'query_root', DirectoryObjectByPk?: { __typename?: 'DirectoryObject', id: any, code: string, name: string, description?: string | null, color?: string | null, byDefault: boolean, createdAt: any, createdBy?: any | null, updatedAt?: any | null, updatedBy?: any | null } | null };

export type GetDirectoryItemsQueryVariables = Exact<{
  kind: Scalars['directory_kind_enum']['input'];
}>;


export type GetDirectoryItemsQuery = { __typename?: 'query_root', DirectoryObject: Array<{ __typename?: 'DirectoryObject', id: any, code: string, name: string, description?: string | null, color?: string | null, byDefault: boolean, createdAt: any, createdBy?: any | null, updatedAt?: any | null, updatedBy?: any | null }> };

export type GetDirectoryRelationsQueryVariables = Exact<{
  sourceId: Scalars['uuid']['input'];
}>;


export type GetDirectoryRelationsQuery = { __typename?: 'query_root', DirectoryItemsMap: Array<{ __typename?: 'DirectoryItemsMap', createdAt: any, type: any, sourceId: any, targetId: any, target: { __typename?: 'DirectoryObject', id: any, code: string, name: string, description?: string | null, kind: any } }> };

export type GetSolutionFullQueryVariables = Exact<{
  id: Scalars['uuid']['input'];
}>;


export type GetSolutionFullQuery = { __typename?: 'query_root', solution?: { __typename?: 'Solution', id: any, code: string, name: string, description?: string | null, context: string, decision: string, consequences: string, alternatives: string, decisionStatus: any, implementationStatus: any, createdAt: any, createdBy?: any | null, updatedAt?: any | null, updatedBy?: any | null, components: Array<{ __typename?: 'SolutionApplicationComponentMap', component: { __typename?: 'ApplicationComponent', id: any, code: string, name: string, description?: string | null } }>, functions: Array<{ __typename?: 'SolutionApplicationFunctionMap', componentId: any, functionId: any }>, dataObjects: Array<{ __typename?: 'SolutionDataObjectMap', componentId: any, dataObjectId: any }>, flows: Array<{ __typename?: 'SolutionFlowMap', flow: { __typename?: 'FlowGeneric', id: any, code: string, name: string, description?: string | null, sourceComponent?: { __typename?: 'ApplicationComponent', id: any, code: string, name: string } | null, targetComponent?: { __typename?: 'ApplicationComponent', id: any, code: string, name: string } | null } }>, motivations: Array<{ __typename?: 'SolutionMotivationElementMap', motivation: { __typename?: 'MotivationElementGeneric', id: any, code: string, name: string, description?: string | null } }>, stakeholders: Array<{ __typename?: 'SolutionStakeholderMap', role: any, stakeholder: { __typename?: 'Stakeholder', id: any, code: string, name: string, description?: string | null } }> } | null, technologyNodes: Array<{ __typename?: 'SolutionTechnologyNodeMap', node: { __typename?: 'TechnologyNode', id: any, code: string, name: string, description?: string | null } }> };

export type GetSolutionsQueryVariables = Exact<{
  where: Solution_Bool_Exp;
  limit: Scalars['Int']['input'];
  offset: Scalars['Int']['input'];
}>;


export type GetSolutionsQuery = { __typename?: 'query_root', Solution: Array<{ __typename?: 'Solution', id: any, code: string, name: string, description?: string | null, context: string, decision: string, consequences: string, alternatives: string, decisionStatus: any, implementationStatus: any, createdAt: any, createdBy?: any | null, updatedAt?: any | null, updatedBy?: any | null }>, SolutionAggregate: { __typename?: 'Solution_aggregate', aggregate?: { __typename?: 'Solution_aggregate_fields', count: number } | null } };

export type GetSystemSoftwareByPkQueryVariables = Exact<{
  id: Scalars['uuid']['input'];
}>;


export type GetSystemSoftwareByPkQuery = { __typename?: 'query_root', SystemSoftwareByPk?: { __typename?: 'SystemSoftware', id: any, code: string, name: string, description?: string | null, version?: string | null, kind: any, createdAt: any, createdBy?: any | null, updatedAt?: any | null, updatedBy?: any | null, type?: { __typename?: 'DirectoryObject', id: any, name: string } | null, licenseType?: { __typename?: 'DirectoryObject', id: any, name: string } | null } | null };

export type GetSystemSoftwareQueryVariables = Exact<{
  where: SystemSoftware_Bool_Exp;
  limit: Scalars['Int']['input'];
  offset: Scalars['Int']['input'];
}>;


export type GetSystemSoftwareQuery = { __typename?: 'query_root', SystemSoftware: Array<{ __typename?: 'SystemSoftware', id: any, code: string, name: string, description?: string | null, version?: string | null, kind: any, createdAt: any, createdBy?: any | null, updatedAt?: any | null, updatedBy?: any | null, type?: { __typename?: 'DirectoryObject', id: any, name: string } | null, licenseType?: { __typename?: 'DirectoryObject', id: any, name: string } | null }>, SystemSoftwareAggregate: { __typename?: 'SystemSoftware_aggregate', aggregate?: { __typename?: 'SystemSoftware_aggregate_fields', count: number } | null } };

export type GetSystemSoftwareListQueryVariables = Exact<{
  where: SystemSoftware_Bool_Exp;
  limit: Scalars['Int']['input'];
  offset: Scalars['Int']['input'];
}>;


export type GetSystemSoftwareListQuery = { __typename?: 'query_root', SystemSoftware: Array<{ __typename?: 'SystemSoftware', id: any, code: string, name: string }>, SystemSoftwareAggregate: { __typename?: 'SystemSoftware_aggregate', aggregate?: { __typename?: 'SystemSoftware_aggregate_fields', count: number } | null } };
